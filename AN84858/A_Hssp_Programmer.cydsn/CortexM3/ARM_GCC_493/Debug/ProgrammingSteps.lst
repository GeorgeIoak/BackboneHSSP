ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ProgrammingSteps.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	checksum_Privileged
  19              		.bss
  20              		.align	2
  21              		.type	checksum_Privileged, %object
  22              		.size	checksum_Privileged, 4
  23              	checksum_Privileged:
  24 0000 00000000 		.space	4
  25              		.global	statusCode
  26              		.align	2
  27              		.type	statusCode, %object
  28              		.size	statusCode, 4
  29              	statusCode:
  30 0004 00000000 		.space	4
  31              		.global	result
  32              		.type	result, %object
  33              		.size	result, 1
  34              	result:
  35 0008 00       		.space	1
  36              		.global	chipProtectionData_Chip
  37              		.type	chipProtectionData_Chip, %object
  38              		.size	chipProtectionData_Chip, 1
  39              	chipProtectionData_Chip:
  40 0009 00       		.space	1
  41              		.comm	flow,1,1
  42 000a 0000     		.section	.text.PollSromStatus,"ax",%progbits
  43              		.align	2
  44              		.global	PollSromStatus
  45              		.thumb
  46              		.thumb_func
  47              		.type	PollSromStatus, %function
  48              	PollSromStatus:
  49              	.LFB63:
  50              		.file 1 "ProgrammingSteps.c"
   1:ProgrammingSteps.c **** /******************************************************************************
   2:ProgrammingSteps.c **** * File Name: ProgrammingSteps.c
   3:ProgrammingSteps.c **** * Version 1.0
   4:ProgrammingSteps.c **** *
   5:ProgrammingSteps.c **** * Description:
   6:ProgrammingSteps.c **** *  This file provides the source code for the high level Programming functions 
   7:ProgrammingSteps.c **** *  used by the main code to program target PSoC 4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 2


   8:ProgrammingSteps.c **** *
   9:ProgrammingSteps.c **** * Owner:
  10:ProgrammingSteps.c **** *	Tushar Rastogi, Application Engineer (tusr@cypress.com)
  11:ProgrammingSteps.c **** *
  12:ProgrammingSteps.c **** * Related Document:
  13:ProgrammingSteps.c **** *	AN84858 - PSoC 4 Programming using an External Microcontroller (HSSP)
  14:ProgrammingSteps.c **** *
  15:ProgrammingSteps.c **** * Hardware Dependency:
  16:ProgrammingSteps.c **** *   PSoC 5LP Development Kit - CY8CKIT-050
  17:ProgrammingSteps.c **** *
  18:ProgrammingSteps.c **** * Code Tested With:
  19:ProgrammingSteps.c **** *	PSoC Creator 3.2
  20:ProgrammingSteps.c **** *	ARM GCC 4.8.4
  21:ProgrammingSteps.c **** *	CY8CKIT-050
  22:ProgrammingSteps.c **** *
  23:ProgrammingSteps.c **** *******************************************************************************
  24:ProgrammingSteps.c **** * Copyright (2015), Cypress Semiconductor Corporation.
  25:ProgrammingSteps.c **** *******************************************************************************
  26:ProgrammingSteps.c **** * This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  27:ProgrammingSteps.c **** * protected by and subject to worldwide patent protection (United States and
  28:ProgrammingSteps.c **** * foreign), United States copyright laws and international treaty provisions.
  29:ProgrammingSteps.c **** * Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
  30:ProgrammingSteps.c **** * license to copy, use, modify, create derivative works of, and compile the
  31:ProgrammingSteps.c **** * Cypress Source Code and derivative works for the sole purpose of creating
  32:ProgrammingSteps.c **** * custom software in support of licensee product to be used only in conjunction
  33:ProgrammingSteps.c **** * with a Cypress integrated circuit as specified in the applicable agreement.
  34:ProgrammingSteps.c **** * Any reproduction, modification, translation, compilation, or representation
  35:ProgrammingSteps.c **** * of this software except as specified above is prohibited without the express
  36:ProgrammingSteps.c **** * written permission of Cypress.
  37:ProgrammingSteps.c **** *
  38:ProgrammingSteps.c **** * Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
  39:ProgrammingSteps.c **** * REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  40:ProgrammingSteps.c **** * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  41:ProgrammingSteps.c **** * Cypress reserves the right to make changes without further notice to the
  42:ProgrammingSteps.c **** * materials described herein. Cypress does not assume any liability arising out
  43:ProgrammingSteps.c **** * of the application or use of any product or circuit described herein. Cypress
  44:ProgrammingSteps.c **** * does not authorize its products for use as critical components in life-support
  45:ProgrammingSteps.c **** * systems where a malfunction or failure may reasonably be expected to result in
  46:ProgrammingSteps.c **** * significant injury to the user. The inclusion of Cypress' product in a life-
  47:ProgrammingSteps.c **** * support systems application implies that the manufacturer assumes all risk of
  48:ProgrammingSteps.c **** * such use and in doing so indemnifies Cypress against all charges. Use may be
  49:ProgrammingSteps.c **** * limited by and subject to the applicable Cypress software license agreement.
  50:ProgrammingSteps.c **** ******************************************************************************/
  51:ProgrammingSteps.c **** 
  52:ProgrammingSteps.c **** /******************************************************************************
  53:ProgrammingSteps.c **** *   Header file Inclusion
  54:ProgrammingSteps.c **** ******************************************************************************/
  55:ProgrammingSteps.c **** #include "ProgrammingSteps.h"
  56:ProgrammingSteps.c **** #include "SWD_PhysicalLayer.h"
  57:ProgrammingSteps.c **** #include "SWD_UpperPacketLayer.h"
  58:ProgrammingSteps.c **** #include "SWD_PacketLayer.h"
  59:ProgrammingSteps.c **** #include "DataFetch.h"
  60:ProgrammingSteps.c **** #include "Timeout.h"
  61:ProgrammingSteps.c **** #include "project.h"
  62:ProgrammingSteps.c **** 
  63:ProgrammingSteps.c **** /******************************************************************************
  64:ProgrammingSteps.c **** *   Global Variable definitions
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 3


  65:ProgrammingSteps.c **** ******************************************************************************/
  66:ProgrammingSteps.c **** unsigned long checksum_Privileged 		= 0;
  67:ProgrammingSteps.c **** unsigned long statusCode 				= 0;
  68:ProgrammingSteps.c **** 
  69:ProgrammingSteps.c **** unsigned char result 					= 0;
  70:ProgrammingSteps.c **** unsigned char chipProtectionData_Chip	= 0;
  71:ProgrammingSteps.c **** 
  72:ProgrammingSteps.c **** enum Transition_mode {OPEN_XXX, VIRGIN_OPEN, PROT_XXX, WRONG_TRANSITION } flow;
  73:ProgrammingSteps.c **** 
  74:ProgrammingSteps.c **** /******************************************************************************
  75:ProgrammingSteps.c **** *   Function Definitions
  76:ProgrammingSteps.c **** ******************************************************************************/
  77:ProgrammingSteps.c **** 
  78:ProgrammingSteps.c **** 
  79:ProgrammingSteps.c **** /******************************************************************************
  80:ProgrammingSteps.c **** * Function Name: PollSromStatus
  81:ProgrammingSteps.c **** *******************************************************************************
  82:ProgrammingSteps.c **** * Summary:
  83:ProgrammingSteps.c **** *  Polls the SROM_SYSREQ_BIT and SROM_PRIVILEGED_BIT in the CPUSS_SYSREQ 
  84:ProgrammingSteps.c **** *  register till it is reset or a timeout condition occurred, whichever is 
  85:ProgrammingSteps.c **** *  earlier. For a SROM polling timeout error, the timeout error status bit is 
  86:ProgrammingSteps.c **** *  set in swd_PacketAck variable and CPUSS_SYSARG register is read to get the 
  87:ProgrammingSteps.c **** *  error status code. If timeout does not happen, the CPUSS_SYSARG register is 
  88:ProgrammingSteps.c **** *  read to determine if the task executed successfully.
  89:ProgrammingSteps.c **** *
  90:ProgrammingSteps.c **** * Parameters:
  91:ProgrammingSteps.c **** *  None.
  92:ProgrammingSteps.c **** *
  93:ProgrammingSteps.c **** * Return:
  94:ProgrammingSteps.c **** *  SUCCESS - SROM executed the task successfully
  95:ProgrammingSteps.c **** *  FAILURE - SROM task is not executed successfully and a timeout error occured.
  96:ProgrammingSteps.c **** *            The failure code is stored in the statusCode global variable.
  97:ProgrammingSteps.c **** *
  98:ProgrammingSteps.c **** * Note:
  99:ProgrammingSteps.c **** *  This function is called after non volatile memory operations like Read,  
 100:ProgrammingSteps.c **** *  Write of Flash, to check if SROM task has been executed which is indicated
 101:ProgrammingSteps.c **** *  by SUCCESS. The status is read from the CPUSS_SYSARG register.
 102:ProgrammingSteps.c **** *
 103:ProgrammingSteps.c **** ******************************************************************************/
 104:ProgrammingSteps.c **** unsigned char PollSromStatus(void)
 105:ProgrammingSteps.c **** {
  51              		.loc 1 105 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 8
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55 0000 80B5     		push	{r7, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 82B0     		sub	sp, sp, #8
  60              		.cfi_def_cfa_offset 16
  61 0004 00AF     		add	r7, sp, #0
  62              		.cfi_def_cfa_register 7
 106:ProgrammingSteps.c ****     unsigned long time_elapsed = 0;
  63              		.loc 1 106 0
  64 0006 0023     		movs	r3, #0
  65 0008 7B60     		str	r3, [r7, #4]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 4


  66              	.L3:
 107:ProgrammingSteps.c ****     
 108:ProgrammingSteps.c ****     do
 109:ProgrammingSteps.c ****     {
 110:ProgrammingSteps.c **** 	    /* Read CPUSS_SYSREQ register and check if SROM_SYSREQ_BIT and 
 111:ProgrammingSteps.c **** 		SROM_PRIVILEGED_BIT are reset to 0 */
 112:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSREQ, &statusCode);
  67              		.loc 1 112 0 discriminator 2
  68 000a 1F48     		ldr	r0, .L7
  69 000c 1F49     		ldr	r1, .L7+4
  70 000e FFF7FEFF 		bl	Read_IO
 113:ProgrammingSteps.c **** 		
 114:ProgrammingSteps.c **** 		statusCode &= (SROM_SYSREQ_BIT | SROM_PRIVILEGED_BIT);
  71              		.loc 1 114 0 discriminator 2
  72 0012 1E4B     		ldr	r3, .L7+4
  73 0014 1B68     		ldr	r3, [r3]
  74 0016 03F01043 		and	r3, r3, #-1879048192
  75 001a 1C4A     		ldr	r2, .L7+4
  76 001c 1360     		str	r3, [r2]
 115:ProgrammingSteps.c **** 	    
 116:ProgrammingSteps.c **** 		time_elapsed++;
  77              		.loc 1 116 0 discriminator 2
  78 001e 7B68     		ldr	r3, [r7, #4]
  79 0020 0133     		adds	r3, r3, #1
  80 0022 7B60     		str	r3, [r7, #4]
 117:ProgrammingSteps.c **** 		
 118:ProgrammingSteps.c ****     }while ((statusCode != 0) && (time_elapsed <= SROM_POLLING_TIMEOUT));
  81              		.loc 1 118 0 discriminator 2
  82 0024 194B     		ldr	r3, .L7+4
  83 0026 1B68     		ldr	r3, [r3]
  84 0028 002B     		cmp	r3, #0
  85 002a 03D0     		beq	.L2
  86              		.loc 1 118 0 is_stmt 0 discriminator 1
  87 002c 7B68     		ldr	r3, [r7, #4]
  88 002e 184A     		ldr	r2, .L7+8
  89 0030 9342     		cmp	r3, r2
  90 0032 EAD9     		bls	.L3
  91              	.L2:
 119:ProgrammingSteps.c **** 	
 120:ProgrammingSteps.c **** 	/* If time exceeds the timeout value, set the SROM_TIMEOUT_ERROR bit in 
 121:ProgrammingSteps.c **** 	   swd_PacketAck */
 122:ProgrammingSteps.c ****     if (time_elapsed > SROM_POLLING_TIMEOUT )
  92              		.loc 1 122 0 is_stmt 1
  93 0034 7B68     		ldr	r3, [r7, #4]
  94 0036 164A     		ldr	r2, .L7+8
  95 0038 9342     		cmp	r3, r2
  96 003a 0CD9     		bls	.L4
 123:ProgrammingSteps.c ****     {
 124:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
  97              		.loc 1 124 0
  98 003c 154B     		ldr	r3, .L7+12
  99 003e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 100 0040 43F02003 		orr	r3, r3, #32
 101 0044 DAB2     		uxtb	r2, r3
 102 0046 134B     		ldr	r3, .L7+12
 103 0048 1A70     		strb	r2, [r3]
 125:ProgrammingSteps.c **** 		
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 5


 126:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSARG, &statusCode);
 104              		.loc 1 126 0
 105 004a 1348     		ldr	r0, .L7+16
 106 004c 0F49     		ldr	r1, .L7+4
 107 004e FFF7FEFF 		bl	Read_IO
 127:ProgrammingSteps.c **** 	    
 128:ProgrammingSteps.c **** 		return (FAILURE);
 108              		.loc 1 128 0
 109 0052 0023     		movs	r3, #0
 110 0054 14E0     		b	.L5
 111              	.L4:
 129:ProgrammingSteps.c ****     }
 130:ProgrammingSteps.c **** 	
 131:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to check if the SROM command executed 
 132:ProgrammingSteps.c **** 	successfully else set SROM_TIMEOUT_ERROR in swd_PacketAck */
 133:ProgrammingSteps.c **** 	Read_IO (CPUSS_SYSARG, &statusCode);
 112              		.loc 1 133 0
 113 0056 1048     		ldr	r0, .L7+16
 114 0058 0C49     		ldr	r1, .L7+4
 115 005a FFF7FEFF 		bl	Read_IO
 134:ProgrammingSteps.c **** 	
 135:ProgrammingSteps.c **** 	if ((statusCode & SROM_STATUS_SUCCESS_MASK) != SROM_STATUS_SUCCEEDED)
 116              		.loc 1 135 0
 117 005e 0B4B     		ldr	r3, .L7+4
 118 0060 1B68     		ldr	r3, [r3]
 119 0062 03F07043 		and	r3, r3, #-268435456
 120 0066 B3F1204F 		cmp	r3, #-1610612736
 121 006a 08D0     		beq	.L6
 136:ProgrammingSteps.c **** 	{
 137:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
 122              		.loc 1 137 0
 123 006c 094B     		ldr	r3, .L7+12
 124 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 125 0070 43F02003 		orr	r3, r3, #32
 126 0074 DAB2     		uxtb	r2, r3
 127 0076 074B     		ldr	r3, .L7+12
 128 0078 1A70     		strb	r2, [r3]
 138:ProgrammingSteps.c **** 		
 139:ProgrammingSteps.c **** 		return (FAILURE);
 129              		.loc 1 139 0
 130 007a 0023     		movs	r3, #0
 131 007c 00E0     		b	.L5
 132              	.L6:
 140:ProgrammingSteps.c ****     }
 141:ProgrammingSteps.c **** 	else
 142:ProgrammingSteps.c **** 	    return (SUCCESS);
 133              		.loc 1 142 0
 134 007e 0123     		movs	r3, #1
 135              	.L5:
 143:ProgrammingSteps.c **** 
 144:ProgrammingSteps.c **** }
 136              		.loc 1 144 0
 137 0080 1846     		mov	r0, r3
 138 0082 0837     		adds	r7, r7, #8
 139              		.cfi_def_cfa_offset 8
 140 0084 BD46     		mov	sp, r7
 141              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 6


 142              		@ sp needed
 143 0086 80BD     		pop	{r7, pc}
 144              	.L8:
 145              		.align	2
 146              	.L7:
 147 0088 04000040 		.word	1073741828
 148 008c 00000000 		.word	statusCode
 149 0090 0DEA0200 		.word	190989
 150 0094 00000000 		.word	swd_PacketAck
 151 0098 08000040 		.word	1073741832
 152              		.cfi_endproc
 153              	.LFE63:
 154              		.size	PollSromStatus, .-PollSromStatus
 155              		.section	.text.ReadSromStatus,"ax",%progbits
 156              		.align	2
 157              		.global	ReadSromStatus
 158              		.thumb
 159              		.thumb_func
 160              		.type	ReadSromStatus, %function
 161              	ReadSromStatus:
 162              	.LFB64:
 145:ProgrammingSteps.c **** #if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY) || defined (CY8C4xx8_BL_FAMILY)
 146:ProgrammingSteps.c **** /******************************************************************************
 147:ProgrammingSteps.c **** * Function Name: SetIMO48MHz
 148:ProgrammingSteps.c **** *******************************************************************************
 149:ProgrammingSteps.c **** * Summary:
 150:ProgrammingSteps.c **** * Set IMO to 48 MHz 
 151:ProgrammingSteps.c **** *
 152:ProgrammingSteps.c **** * Parameters:
 153:ProgrammingSteps.c **** *  None.
 154:ProgrammingSteps.c **** *
 155:ProgrammingSteps.c **** * Return:
 156:ProgrammingSteps.c **** *  None
 157:ProgrammingSteps.c **** *
 158:ProgrammingSteps.c **** * Note:
 159:ProgrammingSteps.c **** *  This function is required to be called before any flash operation.
 160:ProgrammingSteps.c **** *  This function sets the IMO to 48 MHz before flash write/erase operations
 161:ProgrammingSteps.c **** *  and is part of the device acquire routine.
 162:ProgrammingSteps.c **** *
 163:ProgrammingSteps.c **** ******************************************************************************/
 164:ProgrammingSteps.c **** void SetIMO48MHz(void)
 165:ProgrammingSteps.c **** {    
 166:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 167:ProgrammingSteps.c **** 	
 168:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 169:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 170:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_SET_IMO_48MHZ) << 8));
 171:ProgrammingSteps.c **** 	
 172:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 173:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 174:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_SET_IMO_48MHZ);
 175:ProgrammingSteps.c **** }
 176:ProgrammingSteps.c **** #endif
 177:ProgrammingSteps.c **** /******************************************************************************
 178:ProgrammingSteps.c **** * Function Name: ReadSromStatus
 179:ProgrammingSteps.c **** *******************************************************************************
 180:ProgrammingSteps.c **** *
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 7


 181:ProgrammingSteps.c **** * Summary:
 182:ProgrammingSteps.c **** *  It reads the StatusCode global variable and returns LSB of this long variable
 183:ProgrammingSteps.c **** *  to main.c.
 184:ProgrammingSteps.c **** *
 185:ProgrammingSteps.c **** * Parameters:
 186:ProgrammingSteps.c **** *  None.
 187:ProgrammingSteps.c **** *
 188:ProgrammingSteps.c **** * Return:
 189:ProgrammingSteps.c **** * LSB of statusCode - LSB of statusCode global variable contains the error code
 190:ProgrammingSteps.c **** *
 191:ProgrammingSteps.c **** * Note:
 192:ProgrammingSteps.c **** * This function is called from main.c when SROM_TIMEOUT_ERROR bit is set in the
 193:ProgrammingSteps.c **** * swd_PacketAck. 
 194:ProgrammingSteps.c **** *
 195:ProgrammingSteps.c **** ******************************************************************************/
 196:ProgrammingSteps.c **** 
 197:ProgrammingSteps.c **** unsigned char ReadSromStatus(void)
 198:ProgrammingSteps.c **** {
 163              		.loc 1 198 0
 164              		.cfi_startproc
 165              		@ args = 0, pretend = 0, frame = 0
 166              		@ frame_needed = 1, uses_anonymous_args = 0
 167              		@ link register save eliminated.
 168 0000 80B4     		push	{r7}
 169              		.cfi_def_cfa_offset 4
 170              		.cfi_offset 7, -4
 171 0002 00AF     		add	r7, sp, #0
 172              		.cfi_def_cfa_register 7
 199:ProgrammingSteps.c **** 	return((unsigned char)statusCode);
 173              		.loc 1 199 0
 174 0004 034B     		ldr	r3, .L11
 175 0006 1B68     		ldr	r3, [r3]
 176 0008 DBB2     		uxtb	r3, r3
 200:ProgrammingSteps.c **** }
 177              		.loc 1 200 0
 178 000a 1846     		mov	r0, r3
 179 000c BD46     		mov	sp, r7
 180              		.cfi_def_cfa_register 13
 181              		@ sp needed
 182 000e 5DF8047B 		ldr	r7, [sp], #4
 183              		.cfi_restore 7
 184              		.cfi_def_cfa_offset 0
 185 0012 7047     		bx	lr
 186              	.L12:
 187              		.align	2
 188              	.L11:
 189 0014 00000000 		.word	statusCode
 190              		.cfi_endproc
 191              	.LFE64:
 192              		.size	ReadSromStatus, .-ReadSromStatus
 193              		.section	.text.GetChipProtectionVal,"ax",%progbits
 194              		.align	2
 195              		.global	GetChipProtectionVal
 196              		.thumb
 197              		.thumb_func
 198              		.type	GetChipProtectionVal, %function
 199              	GetChipProtectionVal:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 8


 200              	.LFB65:
 201:ProgrammingSteps.c **** 
 202:ProgrammingSteps.c **** /******************************************************************************
 203:ProgrammingSteps.c **** * Function Name: GetChipProtectionVal
 204:ProgrammingSteps.c **** *******************************************************************************
 205:ProgrammingSteps.c **** * Summary:
 206:ProgrammingSteps.c **** *  This sub-routine is used to read the Chip Protection Setting by using SROM 
 207:ProgrammingSteps.c **** *  System Calls. System call to read Silicon Id returns Chip protection settings
 208:ProgrammingSteps.c **** *  in the CPUSS_SYSREQ register. The location of the data is bit [15:12] in the
 209:ProgrammingSteps.c **** *  32-bit register.
 210:ProgrammingSteps.c **** *
 211:ProgrammingSteps.c **** * Parameters:
 212:ProgrammingSteps.c **** *  None.
 213:ProgrammingSteps.c **** *
 214:ProgrammingSteps.c **** * Return:
 215:ProgrammingSteps.c **** *  chipProtectionData_Chip - 1 byte chip protection setting read from the chip
 216:ProgrammingSteps.c **** *
 217:ProgrammingSteps.c **** * Note:
 218:ProgrammingSteps.c **** * This function is called in the "Step 3. Erase All Flash" to read the chip
 219:ProgrammingSteps.c **** * protection settings to take decision whether to move the protection state
 220:ProgrammingSteps.c **** *  to open and then erase the flash or directly erase the flash.
 221:ProgrammingSteps.c **** *
 222:ProgrammingSteps.c **** ******************************************************************************/
 223:ProgrammingSteps.c **** unsigned char GetChipProtectionVal(void)
 224:ProgrammingSteps.c **** {
 201              		.loc 1 224 0
 202              		.cfi_startproc
 203              		@ args = 0, pretend = 0, frame = 8
 204              		@ frame_needed = 1, uses_anonymous_args = 0
 205 0000 80B5     		push	{r7, lr}
 206              		.cfi_def_cfa_offset 8
 207              		.cfi_offset 7, -8
 208              		.cfi_offset 14, -4
 209 0002 82B0     		sub	sp, sp, #8
 210              		.cfi_def_cfa_offset 16
 211 0004 00AF     		add	r7, sp, #0
 212              		.cfi_def_cfa_register 7
 225:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 213              		.loc 1 225 0
 214 0006 0023     		movs	r3, #0
 215 0008 7B60     		str	r3, [r7, #4]
 226:ProgrammingSteps.c **** 	unsigned long chipProtData 		= 0;
 216              		.loc 1 226 0
 217 000a 0023     		movs	r3, #0
 218 000c 3B60     		str	r3, [r7]
 227:ProgrammingSteps.c **** 	
 228:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 229:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 219              		.loc 1 229 0
 220 000e 4DF2B633 		movw	r3, #54198
 221 0012 7B60     		str	r3, [r7, #4]
 230:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 231:ProgrammingSteps.c **** 	
 232:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 233:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 222              		.loc 1 233 0
 223 0014 1A48     		ldr	r0, .L20
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 9


 224 0016 7968     		ldr	r1, [r7, #4]
 225 0018 FFF7FEFF 		bl	Write_IO
 234:ProgrammingSteps.c ****     
 235:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 226              		.loc 1 235 0
 227 001c 194B     		ldr	r3, .L20+4
 228 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 229 0020 012B     		cmp	r3, #1
 230 0022 01D0     		beq	.L14
 236:ProgrammingSteps.c ****     {
 237:ProgrammingSteps.c ****         return(FAILURE);
 231              		.loc 1 237 0
 232 0024 0023     		movs	r3, #0
 233 0026 27E0     		b	.L19
 234              	.L14:
 238:ProgrammingSteps.c ****     }
 239:ProgrammingSteps.c **** 	
 240:ProgrammingSteps.c **** 	/* Request system call by writing to CPUSS_SYSREQ register */
 241:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 235              		.loc 1 241 0
 236 0028 1748     		ldr	r0, .L20+8
 237 002a 4FF00041 		mov	r1, #-2147483648
 238 002e FFF7FEFF 		bl	Write_IO
 242:ProgrammingSteps.c ****     
 243:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 239              		.loc 1 243 0
 240 0032 144B     		ldr	r3, .L20+4
 241 0034 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 242 0036 012B     		cmp	r3, #1
 243 0038 01D0     		beq	.L16
 244:ProgrammingSteps.c ****     {
 245:ProgrammingSteps.c ****         return(FAILURE);
 244              		.loc 1 245 0
 245 003a 0023     		movs	r3, #0
 246 003c 1CE0     		b	.L19
 247              	.L16:
 246:ProgrammingSteps.c ****     }
 247:ProgrammingSteps.c **** 	
 248:ProgrammingSteps.c **** 	/* Read status of the operation */
 249:ProgrammingSteps.c ****     result = PollSromStatus();
 248              		.loc 1 249 0
 249 003e FFF7FEFF 		bl	PollSromStatus
 250 0042 0346     		mov	r3, r0
 251 0044 1A46     		mov	r2, r3
 252 0046 114B     		ldr	r3, .L20+12
 253 0048 1A70     		strb	r2, [r3]
 250:ProgrammingSteps.c ****     
 251:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 254              		.loc 1 251 0
 255 004a 104B     		ldr	r3, .L20+12
 256 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 257 004e 012B     		cmp	r3, #1
 258 0050 01D0     		beq	.L17
 252:ProgrammingSteps.c ****     {
 253:ProgrammingSteps.c ****         return(FAILURE);
 259              		.loc 1 253 0
 260 0052 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 10


 261 0054 10E0     		b	.L19
 262              	.L17:
 254:ProgrammingSteps.c ****     }
 255:ProgrammingSteps.c **** 	
 256:ProgrammingSteps.c **** 	/* Read CPUSS_SYSREQ register to get the current protection setting of the
 257:ProgrammingSteps.c **** 	   chip */
 258:ProgrammingSteps.c ****     Read_IO( CPUSS_SYSREQ, &chipProtData);
 263              		.loc 1 258 0
 264 0056 3B46     		mov	r3, r7
 265 0058 0B48     		ldr	r0, .L20+8
 266 005a 1946     		mov	r1, r3
 267 005c FFF7FEFF 		bl	Read_IO
 259:ProgrammingSteps.c ****     
 260:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 268              		.loc 1 260 0
 269 0060 084B     		ldr	r3, .L20+4
 270 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 271 0064 012B     		cmp	r3, #1
 272 0066 01D0     		beq	.L18
 261:ProgrammingSteps.c ****     {
 262:ProgrammingSteps.c ****         return(FAILURE);
 273              		.loc 1 262 0
 274 0068 0023     		movs	r3, #0
 275 006a 05E0     		b	.L19
 276              	.L18:
 263:ProgrammingSteps.c ****     }
 264:ProgrammingSteps.c **** 
 265:ProgrammingSteps.c ****     chipProtectionData_Chip = (unsigned char)(chipProtData >> 12);
 277              		.loc 1 265 0
 278 006c 3B68     		ldr	r3, [r7]
 279 006e 1B0B     		lsrs	r3, r3, #12
 280 0070 DAB2     		uxtb	r2, r3
 281 0072 074B     		ldr	r3, .L20+16
 282 0074 1A70     		strb	r2, [r3]
 266:ProgrammingSteps.c **** 	
 267:ProgrammingSteps.c **** 	return(SUCCESS);
 283              		.loc 1 267 0
 284 0076 0123     		movs	r3, #1
 285              	.L19:
 268:ProgrammingSteps.c **** }
 286              		.loc 1 268 0 discriminator 1
 287 0078 1846     		mov	r0, r3
 288 007a 0837     		adds	r7, r7, #8
 289              		.cfi_def_cfa_offset 8
 290 007c BD46     		mov	sp, r7
 291              		.cfi_def_cfa_register 13
 292              		@ sp needed
 293 007e 80BD     		pop	{r7, pc}
 294              	.L21:
 295              		.align	2
 296              	.L20:
 297 0080 08000040 		.word	1073741832
 298 0084 00000000 		.word	swd_PacketAck
 299 0088 04000040 		.word	1073741828
 300 008c 00000000 		.word	result
 301 0090 00000000 		.word	chipProtectionData_Chip
 302              		.cfi_endproc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 11


 303              	.LFE65:
 304              		.size	GetChipProtectionVal, .-GetChipProtectionVal
 305              		.section	.text.GetTransitionMode,"ax",%progbits
 306              		.align	2
 307              		.global	GetTransitionMode
 308              		.thumb
 309              		.thumb_func
 310              		.type	GetTransitionMode, %function
 311              	GetTransitionMode:
 312              	.LFB66:
 269:ProgrammingSteps.c **** 
 270:ProgrammingSteps.c **** /******************************************************************************
 271:ProgrammingSteps.c **** * Function Name: GetTransitionMode
 272:ProgrammingSteps.c **** *******************************************************************************
 273:ProgrammingSteps.c **** *
 274:ProgrammingSteps.c **** * Summary:
 275:ProgrammingSteps.c **** *  It reads the chipProtectionData_Chip global variable which contains the Chip
 276:ProgrammingSteps.c **** *  protection setting stored in the Chip and chipProtectionData_Hex from the 
 277:ProgrammingSteps.c **** *  hex file which contains the Chip protection setting stored in the HEX file. 
 278:ProgrammingSteps.c **** *  The function then validates if the two settings correspond to a valid
 279:ProgrammingSteps.c **** *  transition.
 280:ProgrammingSteps.c **** *
 281:ProgrammingSteps.c **** * Parameters:
 282:ProgrammingSteps.c **** *  None.
 283:ProgrammingSteps.c **** *
 284:ProgrammingSteps.c **** * Return:
 285:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the transition is valid.
 286:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the transition is invalid.
 287:ProgrammingSteps.c **** *  Stores the transition in the global enum flow.
 288:ProgrammingSteps.c **** *
 289:ProgrammingSteps.c **** * Note:
 290:ProgrammingSteps.c **** * This function is called in "Step 3. Erase All Flash" to take decision on
 291:ProgrammingSteps.c **** * basis of the global enum flow.
 292:ProgrammingSteps.c **** *
 293:ProgrammingSteps.c **** ******************************************************************************/
 294:ProgrammingSteps.c **** unsigned char GetTransitionMode(void)
 295:ProgrammingSteps.c **** {
 313              		.loc 1 295 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 8
 316              		@ frame_needed = 1, uses_anonymous_args = 0
 317 0000 80B5     		push	{r7, lr}
 318              		.cfi_def_cfa_offset 8
 319              		.cfi_offset 7, -8
 320              		.cfi_offset 14, -4
 321 0002 82B0     		sub	sp, sp, #8
 322              		.cfi_def_cfa_offset 16
 323 0004 00AF     		add	r7, sp, #0
 324              		.cfi_def_cfa_register 7
 296:ProgrammingSteps.c **** 	unsigned char chipProtectionData_Hex;
 297:ProgrammingSteps.c **** 	
 298:ProgrammingSteps.c **** 	/* Get the chip protection setting in the HEX file */
 299:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 325              		.loc 1 299 0
 326 0006 FB1D     		adds	r3, r7, #7
 327 0008 1846     		mov	r0, r3
 328 000a FFF7FEFF 		bl	HEX_ReadChipProtectionData
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 12


 300:ProgrammingSteps.c **** 	
 301:ProgrammingSteps.c **** 	/* enum variable flow stores the transition (current protection setting to 
 302:ProgrammingSteps.c **** 	   setting in hex file) of the chip */
 303:ProgrammingSteps.c **** 	flow = WRONG_TRANSITION;
 329              		.loc 1 303 0
 330 000e 224B     		ldr	r3, .L39
 331 0010 0322     		movs	r2, #3
 332 0012 1A70     		strb	r2, [r3]
 304:ProgrammingSteps.c **** 	
 305:ProgrammingSteps.c **** 	switch (chipProtectionData_Chip)
 333              		.loc 1 305 0
 334 0014 214B     		ldr	r3, .L39+4
 335 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 336 0018 012B     		cmp	r3, #1
 337 001a 0ED0     		beq	.L24
 338 001c 022B     		cmp	r3, #2
 339 001e 17D0     		beq	.L25
 340 0020 002B     		cmp	r3, #0
 341 0022 23D1     		bne	.L38
 306:ProgrammingSteps.c **** 	{
 307:ProgrammingSteps.c **** 		/* virgin to open protection setting is the only allowed transition */
 308:ProgrammingSteps.c **** 		case CHIP_PROT_VIRGIN:
 309:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_OPEN)
 342              		.loc 1 309 0
 343 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 344 0026 012B     		cmp	r3, #1
 345 0028 03D1     		bne	.L27
 310:ProgrammingSteps.c ****                 flow = VIRGIN_OPEN;
 346              		.loc 1 310 0
 347 002a 1B4B     		ldr	r3, .L39
 348 002c 0122     		movs	r2, #1
 349 002e 1A70     		strb	r2, [r3]
 311:ProgrammingSteps.c ****             else
 312:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 313:ProgrammingSteps.c ****             break;
 350              		.loc 1 313 0
 351 0030 20E0     		b	.L29
 352              	.L27:
 312:ProgrammingSteps.c ****             break;
 353              		.loc 1 312 0
 354 0032 194B     		ldr	r3, .L39
 355 0034 0322     		movs	r2, #3
 356 0036 1A70     		strb	r2, [r3]
 357              		.loc 1 313 0
 358 0038 1CE0     		b	.L29
 359              	.L24:
 314:ProgrammingSteps.c **** 		
 315:ProgrammingSteps.c **** 		/* All transitions from Open are allowed other than transition to virgin
 316:ProgrammingSteps.c **** 		   mode */
 317:ProgrammingSteps.c **** 		case CHIP_PROT_OPEN:
 318:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_VIRGIN)
 360              		.loc 1 318 0
 361 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 362 003c 002B     		cmp	r3, #0
 363 003e 03D1     		bne	.L30
 319:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 364              		.loc 1 319 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 13


 365 0040 154B     		ldr	r3, .L39
 366 0042 0322     		movs	r2, #3
 367 0044 1A70     		strb	r2, [r3]
 320:ProgrammingSteps.c ****             else
 321:ProgrammingSteps.c ****                 flow = OPEN_XXX;
 322:ProgrammingSteps.c ****             break;
 368              		.loc 1 322 0
 369 0046 15E0     		b	.L29
 370              	.L30:
 321:ProgrammingSteps.c ****             break;
 371              		.loc 1 321 0
 372 0048 134B     		ldr	r3, .L39
 373 004a 0022     		movs	r2, #0
 374 004c 1A70     		strb	r2, [r3]
 375              		.loc 1 322 0
 376 004e 11E0     		b	.L29
 377              	.L25:
 323:ProgrammingSteps.c ****         
 324:ProgrammingSteps.c **** 		/* Protected to Protected and Protected to Open are the allowed
 325:ProgrammingSteps.c **** 		   transitions */
 326:ProgrammingSteps.c **** 		case CHIP_PROT_PROTECTED:
 327:ProgrammingSteps.c ****             if ((chipProtectionData_Hex == CHIP_PROT_OPEN) || (chipProtectionData_Hex == CHIP_PROT_
 378              		.loc 1 327 0
 379 0050 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 380 0052 012B     		cmp	r3, #1
 381 0054 02D0     		beq	.L32
 382              		.loc 1 327 0 is_stmt 0 discriminator 1
 383 0056 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 384 0058 022B     		cmp	r3, #2
 385 005a 03D1     		bne	.L33
 386              	.L32:
 328:ProgrammingSteps.c ****                 flow = PROT_XXX;
 387              		.loc 1 328 0 is_stmt 1
 388 005c 0E4B     		ldr	r3, .L39
 389 005e 0222     		movs	r2, #2
 390 0060 1A70     		strb	r2, [r3]
 329:ProgrammingSteps.c ****             else
 330:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 331:ProgrammingSteps.c ****             break;
 391              		.loc 1 331 0
 392 0062 07E0     		b	.L29
 393              	.L33:
 330:ProgrammingSteps.c ****             break;
 394              		.loc 1 330 0
 395 0064 0C4B     		ldr	r3, .L39
 396 0066 0322     		movs	r2, #3
 397 0068 1A70     		strb	r2, [r3]
 398              		.loc 1 331 0
 399 006a 03E0     		b	.L29
 400              	.L38:
 332:ProgrammingSteps.c ****         
 333:ProgrammingSteps.c **** 		default:
 334:ProgrammingSteps.c ****             flow = WRONG_TRANSITION;
 401              		.loc 1 334 0
 402 006c 0A4B     		ldr	r3, .L39
 403 006e 0322     		movs	r2, #3
 404 0070 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 14


 335:ProgrammingSteps.c ****             break;
 405              		.loc 1 335 0
 406 0072 00BF     		nop
 407              	.L29:
 336:ProgrammingSteps.c **** 	}
 337:ProgrammingSteps.c **** 	
 338:ProgrammingSteps.c **** 	/* Set TRANSITION_ERROR bit high in Swd_PacketAck to show wrong transition
 339:ProgrammingSteps.c **** 	   error */
 340:ProgrammingSteps.c **** 	if (flow == WRONG_TRANSITION)
 408              		.loc 1 340 0
 409 0074 084B     		ldr	r3, .L39
 410 0076 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 411 0078 032B     		cmp	r3, #3
 412 007a 08D1     		bne	.L35
 341:ProgrammingSteps.c **** 	{
 342:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | TRANSITION_ERROR;
 413              		.loc 1 342 0
 414 007c 084B     		ldr	r3, .L39+8
 415 007e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 416 0080 63F07F03 		orn	r3, r3, #127
 417 0084 DAB2     		uxtb	r2, r3
 418 0086 064B     		ldr	r3, .L39+8
 419 0088 1A70     		strb	r2, [r3]
 343:ProgrammingSteps.c **** 		return(FAILURE);
 420              		.loc 1 343 0
 421 008a 0023     		movs	r3, #0
 422 008c 00E0     		b	.L37
 423              	.L35:
 344:ProgrammingSteps.c **** 	}
 345:ProgrammingSteps.c **** 	return(SUCCESS);
 424              		.loc 1 345 0
 425 008e 0123     		movs	r3, #1
 426              	.L37:
 346:ProgrammingSteps.c **** }
 427              		.loc 1 346 0 discriminator 1
 428 0090 1846     		mov	r0, r3
 429 0092 0837     		adds	r7, r7, #8
 430              		.cfi_def_cfa_offset 8
 431 0094 BD46     		mov	sp, r7
 432              		.cfi_def_cfa_register 13
 433              		@ sp needed
 434 0096 80BD     		pop	{r7, pc}
 435              	.L40:
 436              		.align	2
 437              	.L39:
 438 0098 00000000 		.word	flow
 439 009c 00000000 		.word	chipProtectionData_Chip
 440 00a0 00000000 		.word	swd_PacketAck
 441              		.cfi_endproc
 442              	.LFE66:
 443              		.size	GetTransitionMode, .-GetTransitionMode
 444              		.section	.text.LoadLatch,"ax",%progbits
 445              		.align	2
 446              		.global	LoadLatch
 447              		.thumb
 448              		.thumb_func
 449              		.type	LoadLatch, %function
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 15


 450              	LoadLatch:
 451              	.LFB67:
 347:ProgrammingSteps.c **** 
 348:ProgrammingSteps.c **** /******************************************************************************
 349:ProgrammingSteps.c **** * Function Name: LoadLatch
 350:ProgrammingSteps.c **** *******************************************************************************
 351:ProgrammingSteps.c **** *
 352:ProgrammingSteps.c **** * Summary:
 353:ProgrammingSteps.c **** *  This function loads the page latch buffer with data to be programmed in to a
 354:ProgrammingSteps.c **** *  row of flash (or flash protection area). Data is loaded into the page latch 
 355:ProgrammingSteps.c **** *  buffer starting at the location specified by the SRAM_PARAMS_BASE input parameter. 
 356:ProgrammingSteps.c **** *  Data loaded into the page latch buffer will remain until a program operation is 
 357:ProgrammingSteps.c **** *  performed, which clears the page latch contents.
 358:ProgrammingSteps.c **** *
 359:ProgrammingSteps.c **** * Parameters:
 360:ProgrammingSteps.c **** *  arrayID - Array Number of the flash
 361:ProgrammingSteps.c **** *  rowData - Array containing 128 bytes of programming data
 362:ProgrammingSteps.c **** *  rowByteSize - Number of bytes in the current row to be loaded using parameter2
 363:ProgrammingSteps.c **** *
 364:ProgrammingSteps.c **** * Return:
 365:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Data is successfully latched
 366:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Data is not latched successfully
 367:ProgrammingSteps.c **** *
 368:ProgrammingSteps.c **** * Note:
 369:ProgrammingSteps.c **** * This function is called in "Step 5. Program Flash" and 
 370:ProgrammingSteps.c **** * "Step 7. Program Protection Settings" to latch the programming data in SRAM.
 371:ProgrammingSteps.c **** *
 372:ProgrammingSteps.c **** ******************************************************************************/
 373:ProgrammingSteps.c **** unsigned char LoadLatch(unsigned char arrayID, unsigned char * rowData, unsigned short rowByteSize)
 374:ProgrammingSteps.c **** {
 452              		.loc 1 374 0
 453              		.cfi_startproc
 454              		@ args = 0, pretend = 0, frame = 24
 455              		@ frame_needed = 1, uses_anonymous_args = 0
 456 0000 80B5     		push	{r7, lr}
 457              		.cfi_def_cfa_offset 8
 458              		.cfi_offset 7, -8
 459              		.cfi_offset 14, -4
 460 0002 86B0     		sub	sp, sp, #24
 461              		.cfi_def_cfa_offset 32
 462 0004 00AF     		add	r7, sp, #0
 463              		.cfi_def_cfa_register 7
 464 0006 0346     		mov	r3, r0
 465 0008 3960     		str	r1, [r7]
 466 000a FB71     		strb	r3, [r7, #7]
 467 000c 1346     		mov	r3, r2	@ movhi
 468 000e BB80     		strh	r3, [r7, #4]	@ movhi
 375:ProgrammingSteps.c **** 		unsigned long parameter1 = 0;
 469              		.loc 1 375 0
 470 0010 0023     		movs	r3, #0
 471 0012 3B61     		str	r3, [r7, #16]
 376:ProgrammingSteps.c **** 		unsigned long parameter2 = 0;
 472              		.loc 1 376 0
 473 0014 0023     		movs	r3, #0
 474 0016 FB60     		str	r3, [r7, #12]
 377:ProgrammingSteps.c **** 		unsigned short i = 0;
 475              		.loc 1 377 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 16


 476 0018 0023     		movs	r3, #0
 477 001a FB82     		strh	r3, [r7, #22]	@ movhi
 378:ProgrammingSteps.c **** 		
 379:ProgrammingSteps.c **** 		/* Load parameter1 with the SROM command to load the page latch buffer
 380:ProgrammingSteps.c **** 		   with programming data */
 381:ProgrammingSteps.c **** 		parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 382:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 383:ProgrammingSteps.c **** 					(0x00 << 16) + ((unsigned long)arrayID << 24);
 478              		.loc 1 383 0
 479 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 480 001e 1B06     		lsls	r3, r3, #24
 381:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 481              		.loc 1 381 0
 482 0020 03F55743 		add	r3, r3, #55040
 483 0024 B633     		adds	r3, r3, #182
 484 0026 3B61     		str	r3, [r7, #16]
 384:ProgrammingSteps.c **** 		
 385:ProgrammingSteps.c **** 		/* Number of Bytes to load minus 1 */
 386:ProgrammingSteps.c **** 		parameter2 = (rowByteSize - 1);
 485              		.loc 1 386 0
 486 0028 BB88     		ldrh	r3, [r7, #4]
 487 002a 013B     		subs	r3, r3, #1
 488 002c FB60     		str	r3, [r7, #12]
 387:ProgrammingSteps.c **** 		
 388:ProgrammingSteps.c **** 		/* Write parameter1 in SRAM */
 389:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE + 0x00, parameter1);
 489              		.loc 1 389 0
 490 002e 3648     		ldr	r0, .L51
 491 0030 3969     		ldr	r1, [r7, #16]
 492 0032 FFF7FEFF 		bl	Write_IO
 390:ProgrammingSteps.c **** 		
 391:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 493              		.loc 1 391 0
 494 0036 354B     		ldr	r3, .L51+4
 495 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 496 003a 012B     		cmp	r3, #1
 497 003c 01D0     		beq	.L42
 392:ProgrammingSteps.c **** 	    {
 393:ProgrammingSteps.c **** 	        return (FAILURE);
 498              		.loc 1 393 0
 499 003e 0023     		movs	r3, #0
 500 0040 5DE0     		b	.L43
 501              	.L42:
 394:ProgrammingSteps.c **** 	    }
 395:ProgrammingSteps.c **** 	    
 396:ProgrammingSteps.c **** 		/* Write parameter2 in SRAM */
 397:ProgrammingSteps.c **** 		Write_IO(SRAM_PARAMS_BASE + 0x04, parameter2);
 502              		.loc 1 397 0
 503 0042 3348     		ldr	r0, .L51+8
 504 0044 F968     		ldr	r1, [r7, #12]
 505 0046 FFF7FEFF 		bl	Write_IO
 398:ProgrammingSteps.c **** 		
 399:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 506              		.loc 1 399 0
 507 004a 304B     		ldr	r3, .L51+4
 508 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 509 004e 012B     		cmp	r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 17


 510 0050 01D0     		beq	.L44
 400:ProgrammingSteps.c **** 	    {
 401:ProgrammingSteps.c **** 	        return (FAILURE);
 511              		.loc 1 401 0
 512 0052 0023     		movs	r3, #0
 513 0054 53E0     		b	.L43
 514              	.L44:
 402:ProgrammingSteps.c **** 	    }
 403:ProgrammingSteps.c **** 		
 404:ProgrammingSteps.c **** 		/* Put row data into SRAM buffer */
 405:ProgrammingSteps.c **** 	    for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 515              		.loc 1 405 0
 516 0056 0023     		movs	r3, #0
 517 0058 FB82     		strh	r3, [r7, #22]	@ movhi
 518 005a 2CE0     		b	.L45
 519              	.L47:
 406:ProgrammingSteps.c **** 	    {
 407:ProgrammingSteps.c **** 	     	parameter1 = (rowData[i] << 0) + (rowData[i + 1] << 8) + (rowData[i + 2] << 16) + (rowData[i
 520              		.loc 1 407 0
 521 005c FB8A     		ldrh	r3, [r7, #22]
 522 005e 3A68     		ldr	r2, [r7]
 523 0060 1344     		add	r3, r3, r2
 524 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 525 0064 1946     		mov	r1, r3
 526 0066 FB8A     		ldrh	r3, [r7, #22]
 527 0068 0133     		adds	r3, r3, #1
 528 006a 3A68     		ldr	r2, [r7]
 529 006c 1344     		add	r3, r3, r2
 530 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 531 0070 1B02     		lsls	r3, r3, #8
 532 0072 CA18     		adds	r2, r1, r3
 533 0074 FB8A     		ldrh	r3, [r7, #22]
 534 0076 0233     		adds	r3, r3, #2
 535 0078 3968     		ldr	r1, [r7]
 536 007a 0B44     		add	r3, r3, r1
 537 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 538 007e 1B04     		lsls	r3, r3, #16
 539 0080 1A44     		add	r2, r2, r3
 540 0082 FB8A     		ldrh	r3, [r7, #22]
 541 0084 0333     		adds	r3, r3, #3
 542 0086 3968     		ldr	r1, [r7]
 543 0088 0B44     		add	r3, r3, r1
 544 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 545 008c 1B06     		lsls	r3, r3, #24
 546 008e 1344     		add	r3, r3, r2
 547 0090 3B61     		str	r3, [r7, #16]
 408:ProgrammingSteps.c **** 	        
 409:ProgrammingSteps.c **** 			/* Write parameter1 in SRAM */
 410:ProgrammingSteps.c **** 			Write_IO(SRAM_PARAMS_BASE + 0x08 + i, parameter1);
 548              		.loc 1 410 0
 549 0092 FB8A     		ldrh	r3, [r7, #22]
 550 0094 03F10053 		add	r3, r3, #536870912
 551 0098 03F58473 		add	r3, r3, #264
 552 009c 1846     		mov	r0, r3
 553 009e 3969     		ldr	r1, [r7, #16]
 554 00a0 FFF7FEFF 		bl	Write_IO
 411:ProgrammingSteps.c **** 			
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 18


 412:ProgrammingSteps.c **** 			if( swd_PacketAck != SWD_OK_ACK )
 555              		.loc 1 412 0
 556 00a4 194B     		ldr	r3, .L51+4
 557 00a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 558 00a8 012B     		cmp	r3, #1
 559 00aa 01D0     		beq	.L46
 413:ProgrammingSteps.c ****     	    {
 414:ProgrammingSteps.c ****     	        return (FAILURE);
 560              		.loc 1 414 0
 561 00ac 0023     		movs	r3, #0
 562 00ae 26E0     		b	.L43
 563              	.L46:
 405:ProgrammingSteps.c **** 	    {
 564              		.loc 1 405 0 discriminator 2
 565 00b0 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 566 00b2 0433     		adds	r3, r3, #4
 567 00b4 FB82     		strh	r3, [r7, #22]	@ movhi
 568              	.L45:
 405:ProgrammingSteps.c **** 	    {
 569              		.loc 1 405 0 is_stmt 0 discriminator 1
 570 00b6 FB8A     		ldrh	r3, [r7, #22]
 571 00b8 7F2B     		cmp	r3, #127
 572 00ba CFD9     		bls	.L47
 415:ProgrammingSteps.c ****     	    }
 416:ProgrammingSteps.c **** 		}
 417:ProgrammingSteps.c **** 
 418:ProgrammingSteps.c **** 	    /*  Call "Load Latch" SROM API */
 419:ProgrammingSteps.c **** 		
 420:ProgrammingSteps.c **** 		/* Set location of parameters */
 421:ProgrammingSteps.c **** 	    Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 573              		.loc 1 421 0 is_stmt 1
 574 00bc 1548     		ldr	r0, .L51+12
 575 00be 1249     		ldr	r1, .L51
 576 00c0 FFF7FEFF 		bl	Write_IO
 422:ProgrammingSteps.c **** 		
 423:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 577              		.loc 1 423 0
 578 00c4 114B     		ldr	r3, .L51+4
 579 00c6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 580 00c8 012B     		cmp	r3, #1
 581 00ca 01D0     		beq	.L48
 424:ProgrammingSteps.c **** 	    {
 425:ProgrammingSteps.c **** 	        return (FAILURE);
 582              		.loc 1 425 0
 583 00cc 0023     		movs	r3, #0
 584 00ce 16E0     		b	.L43
 585              	.L48:
 426:ProgrammingSteps.c **** 	    }
 427:ProgrammingSteps.c **** 	    
 428:ProgrammingSteps.c **** 		/* Request SROM operation */
 429:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_LOAD_LATCH);
 586              		.loc 1 429 0
 587 00d0 1148     		ldr	r0, .L51+16
 588 00d2 1249     		ldr	r1, .L51+20
 589 00d4 FFF7FEFF 		bl	Write_IO
 430:ProgrammingSteps.c **** 		
 431:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 19


 590              		.loc 1 431 0
 591 00d8 0C4B     		ldr	r3, .L51+4
 592 00da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 593 00dc 012B     		cmp	r3, #1
 594 00de 01D0     		beq	.L49
 432:ProgrammingSteps.c **** 	    {
 433:ProgrammingSteps.c **** 	        return (FAILURE);
 595              		.loc 1 433 0
 596 00e0 0023     		movs	r3, #0
 597 00e2 0CE0     		b	.L43
 598              	.L49:
 434:ProgrammingSteps.c **** 	    }
 435:ProgrammingSteps.c **** 	    
 436:ProgrammingSteps.c **** 		/* Read status of the operation */
 437:ProgrammingSteps.c **** 		result = PollSromStatus();
 599              		.loc 1 437 0
 600 00e4 FFF7FEFF 		bl	PollSromStatus
 601 00e8 0346     		mov	r3, r0
 602 00ea 1A46     		mov	r2, r3
 603 00ec 0C4B     		ldr	r3, .L51+24
 604 00ee 1A70     		strb	r2, [r3]
 438:ProgrammingSteps.c **** 	    
 439:ProgrammingSteps.c **** 		if ( result != SROM_SUCCESS )
 605              		.loc 1 439 0
 606 00f0 0B4B     		ldr	r3, .L51+24
 607 00f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 608 00f4 012B     		cmp	r3, #1
 609 00f6 01D0     		beq	.L50
 440:ProgrammingSteps.c ****         {
 441:ProgrammingSteps.c ****             return (FAILURE);
 610              		.loc 1 441 0
 611 00f8 0023     		movs	r3, #0
 612 00fa 00E0     		b	.L43
 613              	.L50:
 442:ProgrammingSteps.c ****         }
 443:ProgrammingSteps.c **** 	
 444:ProgrammingSteps.c **** 	return (SUCCESS);
 614              		.loc 1 444 0
 615 00fc 0123     		movs	r3, #1
 616              	.L43:
 445:ProgrammingSteps.c **** }
 617              		.loc 1 445 0
 618 00fe 1846     		mov	r0, r3
 619 0100 1837     		adds	r7, r7, #24
 620              		.cfi_def_cfa_offset 8
 621 0102 BD46     		mov	sp, r7
 622              		.cfi_def_cfa_register 13
 623              		@ sp needed
 624 0104 80BD     		pop	{r7, pc}
 625              	.L52:
 626 0106 00BF     		.align	2
 627              	.L51:
 628 0108 00010020 		.word	536871168
 629 010c 00000000 		.word	swd_PacketAck
 630 0110 04010020 		.word	536871172
 631 0114 08000040 		.word	1073741832
 632 0118 04000040 		.word	1073741828
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 20


 633 011c 04000080 		.word	-2147483644
 634 0120 00000000 		.word	result
 635              		.cfi_endproc
 636              	.LFE67:
 637              		.size	LoadLatch, .-LoadLatch
 638              		.section	.text.ChecksumAPI,"ax",%progbits
 639              		.align	2
 640              		.global	ChecksumAPI
 641              		.thumb
 642              		.thumb_func
 643              		.type	ChecksumAPI, %function
 644              	ChecksumAPI:
 645              	.LFB68:
 446:ProgrammingSteps.c **** 
 447:ProgrammingSteps.c **** /******************************************************************************
 448:ProgrammingSteps.c **** * Function Name: ChecksumAPI
 449:ProgrammingSteps.c **** *******************************************************************************
 450:ProgrammingSteps.c **** *
 451:ProgrammingSteps.c **** * Summary:
 452:ProgrammingSteps.c **** *  This function reads either the whole flash memory or a row of flash. When 
 453:ProgrammingSteps.c **** *  performing a checksum on the whole flash, the user code and the supervisory 
 454:ProgrammingSteps.c **** *  flash regions are included. When performing a checksum only on one row of 
 455:ProgrammingSteps.c **** *  flash, the flash row number is passed as a parameter. For computing Checksum
 456:ProgrammingSteps.c **** *  of entire flash, ChecksumRow input parameter is loaded as macro
 457:ProgrammingSteps.c **** *  CHECKSUM_ENTIRE_FLASH (0x8000).
 458:ProgrammingSteps.c **** *
 459:ProgrammingSteps.c **** * Parameters:
 460:ProgrammingSteps.c **** *  checksumRow: Row number of flash for which checksum has to be calculated. 
 461:ProgrammingSteps.c **** *  				To compute checksum of entire flash, this variable is set to 
 462:ProgrammingSteps.c **** *  				CHECKSUM_ENTIRE_FLASH (0x8000).
 463:ProgrammingSteps.c **** *  
 464:ProgrammingSteps.c **** *  checksum: This variable is loaded with the checksum after the execution of
 465:ProgrammingSteps.c **** *			 the function.
 466:ProgrammingSteps.c **** *
 467:ProgrammingSteps.c **** * Return:
 468:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Checksum System call is successfully executed.
 469:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Checksum system call fails to execute.
 470:ProgrammingSteps.c **** *
 471:ProgrammingSteps.c **** * Note:
 472:ProgrammingSteps.c **** * This function is called in "Step 4. Checksum Privileged Calculation" and 
 473:ProgrammingSteps.c **** * "Step 9. Verify Checksum" to calculate the checksum of flash privileged rows
 474:ProgrammingSteps.c **** * and entire flash, respectively.
 475:ProgrammingSteps.c **** *
 476:ProgrammingSteps.c **** ******************************************************************************/
 477:ProgrammingSteps.c **** unsigned char ChecksumAPI(unsigned short checksumRow, unsigned long *checksum)
 478:ProgrammingSteps.c **** {
 646              		.loc 1 478 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 16
 649              		@ frame_needed = 1, uses_anonymous_args = 0
 650 0000 80B5     		push	{r7, lr}
 651              		.cfi_def_cfa_offset 8
 652              		.cfi_offset 7, -8
 653              		.cfi_offset 14, -4
 654 0002 84B0     		sub	sp, sp, #16
 655              		.cfi_def_cfa_offset 24
 656 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 21


 657              		.cfi_def_cfa_register 7
 658 0006 0346     		mov	r3, r0
 659 0008 3960     		str	r1, [r7]
 660 000a FB80     		strh	r3, [r7, #6]	@ movhi
 479:ProgrammingSteps.c **** 	unsigned long parameter1 	= 0;
 661              		.loc 1 479 0
 662 000c 0023     		movs	r3, #0
 663 000e FB60     		str	r3, [r7, #12]
 480:ProgrammingSteps.c **** 	unsigned long checksum_chip = 0 ;
 664              		.loc 1 480 0
 665 0010 0023     		movs	r3, #0
 666 0012 BB60     		str	r3, [r7, #8]
 481:ProgrammingSteps.c **** 	
 482:ProgrammingSteps.c **** 	/* Load parameter1 with the SROM command to compute checksum of whole
 483:ProgrammingSteps.c **** 	   flash */
 484:ProgrammingSteps.c **** 	parameter1 = ((unsigned long)SROM_KEY1 << 00) + (((unsigned long)SROM_KEY2 + //
 485:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 667              		.loc 1 485 0
 668 0014 FB88     		ldrh	r3, [r7, #6]
 669 0016 DBB2     		uxtb	r3, r3
 670 0018 1A04     		lsls	r2, r3, #16
 486:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 671              		.loc 1 486 0
 672 001a FB88     		ldrh	r3, [r7, #6]
 673 001c 03F47F43 		and	r3, r3, #65280
 674 0020 1B04     		lsls	r3, r3, #16
 485:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 675              		.loc 1 485 0
 676 0022 1344     		add	r3, r3, r2
 484:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 677              		.loc 1 484 0
 678 0024 03F55E43 		add	r3, r3, #56832
 679 0028 B633     		adds	r3, r3, #182
 680 002a FB60     		str	r3, [r7, #12]
 487:ProgrammingSteps.c **** 	
 488:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 command */
 489:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 681              		.loc 1 489 0
 682 002c 1A48     		ldr	r0, .L60
 683 002e F968     		ldr	r1, [r7, #12]
 684 0030 FFF7FEFF 		bl	Write_IO
 490:ProgrammingSteps.c **** 	
 491:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 685              		.loc 1 491 0
 686 0034 194B     		ldr	r3, .L60+4
 687 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 688 0038 012B     		cmp	r3, #1
 689 003a 01D0     		beq	.L54
 492:ProgrammingSteps.c ****     {
 493:ProgrammingSteps.c ****         return(FAILURE);
 690              		.loc 1 493 0
 691 003c 0023     		movs	r3, #0
 692 003e 27E0     		b	.L59
 693              	.L54:
 494:ProgrammingSteps.c ****     }
 495:ProgrammingSteps.c **** 	
 496:ProgrammingSteps.c **** 	/* Request SROM operation */
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 22


 497:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_CHECKSUM);
 694              		.loc 1 497 0
 695 0040 1748     		ldr	r0, .L60+8
 696 0042 1849     		ldr	r1, .L60+12
 697 0044 FFF7FEFF 		bl	Write_IO
 498:ProgrammingSteps.c **** 	
 499:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 698              		.loc 1 499 0
 699 0048 144B     		ldr	r3, .L60+4
 700 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 701 004c 012B     		cmp	r3, #1
 702 004e 01D0     		beq	.L56
 500:ProgrammingSteps.c ****     {
 501:ProgrammingSteps.c ****         return(FAILURE);
 703              		.loc 1 501 0
 704 0050 0023     		movs	r3, #0
 705 0052 1DE0     		b	.L59
 706              	.L56:
 502:ProgrammingSteps.c ****     }
 503:ProgrammingSteps.c ****     
 504:ProgrammingSteps.c **** 	/* Read status of the operation */
 505:ProgrammingSteps.c **** 	result = PollSromStatus();
 707              		.loc 1 505 0
 708 0054 FFF7FEFF 		bl	PollSromStatus
 709 0058 0346     		mov	r3, r0
 710 005a 1A46     		mov	r2, r3
 711 005c 124B     		ldr	r3, .L60+16
 712 005e 1A70     		strb	r2, [r3]
 506:ProgrammingSteps.c **** 	
 507:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 713              		.loc 1 507 0
 714 0060 114B     		ldr	r3, .L60+16
 715 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 716 0064 012B     		cmp	r3, #1
 717 0066 01D0     		beq	.L57
 508:ProgrammingSteps.c ****     {
 509:ProgrammingSteps.c ****         return(FAILURE);
 718              		.loc 1 509 0
 719 0068 0023     		movs	r3, #0
 720 006a 11E0     		b	.L59
 721              	.L57:
 510:ProgrammingSteps.c ****     }
 511:ProgrammingSteps.c **** 	
 512:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to get the checksum value */
 513:ProgrammingSteps.c **** 	Read_IO( CPUSS_SYSARG, &checksum_chip);
 722              		.loc 1 513 0
 723 006c 07F10803 		add	r3, r7, #8
 724 0070 0948     		ldr	r0, .L60
 725 0072 1946     		mov	r1, r3
 726 0074 FFF7FEFF 		bl	Read_IO
 514:ProgrammingSteps.c **** 	
 515:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 727              		.loc 1 515 0
 728 0078 084B     		ldr	r3, .L60+4
 729 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 730 007c 012B     		cmp	r3, #1
 731 007e 01D0     		beq	.L58
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 23


 516:ProgrammingSteps.c ****     {
 517:ProgrammingSteps.c ****         return(FAILURE);
 732              		.loc 1 517 0
 733 0080 0023     		movs	r3, #0
 734 0082 05E0     		b	.L59
 735              	.L58:
 518:ProgrammingSteps.c ****     }
 519:ProgrammingSteps.c **** 	
 520:ProgrammingSteps.c **** 	/* 28-bit checksum */
 521:ProgrammingSteps.c **** 	*checksum = (checksum_chip & 0x0FFFFFFF);
 736              		.loc 1 521 0
 737 0084 BB68     		ldr	r3, [r7, #8]
 738 0086 23F07042 		bic	r2, r3, #-268435456
 739 008a 3B68     		ldr	r3, [r7]
 740 008c 1A60     		str	r2, [r3]
 522:ProgrammingSteps.c **** 
 523:ProgrammingSteps.c **** 	return (SUCCESS);
 741              		.loc 1 523 0
 742 008e 0123     		movs	r3, #1
 743              	.L59:
 524:ProgrammingSteps.c **** }
 744              		.loc 1 524 0 discriminator 1
 745 0090 1846     		mov	r0, r3
 746 0092 1037     		adds	r7, r7, #16
 747              		.cfi_def_cfa_offset 8
 748 0094 BD46     		mov	sp, r7
 749              		.cfi_def_cfa_register 13
 750              		@ sp needed
 751 0096 80BD     		pop	{r7, pc}
 752              	.L61:
 753              		.align	2
 754              	.L60:
 755 0098 08000040 		.word	1073741832
 756 009c 00000000 		.word	swd_PacketAck
 757 00a0 04000040 		.word	1073741828
 758 00a4 0B000080 		.word	-2147483637
 759 00a8 00000000 		.word	result
 760              		.cfi_endproc
 761              	.LFE68:
 762              		.size	ChecksumAPI, .-ChecksumAPI
 763              		.section	.text.DeviceAcquire,"ax",%progbits
 764              		.align	2
 765              		.global	DeviceAcquire
 766              		.thumb
 767              		.thumb_func
 768              		.type	DeviceAcquire, %function
 769              	DeviceAcquire:
 770              	.LFB69:
 525:ProgrammingSteps.c **** 
 526:ProgrammingSteps.c **** 
 527:ProgrammingSteps.c **** /******************************************************************************
 528:ProgrammingSteps.c **** *Function Name: DeviceAcquire
 529:ProgrammingSteps.c **** *******************************************************************************
 530:ProgrammingSteps.c **** *
 531:ProgrammingSteps.c **** * Summary:
 532:ProgrammingSteps.c **** *  This is Step 1 of the programming sequence. In this Step, target PSoC 4 is 
 533:ProgrammingSteps.c **** *  acquired by the host microcontroller by sending specific Port Acquiring 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 24


 534:ProgrammingSteps.c **** *  Sequence in a 1.5 ms time-window. After acquiring SWD port, debug port is 
 535:ProgrammingSteps.c **** *  configured and bit 31 in TEST_MODE control register is set.
 536:ProgrammingSteps.c **** *
 537:ProgrammingSteps.c **** * Parameters:
 538:ProgrammingSteps.c **** *  None
 539:ProgrammingSteps.c **** *
 540:ProgrammingSteps.c **** * Return:
 541:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the device is successfully acquired.
 542:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the function fails in any of the intermediate
 543:ProgrammingSteps.c **** *			 step.
 544:ProgrammingSteps.c **** *
 545:ProgrammingSteps.c **** * Note:
 546:ProgrammingSteps.c **** * This function has very strict timing requirements. The device must be
 547:ProgrammingSteps.c **** * acquired as per the timing requirements given in PSoC 4 Device Programming 
 548:ProgrammingSteps.c **** * Specification Document.
 549:ProgrammingSteps.c **** *
 550:ProgrammingSteps.c **** ******************************************************************************/
 551:ProgrammingSteps.c **** unsigned char DeviceAcquire(void)
 552:ProgrammingSteps.c **** {
 771              		.loc 1 552 0
 772              		.cfi_startproc
 773              		@ args = 0, pretend = 0, frame = 16
 774              		@ frame_needed = 1, uses_anonymous_args = 0
 775 0000 80B5     		push	{r7, lr}
 776              		.cfi_def_cfa_offset 8
 777              		.cfi_offset 7, -8
 778              		.cfi_offset 14, -4
 779 0002 84B0     		sub	sp, sp, #16
 780              		.cfi_def_cfa_offset 24
 781 0004 00AF     		add	r7, sp, #0
 782              		.cfi_def_cfa_register 7
 553:ProgrammingSteps.c **** 	unsigned long chip_DAP_Id 			= 0;
 783              		.loc 1 553 0
 784 0006 0023     		movs	r3, #0
 785 0008 BB60     		str	r3, [r7, #8]
 554:ProgrammingSteps.c ****     unsigned short total_packet_count 	= 0;
 786              		.loc 1 554 0
 787 000a 0023     		movs	r3, #0
 788 000c FB81     		strh	r3, [r7, #14]	@ movhi
 555:ProgrammingSteps.c ****     unsigned long status 				= 0;
 789              		.loc 1 555 0
 790 000e 0023     		movs	r3, #0
 791 0010 7B60     		str	r3, [r7, #4]
 556:ProgrammingSteps.c ****     
 557:ProgrammingSteps.c **** 	/* Aquiring Sequence */
 558:ProgrammingSteps.c **** 
 559:ProgrammingSteps.c **** 	SetXresCmosOutput();
 792              		.loc 1 559 0
 793 0012 FFF7FEFF 		bl	SetXresCmosOutput
 560:ProgrammingSteps.c **** 	SetXresHigh();
 794              		.loc 1 560 0
 795 0016 FFF7FEFF 		bl	SetXresHigh
 561:ProgrammingSteps.c **** 
 562:ProgrammingSteps.c **** 	SetSwdckCmosOutput();
 796              		.loc 1 562 0
 797 001a FFF7FEFF 		bl	SetSwdckCmosOutput
 563:ProgrammingSteps.c **** 	SetSwdckLow();
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 25


 798              		.loc 1 563 0
 799 001e FFF7FEFF 		bl	SetSwdckLow
 564:ProgrammingSteps.c **** 
 565:ProgrammingSteps.c **** 	SetSwdioCmosOutput();
 800              		.loc 1 565 0
 801 0022 FFF7FEFF 		bl	SetSwdioCmosOutput
 566:ProgrammingSteps.c **** 	SetSwdioLow();
 802              		.loc 1 566 0
 803 0026 FFF7FEFF 		bl	SetSwdioLow
 567:ProgrammingSteps.c **** 	
 568:ProgrammingSteps.c **** 	/* Set XRES of PSoC 4 low for 100us with SWDCK and SWDIO low (min delay 
 569:ProgrammingSteps.c **** 	   required is 5us) */
 570:ProgrammingSteps.c **** 	SetXresLow();
 804              		.loc 1 570 0
 805 002a FFF7FEFF 		bl	SetXresLow
 571:ProgrammingSteps.c **** 	DelayHundredUs();
 806              		.loc 1 571 0
 807 002e FFF7FEFF 		bl	DelayHundredUs
 572:ProgrammingSteps.c **** 	SetXresHigh();
 808              		.loc 1 572 0
 809 0032 FFF7FEFF 		bl	SetXresHigh
 810              	.L64:
 573:ProgrammingSteps.c **** 	
 574:ProgrammingSteps.c ****     do
 575:ProgrammingSteps.c ****     {
 576:ProgrammingSteps.c **** 		/* Call Swd_LineReset (Standard ARM command to reset DAP) and read
 577:ProgrammingSteps.c **** 		   DAP_ID from chip */
 578:ProgrammingSteps.c ****     	Swd_LineReset();
 811              		.loc 1 578 0 discriminator 2
 812 0036 FFF7FEFF 		bl	Swd_LineReset
 579:ProgrammingSteps.c **** 		
 580:ProgrammingSteps.c **** 		Read_DAP(DPACC_DP_IDCODE_READ, &chip_DAP_Id);
 813              		.loc 1 580 0 discriminator 2
 814 003a 07F10803 		add	r3, r7, #8
 815 003e A520     		movs	r0, #165
 816 0040 1946     		mov	r1, r3
 817 0042 FFF7FEFF 		bl	Read_DAP
 581:ProgrammingSteps.c ****     	
 582:ProgrammingSteps.c **** 		total_packet_count++;
 818              		.loc 1 582 0 discriminator 2
 819 0046 FB89     		ldrh	r3, [r7, #14]
 820 0048 0133     		adds	r3, r3, #1
 821 004a FB81     		strh	r3, [r7, #14]	@ movhi
 583:ProgrammingSteps.c **** 		
 584:ProgrammingSteps.c ****     }while((swd_PacketAck != SWD_OK_ACK)&& (total_packet_count < DEVICE_ACQUIRE_TIMEOUT));
 822              		.loc 1 584 0 discriminator 2
 823 004c 354B     		ldr	r3, .L76
 824 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 825 0050 012B     		cmp	r3, #1
 826 0052 02D0     		beq	.L63
 827              		.loc 1 584 0 is_stmt 0 discriminator 1
 828 0054 FB89     		ldrh	r3, [r7, #14]
 829 0056 0E2B     		cmp	r3, #14
 830 0058 EDD9     		bls	.L64
 831              	.L63:
 585:ProgrammingSteps.c **** 	
 586:ProgrammingSteps.c **** 	/* Set PORT_ACQUIRE_TIMEOUT_ERROR bit in swd_PacketAck if time
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 26


 587:ProgrammingSteps.c **** 	   exceeds 1.5 ms */
 588:ProgrammingSteps.c **** 	if (total_packet_count == DEVICE_ACQUIRE_TIMEOUT)
 832              		.loc 1 588 0 is_stmt 1
 833 005a FB89     		ldrh	r3, [r7, #14]
 834 005c 0F2B     		cmp	r3, #15
 835 005e 08D1     		bne	.L65
 589:ProgrammingSteps.c **** 	{
 590:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | PORT_ACQUIRE_TIMEOUT_ERROR;
 836              		.loc 1 590 0
 837 0060 304B     		ldr	r3, .L76
 838 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 839 0064 43F01003 		orr	r3, r3, #16
 840 0068 DAB2     		uxtb	r2, r3
 841 006a 2E4B     		ldr	r3, .L76
 842 006c 1A70     		strb	r2, [r3]
 591:ProgrammingSteps.c ****         return(FAILURE);
 843              		.loc 1 591 0
 844 006e 0023     		movs	r3, #0
 845 0070 53E0     		b	.L75
 846              	.L65:
 592:ProgrammingSteps.c **** 	}
 593:ProgrammingSteps.c **** 	
 594:ProgrammingSteps.c **** 	/* Set VERIFICATION_ERROR bit in swd_PacketAck if the DAP_ID read
 595:ProgrammingSteps.c **** 	   from chip does not match with the ARM CM0_DAP_ID (MACRO defined in
 596:ProgrammingSteps.c **** 	   ProgrammingSteps.h file - 0x0BB11477) */
 597:ProgrammingSteps.c **** 	if (chip_DAP_Id != CM0_DAP_ID)
 847              		.loc 1 597 0
 848 0072 BB68     		ldr	r3, [r7, #8]
 849 0074 2C4A     		ldr	r2, .L76+4
 850 0076 9342     		cmp	r3, r2
 851 0078 08D0     		beq	.L67
 598:ProgrammingSteps.c **** 	{
 599:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 852              		.loc 1 599 0
 853 007a 2A4B     		ldr	r3, .L76
 854 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 855 007e 43F04003 		orr	r3, r3, #64
 856 0082 DAB2     		uxtb	r2, r3
 857 0084 274B     		ldr	r3, .L76
 858 0086 1A70     		strb	r2, [r3]
 600:ProgrammingSteps.c **** 		return(FAILURE);
 859              		.loc 1 600 0
 860 0088 0023     		movs	r3, #0
 861 008a 46E0     		b	.L75
 862              	.L67:
 601:ProgrammingSteps.c **** 	}
 602:ProgrammingSteps.c **** 	
 603:ProgrammingSteps.c **** 	/* Initialize Debug Port */
 604:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_CTRLSTAT_WRITE, 0x54000000);
 863              		.loc 1 604 0
 864 008c A920     		movs	r0, #169
 865 008e 4FF0A841 		mov	r1, #1409286144
 866 0092 FFF7FEFF 		bl	Write_DAP
 605:ProgrammingSteps.c ****     
 606:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 867              		.loc 1 606 0
 868 0096 234B     		ldr	r3, .L76
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 27


 869 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 870 009a 012B     		cmp	r3, #1
 871 009c 01D0     		beq	.L68
 607:ProgrammingSteps.c ****     {
 608:ProgrammingSteps.c ****         return(FAILURE);
 872              		.loc 1 608 0
 873 009e 0023     		movs	r3, #0
 874 00a0 3BE0     		b	.L75
 875              	.L68:
 609:ProgrammingSteps.c ****     }
 610:ProgrammingSteps.c **** 	
 611:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_SELECT_WRITE, 0x00000000);
 876              		.loc 1 611 0
 877 00a2 B120     		movs	r0, #177
 878 00a4 0021     		movs	r1, #0
 879 00a6 FFF7FEFF 		bl	Write_DAP
 612:ProgrammingSteps.c ****     
 613:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 880              		.loc 1 613 0
 881 00aa 1E4B     		ldr	r3, .L76
 882 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 883 00ae 012B     		cmp	r3, #1
 884 00b0 01D0     		beq	.L69
 614:ProgrammingSteps.c ****     {
 615:ProgrammingSteps.c ****         return(FAILURE);
 885              		.loc 1 615 0
 886 00b2 0023     		movs	r3, #0
 887 00b4 31E0     		b	.L75
 888              	.L69:
 616:ProgrammingSteps.c ****     }
 617:ProgrammingSteps.c **** 	
 618:ProgrammingSteps.c **** 	Write_DAP (DPACC_AP_CSW_WRITE, 0x00000002);
 889              		.loc 1 618 0
 890 00b6 A320     		movs	r0, #163
 891 00b8 0221     		movs	r1, #2
 892 00ba FFF7FEFF 		bl	Write_DAP
 619:ProgrammingSteps.c ****     
 620:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 893              		.loc 1 620 0
 894 00be 194B     		ldr	r3, .L76
 895 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 896 00c2 012B     		cmp	r3, #1
 897 00c4 01D0     		beq	.L70
 621:ProgrammingSteps.c ****     {
 622:ProgrammingSteps.c ****         return(FAILURE);
 898              		.loc 1 622 0
 899 00c6 0023     		movs	r3, #0
 900 00c8 27E0     		b	.L75
 901              	.L70:
 623:ProgrammingSteps.c ****     }
 624:ProgrammingSteps.c **** 
 625:ProgrammingSteps.c **** 	/* Enter CPU into Test Mode */
 626:ProgrammingSteps.c ****     Write_IO (TEST_MODE, 0x80000000);
 902              		.loc 1 626 0
 903 00ca 1848     		ldr	r0, .L76+8
 904 00cc 4FF00041 		mov	r1, #-2147483648
 905 00d0 FFF7FEFF 		bl	Write_IO
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 28


 627:ProgrammingSteps.c **** 	
 628:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 906              		.loc 1 628 0
 907 00d4 134B     		ldr	r3, .L76
 908 00d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 909 00d8 012B     		cmp	r3, #1
 910 00da 01D0     		beq	.L71
 629:ProgrammingSteps.c ****     {
 630:ProgrammingSteps.c ****         return(FAILURE);
 911              		.loc 1 630 0
 912 00dc 0023     		movs	r3, #0
 913 00de 1CE0     		b	.L75
 914              	.L71:
 631:ProgrammingSteps.c ****     }
 632:ProgrammingSteps.c ****     
 633:ProgrammingSteps.c ****     Read_IO (TEST_MODE, &status);
 915              		.loc 1 633 0
 916 00e0 3B1D     		adds	r3, r7, #4
 917 00e2 1248     		ldr	r0, .L76+8
 918 00e4 1946     		mov	r1, r3
 919 00e6 FFF7FEFF 		bl	Read_IO
 634:ProgrammingSteps.c **** 	
 635:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 920              		.loc 1 635 0
 921 00ea 0E4B     		ldr	r3, .L76
 922 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 923 00ee 012B     		cmp	r3, #1
 924 00f0 01D0     		beq	.L72
 636:ProgrammingSteps.c ****     {
 637:ProgrammingSteps.c ****         return(FAILURE);
 925              		.loc 1 637 0
 926 00f2 0023     		movs	r3, #0
 927 00f4 11E0     		b	.L75
 928              	.L72:
 638:ProgrammingSteps.c ****     }
 639:ProgrammingSteps.c **** 	
 640:ProgrammingSteps.c ****     if((status & 0x80000000) != 0x80000000)
 929              		.loc 1 640 0
 930 00f6 7B68     		ldr	r3, [r7, #4]
 931 00f8 002B     		cmp	r3, #0
 932 00fa 01DB     		blt	.L73
 641:ProgrammingSteps.c ****     {
 642:ProgrammingSteps.c ****         return (FAILURE);
 933              		.loc 1 642 0
 934 00fc 0023     		movs	r3, #0
 935 00fe 0CE0     		b	.L75
 936              	.L73:
 643:ProgrammingSteps.c ****     }
 644:ProgrammingSteps.c **** 	
 645:ProgrammingSteps.c **** 	/* Read status of the operation */
 646:ProgrammingSteps.c **** 	result = PollSromStatus();
 937              		.loc 1 646 0
 938 0100 FFF7FEFF 		bl	PollSromStatus
 939 0104 0346     		mov	r3, r0
 940 0106 1A46     		mov	r2, r3
 941 0108 094B     		ldr	r3, .L76+12
 942 010a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 29


 647:ProgrammingSteps.c **** 	
 648:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 943              		.loc 1 648 0
 944 010c 084B     		ldr	r3, .L76+12
 945 010e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 946 0110 012B     		cmp	r3, #1
 947 0112 01D0     		beq	.L74
 649:ProgrammingSteps.c **** 	{
 650:ProgrammingSteps.c **** 		return(FAILURE);		
 948              		.loc 1 650 0
 949 0114 0023     		movs	r3, #0
 950 0116 00E0     		b	.L75
 951              	.L74:
 651:ProgrammingSteps.c **** 	}
 652:ProgrammingSteps.c **** 	
 653:ProgrammingSteps.c **** 	#if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY)
 654:ProgrammingSteps.c **** 	
 655:ProgrammingSteps.c **** 	/* Set IMO to 48 MHz */
 656:ProgrammingSteps.c **** 	SetIMO48MHz();
 657:ProgrammingSteps.c **** 	
 658:ProgrammingSteps.c **** 	/* Read status of the operation */
 659:ProgrammingSteps.c **** 	result = PollSromStatus();
 660:ProgrammingSteps.c **** 	
 661:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 662:ProgrammingSteps.c **** 	{
 663:ProgrammingSteps.c **** 		return(FAILURE);		
 664:ProgrammingSteps.c **** 	}
 665:ProgrammingSteps.c **** 	#endif
 666:ProgrammingSteps.c **** 	
 667:ProgrammingSteps.c ****     return (SUCCESS);
 952              		.loc 1 667 0
 953 0118 0123     		movs	r3, #1
 954              	.L75:
 668:ProgrammingSteps.c **** }
 955              		.loc 1 668 0 discriminator 1
 956 011a 1846     		mov	r0, r3
 957 011c 1037     		adds	r7, r7, #16
 958              		.cfi_def_cfa_offset 8
 959 011e BD46     		mov	sp, r7
 960              		.cfi_def_cfa_register 13
 961              		@ sp needed
 962 0120 80BD     		pop	{r7, pc}
 963              	.L77:
 964 0122 00BF     		.align	2
 965              	.L76:
 966 0124 00000000 		.word	swd_PacketAck
 967 0128 7714B10B 		.word	196154487
 968 012c 14000340 		.word	1073938452
 969 0130 00000000 		.word	result
 970              		.cfi_endproc
 971              	.LFE69:
 972              		.size	DeviceAcquire, .-DeviceAcquire
 973              		.section	.text.VerifySiliconId,"ax",%progbits
 974              		.align	2
 975              		.global	VerifySiliconId
 976              		.thumb
 977              		.thumb_func
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 30


 978              		.type	VerifySiliconId, %function
 979              	VerifySiliconId:
 980              	.LFB70:
 669:ProgrammingSteps.c **** 
 670:ProgrammingSteps.c **** /******************************************************************************
 671:ProgrammingSteps.c **** * Function Name: VerifySiliconId
 672:ProgrammingSteps.c **** *******************************************************************************
 673:ProgrammingSteps.c **** *
 674:ProgrammingSteps.c **** * Summary:
 675:ProgrammingSteps.c **** *  This is Step 2 of the programming sequence. In this Step, Silicon Id of the
 676:ProgrammingSteps.c **** *  PSoC 4 device is read and matched with the silicon id stored in the Hex File
 677:ProgrammingSteps.c **** *  to verify that the correct device is being programmed.
 678:ProgrammingSteps.c **** *
 679:ProgrammingSteps.c **** * Parameters:
 680:ProgrammingSteps.c **** *  None
 681:ProgrammingSteps.c **** *
 682:ProgrammingSteps.c **** * Return:
 683:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Silicon Id read from chip matches the Id in the
 684:ProgrammingSteps.c **** *			 HEX File.
 685:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 686:ProgrammingSteps.c **** *			 message.
 687:ProgrammingSteps.c **** *
 688:ProgrammingSteps.c **** * Note:
 689:ProgrammingSteps.c **** * 
 690:ProgrammingSteps.c **** ******************************************************************************/
 691:ProgrammingSteps.c **** unsigned char VerifySiliconId(void)
 692:ProgrammingSteps.c **** {
 981              		.loc 1 692 0
 982              		.cfi_startproc
 983              		@ args = 0, pretend = 0, frame = 24
 984              		@ frame_needed = 1, uses_anonymous_args = 0
 985 0000 80B5     		push	{r7, lr}
 986              		.cfi_def_cfa_offset 8
 987              		.cfi_offset 7, -8
 988              		.cfi_offset 14, -4
 989 0002 86B0     		sub	sp, sp, #24
 990              		.cfi_def_cfa_offset 32
 991 0004 00AF     		add	r7, sp, #0
 992              		.cfi_def_cfa_register 7
 693:ProgrammingSteps.c **** 	unsigned char i;
 694:ProgrammingSteps.c **** 	unsigned long deviceSiliconID;
 695:ProgrammingSteps.c **** 	unsigned long hexSiliconId = 0;
 993              		.loc 1 695 0
 994 0006 0023     		movs	r3, #0
 995 0008 BB60     		str	r3, [r7, #8]
 696:ProgrammingSteps.c ****     
 697:ProgrammingSteps.c **** 	unsigned long parameter1 	 = 0;
 996              		.loc 1 697 0
 997 000a 0023     		movs	r3, #0
 998 000c 3B61     		str	r3, [r7, #16]
 698:ProgrammingSteps.c **** 	unsigned long siliconIdData1 = 0;
 999              		.loc 1 698 0
 1000 000e 0023     		movs	r3, #0
 1001 0010 7B60     		str	r3, [r7, #4]
 699:ProgrammingSteps.c **** 	unsigned long siliconIdData2 = 0;
 1002              		.loc 1 699 0
 1003 0012 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 31


 1004 0014 3B60     		str	r3, [r7]
 700:ProgrammingSteps.c **** 	
 701:ProgrammingSteps.c **** 	/* Read and store Silicon ID from HEX file to hexSiliconId array */
 702:ProgrammingSteps.c **** 	HEX_ReadSiliconId(&hexSiliconId);
 1005              		.loc 1 702 0
 1006 0016 07F10803 		add	r3, r7, #8
 1007 001a 1846     		mov	r0, r3
 1008 001c FFF7FEFF 		bl	HEX_ReadSiliconId
 703:ProgrammingSteps.c **** 	
 704:ProgrammingSteps.c **** 	/* Load Parameter1 with the SROM command to read silicon ID from PSoC 4
 705:ProgrammingSteps.c **** 	   chip */
 706:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1009              		.loc 1 706 0
 1010 0020 4DF2B633 		movw	r3, #54198
 1011 0024 3B61     		str	r3, [r7, #16]
 707:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 708:ProgrammingSteps.c **** 	
 709:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 */
 710:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSARG, parameter1);
 1012              		.loc 1 710 0
 1013 0026 3248     		ldr	r0, .L89
 1014 0028 3969     		ldr	r1, [r7, #16]
 1015 002a FFF7FEFF 		bl	Write_IO
 711:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1016              		.loc 1 711 0
 1017 002e 314B     		ldr	r3, .L89+4
 1018 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1019 0032 012B     		cmp	r3, #1
 1020 0034 01D0     		beq	.L79
 712:ProgrammingSteps.c ****     {
 713:ProgrammingSteps.c ****         return(FAILURE);
 1021              		.loc 1 713 0
 1022 0036 0023     		movs	r3, #0
 1023 0038 55E0     		b	.L88
 1024              	.L79:
 714:ProgrammingSteps.c ****     }
 715:ProgrammingSteps.c **** 	
 716:ProgrammingSteps.c **** 	/* Request SROM operation */
 717:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 1025              		.loc 1 717 0
 1026 003a 2F48     		ldr	r0, .L89+8
 1027 003c 4FF00041 		mov	r1, #-2147483648
 1028 0040 FFF7FEFF 		bl	Write_IO
 718:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1029              		.loc 1 718 0
 1030 0044 2B4B     		ldr	r3, .L89+4
 1031 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1032 0048 012B     		cmp	r3, #1
 1033 004a 01D0     		beq	.L81
 719:ProgrammingSteps.c ****     {
 720:ProgrammingSteps.c ****         return(FAILURE);
 1034              		.loc 1 720 0
 1035 004c 0023     		movs	r3, #0
 1036 004e 4AE0     		b	.L88
 1037              	.L81:
 721:ProgrammingSteps.c ****     }
 722:ProgrammingSteps.c **** 	
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 32


 723:ProgrammingSteps.c **** 	/* Read status of the operation */
 724:ProgrammingSteps.c ****     result = PollSromStatus();
 1038              		.loc 1 724 0
 1039 0050 FFF7FEFF 		bl	PollSromStatus
 1040 0054 0346     		mov	r3, r0
 1041 0056 1A46     		mov	r2, r3
 1042 0058 284B     		ldr	r3, .L89+12
 1043 005a 1A70     		strb	r2, [r3]
 725:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 1044              		.loc 1 725 0
 1045 005c 274B     		ldr	r3, .L89+12
 1046 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1047 0060 012B     		cmp	r3, #1
 1048 0062 01D0     		beq	.L82
 726:ProgrammingSteps.c ****     {
 727:ProgrammingSteps.c ****         return(FAILURE);
 1049              		.loc 1 727 0
 1050 0064 0023     		movs	r3, #0
 1051 0066 3EE0     		b	.L88
 1052              	.L82:
 728:ProgrammingSteps.c ****     }
 729:ProgrammingSteps.c **** 	
 730:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG and CPUSS_SYSREQ to read 4 bytes of silicon ID */
 731:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSARG, &siliconIdData1);
 1053              		.loc 1 731 0
 1054 0068 3B1D     		adds	r3, r7, #4
 1055 006a 2148     		ldr	r0, .L89
 1056 006c 1946     		mov	r1, r3
 1057 006e FFF7FEFF 		bl	Read_IO
 732:ProgrammingSteps.c ****     if( swd_PacketAck != SWD_OK_ACK )
 1058              		.loc 1 732 0
 1059 0072 204B     		ldr	r3, .L89+4
 1060 0074 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1061 0076 012B     		cmp	r3, #1
 1062 0078 01D0     		beq	.L83
 733:ProgrammingSteps.c ****     {
 734:ProgrammingSteps.c ****         return(FAILURE);
 1063              		.loc 1 734 0
 1064 007a 0023     		movs	r3, #0
 1065 007c 33E0     		b	.L88
 1066              	.L83:
 735:ProgrammingSteps.c ****     }
 736:ProgrammingSteps.c **** 	
 737:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSREQ, &siliconIdData2);
 1067              		.loc 1 737 0
 1068 007e 3B46     		mov	r3, r7
 1069 0080 1D48     		ldr	r0, .L89+8
 1070 0082 1946     		mov	r1, r3
 1071 0084 FFF7FEFF 		bl	Read_IO
 738:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1072              		.loc 1 738 0
 1073 0088 1A4B     		ldr	r3, .L89+4
 1074 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1075 008c 012B     		cmp	r3, #1
 1076 008e 01D0     		beq	.L84
 739:ProgrammingSteps.c ****     {
 740:ProgrammingSteps.c ****         return(FAILURE);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 33


 1077              		.loc 1 740 0
 1078 0090 0023     		movs	r3, #0
 1079 0092 28E0     		b	.L88
 1080              	.L84:
 741:ProgrammingSteps.c ****     }
 742:ProgrammingSteps.c ****     
 743:ProgrammingSteps.c **** 	/*
 744:ProgrammingSteps.c **** 	SiliconIdData2 (0th byte) = 4th byte of Device Silicon ID (MSB)
 745:ProgrammingSteps.c **** 	SiliconIdData1 (3rd byte) = 3rd byte of Device Silicon ID
 746:ProgrammingSteps.c **** 	SiliconIdData1 (1st byte) = 2nd byte of Device Silicon ID
 747:ProgrammingSteps.c **** 	SiliconIdData1 (2nd byte) = 1st byte of Device Silicon ID (LSB)
 748:ProgrammingSteps.c **** 	*/
 749:ProgrammingSteps.c **** 	deviceSiliconID = (((siliconIdData2 << 24) & 0xFF000000) + (siliconIdData1 & 0x00FF0000) + //
 1081              		.loc 1 749 0
 1082 0094 3B68     		ldr	r3, [r7]
 1083 0096 1A06     		lsls	r2, r3, #24
 1084 0098 7B68     		ldr	r3, [r7, #4]
 1085 009a 03F47F03 		and	r3, r3, #16711680
 1086 009e 1A44     		add	r2, r2, r3
 750:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1087              		.loc 1 750 0
 1088 00a0 7B68     		ldr	r3, [r7, #4]
 1089 00a2 1B02     		lsls	r3, r3, #8
 1090 00a4 9BB2     		uxth	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1091              		.loc 1 749 0
 1092 00a6 1A44     		add	r2, r2, r3
 1093              		.loc 1 750 0
 1094 00a8 7B68     		ldr	r3, [r7, #4]
 1095 00aa 1B0A     		lsrs	r3, r3, #8
 1096 00ac DBB2     		uxtb	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1097              		.loc 1 749 0
 1098 00ae 1344     		add	r3, r3, r2
 1099 00b0 FB60     		str	r3, [r7, #12]
 751:ProgrammingSteps.c **** 	
 752:ProgrammingSteps.c **** 	/* Match the Silicon ID read from HEX file and PSoC 4 chip */
 753:ProgrammingSteps.c **** 	for (i=0; i<SILICON_ID_BYTE_LENGTH; i++)
 1100              		.loc 1 753 0
 1101 00b2 0023     		movs	r3, #0
 1102 00b4 FB75     		strb	r3, [r7, #23]
 1103 00b6 12E0     		b	.L85
 1104              	.L87:
 754:ProgrammingSteps.c **** 	{
 755:ProgrammingSteps.c **** 		if ((deviceSiliconID & 0xFF00FFFF) != (hexSiliconId & 0xFF00FFFF))
 1105              		.loc 1 755 0
 1106 00b8 BA68     		ldr	r2, [r7, #8]
 1107 00ba FB68     		ldr	r3, [r7, #12]
 1108 00bc 5340     		eors	r3, r3, r2
 1109 00be 23F47F03 		bic	r3, r3, #16711680
 1110 00c2 002B     		cmp	r3, #0
 1111 00c4 08D0     		beq	.L86
 756:ProgrammingSteps.c ****         {
 757:ProgrammingSteps.c **** 			/* Set the VERIFICATION_ERROR bit in swd_PacketAck */
 758:ProgrammingSteps.c ****             swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1112              		.loc 1 758 0
 1113 00c6 0B4B     		ldr	r3, .L89+4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 34


 1114 00c8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1115 00ca 43F04003 		orr	r3, r3, #64
 1116 00ce DAB2     		uxtb	r2, r3
 1117 00d0 084B     		ldr	r3, .L89+4
 1118 00d2 1A70     		strb	r2, [r3]
 759:ProgrammingSteps.c **** 			return (FAILURE);
 1119              		.loc 1 759 0
 1120 00d4 0023     		movs	r3, #0
 1121 00d6 06E0     		b	.L88
 1122              	.L86:
 753:ProgrammingSteps.c **** 	{
 1123              		.loc 1 753 0 discriminator 2
 1124 00d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1125 00da 0133     		adds	r3, r3, #1
 1126 00dc FB75     		strb	r3, [r7, #23]
 1127              	.L85:
 753:ProgrammingSteps.c **** 	{
 1128              		.loc 1 753 0 is_stmt 0 discriminator 1
 1129 00de FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1130 00e0 032B     		cmp	r3, #3
 1131 00e2 E9D9     		bls	.L87
 760:ProgrammingSteps.c ****         }
 761:ProgrammingSteps.c **** 	}
 762:ProgrammingSteps.c **** 	return (SUCCESS);
 1132              		.loc 1 762 0 is_stmt 1
 1133 00e4 0123     		movs	r3, #1
 1134              	.L88:
 763:ProgrammingSteps.c **** }
 1135              		.loc 1 763 0 discriminator 1
 1136 00e6 1846     		mov	r0, r3
 1137 00e8 1837     		adds	r7, r7, #24
 1138              		.cfi_def_cfa_offset 8
 1139 00ea BD46     		mov	sp, r7
 1140              		.cfi_def_cfa_register 13
 1141              		@ sp needed
 1142 00ec 80BD     		pop	{r7, pc}
 1143              	.L90:
 1144 00ee 00BF     		.align	2
 1145              	.L89:
 1146 00f0 08000040 		.word	1073741832
 1147 00f4 00000000 		.word	swd_PacketAck
 1148 00f8 04000040 		.word	1073741828
 1149 00fc 00000000 		.word	result
 1150              		.cfi_endproc
 1151              	.LFE70:
 1152              		.size	VerifySiliconId, .-VerifySiliconId
 1153              		.section	.text.EraseAllFlash,"ax",%progbits
 1154              		.align	2
 1155              		.global	EraseAllFlash
 1156              		.thumb
 1157              		.thumb_func
 1158              		.type	EraseAllFlash, %function
 1159              	EraseAllFlash:
 1160              	.LFB71:
 764:ProgrammingSteps.c **** 
 765:ProgrammingSteps.c **** /******************************************************************************
 766:ProgrammingSteps.c **** * Function Name: EraseAllFlash
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 35


 767:ProgrammingSteps.c **** *******************************************************************************
 768:ProgrammingSteps.c **** *
 769:ProgrammingSteps.c **** * Summary:
 770:ProgrammingSteps.c **** *  This is Step 3 of the programming sequence. In this Step, the whole user 
 771:ProgrammingSteps.c **** *  flash is erased. This function uses GetChipProtectionVal() and 
 772:ProgrammingSteps.c **** *  GetTransitionMode() API's to take the decision on the method to follow to 
 773:ProgrammingSteps.c **** *  erase the device.
 774:ProgrammingSteps.c **** *
 775:ProgrammingSteps.c **** * Parameters:
 776:ProgrammingSteps.c **** *  None
 777:ProgrammingSteps.c **** *
 778:ProgrammingSteps.c **** * Return:
 779:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully erases complete user 
 780:ProgrammingSteps.c **** *			 flash region.
 781:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 782:ProgrammingSteps.c **** *			 message.
 783:ProgrammingSteps.c **** *
 784:ProgrammingSteps.c **** * Note:
 785:ProgrammingSteps.c **** * 
 786:ProgrammingSteps.c **** ******************************************************************************/
 787:ProgrammingSteps.c **** unsigned char EraseAllFlash(void)
 788:ProgrammingSteps.c **** {
 1161              		.loc 1 788 0
 1162              		.cfi_startproc
 1163              		@ args = 0, pretend = 0, frame = 8
 1164              		@ frame_needed = 1, uses_anonymous_args = 0
 1165 0000 80B5     		push	{r7, lr}
 1166              		.cfi_def_cfa_offset 8
 1167              		.cfi_offset 7, -8
 1168              		.cfi_offset 14, -4
 1169 0002 82B0     		sub	sp, sp, #8
 1170              		.cfi_def_cfa_offset 16
 1171 0004 00AF     		add	r7, sp, #0
 1172              		.cfi_def_cfa_register 7
 789:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1173              		.loc 1 789 0
 1174 0006 0023     		movs	r3, #0
 1175 0008 7B60     		str	r3, [r7, #4]
 790:ProgrammingSteps.c **** 	
 791:ProgrammingSteps.c **** 	/* Get current chip protection setting */
 792:ProgrammingSteps.c **** 	GetChipProtectionVal();
 1176              		.loc 1 792 0
 1177 000a FFF7FEFF 		bl	GetChipProtectionVal
 793:ProgrammingSteps.c **** 	
 794:ProgrammingSteps.c **** 	/* Check if the Chip protection setting transition is valid */
 795:ProgrammingSteps.c **** 	result = GetTransitionMode();
 1178              		.loc 1 795 0
 1179 000e FFF7FEFF 		bl	GetTransitionMode
 1180 0012 0346     		mov	r3, r0
 1181 0014 1A46     		mov	r2, r3
 1182 0016 3A4B     		ldr	r3, .L104
 1183 0018 1A70     		strb	r2, [r3]
 796:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1184              		.loc 1 796 0
 1185 001a 394B     		ldr	r3, .L104
 1186 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1187 001e 012B     		cmp	r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 36


 1188 0020 01D0     		beq	.L92
 797:ProgrammingSteps.c **** 	{
 798:ProgrammingSteps.c **** 		return(FAILURE);
 1189              		.loc 1 798 0
 1190 0022 0023     		movs	r3, #0
 1191 0024 68E0     		b	.L93
 1192              	.L92:
 799:ProgrammingSteps.c **** 	}
 800:ProgrammingSteps.c **** 	
 801:ProgrammingSteps.c **** 	/* If the transition is from open to any protection setting or from virgin to
 802:ProgrammingSteps.c **** 	   open, call ERASE_ALL SROM command */
 803:ProgrammingSteps.c **** 	if ((flow == OPEN_XXX) || (flow == VIRGIN_OPEN))
 1193              		.loc 1 803 0
 1194 0026 374B     		ldr	r3, .L104+4
 1195 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1196 002a 002B     		cmp	r3, #0
 1197 002c 03D0     		beq	.L94
 1198              		.loc 1 803 0 is_stmt 0 discriminator 1
 1199 002e 354B     		ldr	r3, .L104+4
 1200 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1201 0032 012B     		cmp	r3, #1
 1202 0034 2DD1     		bne	.L95
 1203              	.L94:
 804:ProgrammingSteps.c ****     {
 805:ProgrammingSteps.c **** 		parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1204              		.loc 1 805 0 is_stmt 1
 1205 0036 4DF6B653 		movw	r3, #56758
 1206 003a 7B60     		str	r3, [r7, #4]
 806:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_ERASE_ALL) << 8));
 807:ProgrammingSteps.c **** 		
 808:ProgrammingSteps.c **** 		/* Load ERASE_ALL SROM command in parameter1 to SRAM */ 
 809:ProgrammingSteps.c ****     	Write_IO (SRAM_PARAMS_BASE + 0x00, parameter1);
 1207              		.loc 1 809 0
 1208 003c 3248     		ldr	r0, .L104+8
 1209 003e 7968     		ldr	r1, [r7, #4]
 1210 0040 FFF7FEFF 		bl	Write_IO
 810:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1211              		.loc 1 810 0
 1212 0044 314B     		ldr	r3, .L104+12
 1213 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1214 0048 012B     		cmp	r3, #1
 1215 004a 01D0     		beq	.L96
 811:ProgrammingSteps.c ****         {
 812:ProgrammingSteps.c ****             return(FAILURE);
 1216              		.loc 1 812 0
 1217 004c 0023     		movs	r3, #0
 1218 004e 53E0     		b	.L93
 1219              	.L96:
 813:ProgrammingSteps.c ****         }
 814:ProgrammingSteps.c **** 		
 815:ProgrammingSteps.c **** 		/* Set location of parameters */
 816:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1220              		.loc 1 816 0
 1221 0050 2F48     		ldr	r0, .L104+16
 1222 0052 2D49     		ldr	r1, .L104+8
 1223 0054 FFF7FEFF 		bl	Write_IO
 817:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 37


 1224              		.loc 1 817 0
 1225 0058 2C4B     		ldr	r3, .L104+12
 1226 005a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1227 005c 012B     		cmp	r3, #1
 1228 005e 01D0     		beq	.L97
 818:ProgrammingSteps.c ****         {
 819:ProgrammingSteps.c ****             return(FAILURE);
 1229              		.loc 1 819 0
 1230 0060 0023     		movs	r3, #0
 1231 0062 49E0     		b	.L93
 1232              	.L97:
 820:ProgrammingSteps.c ****         }
 821:ProgrammingSteps.c **** 		
 822:ProgrammingSteps.c **** 		/* Request SROM call */
 823:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_ERASE_ALL);
 1233              		.loc 1 823 0
 1234 0064 2B48     		ldr	r0, .L104+20
 1235 0066 2C49     		ldr	r1, .L104+24
 1236 0068 FFF7FEFF 		bl	Write_IO
 824:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1237              		.loc 1 824 0
 1238 006c 274B     		ldr	r3, .L104+12
 1239 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1240 0070 012B     		cmp	r3, #1
 1241 0072 01D0     		beq	.L98
 825:ProgrammingSteps.c ****         {
 826:ProgrammingSteps.c ****             return(FAILURE);
 1242              		.loc 1 826 0
 1243 0074 0023     		movs	r3, #0
 1244 0076 3FE0     		b	.L93
 1245              	.L98:
 827:ProgrammingSteps.c ****         }
 828:ProgrammingSteps.c **** 		
 829:ProgrammingSteps.c **** 		/* Read status of the operation */
 830:ProgrammingSteps.c ****     	result = PollSromStatus();
 1246              		.loc 1 830 0
 1247 0078 FFF7FEFF 		bl	PollSromStatus
 1248 007c 0346     		mov	r3, r0
 1249 007e 1A46     		mov	r2, r3
 1250 0080 1F4B     		ldr	r3, .L104
 1251 0082 1A70     		strb	r2, [r3]
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1252              		.loc 1 831 0
 1253 0084 1E4B     		ldr	r3, .L104
 1254 0086 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1255 0088 012B     		cmp	r3, #1
 1256 008a 01D0     		beq	.L99
 832:ProgrammingSteps.c **** 		{
 833:ProgrammingSteps.c ****     		return (FAILURE);
 1257              		.loc 1 833 0
 1258 008c 0023     		movs	r3, #0
 1259 008e 33E0     		b	.L93
 1260              	.L99:
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1261              		.loc 1 831 0
 1262 0090 31E0     		b	.L100
 1263              	.L95:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 38


 834:ProgrammingSteps.c **** 		}
 835:ProgrammingSteps.c ****     }
 836:ProgrammingSteps.c **** 	
 837:ProgrammingSteps.c **** 	/* If the transition is from protected mode to open mode or protected mode to
 838:ProgrammingSteps.c **** 	protected mode only, call ERASE_ALL SROM command */
 839:ProgrammingSteps.c ****     else if (flow == PROT_XXX)
 1264              		.loc 1 839 0
 1265 0092 1C4B     		ldr	r3, .L104+4
 1266 0094 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1267 0096 022B     		cmp	r3, #2
 1268 0098 2DD1     		bne	.L100
 840:ProgrammingSteps.c ****     {
 841:ProgrammingSteps.c **** 		/* Move chip to open state: 0x01 corresponds to open state, 0x00 to
 842:ProgrammingSteps.c **** 		   macro 1 */
 843:ProgrammingSteps.c ****     	parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 1269              		.loc 1 843 0
 1270 009a 204B     		ldr	r3, .L104+28
 1271 009c 7B60     		str	r3, [r7, #4]
 844:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 845:ProgrammingSteps.c **** 					(0x01 << 16) + (0x00 << 24);
 846:ProgrammingSteps.c **** 		
 847:ProgrammingSteps.c **** 		/* Load the write protection command to SRAM */
 848:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, parameter1);
 1272              		.loc 1 848 0
 1273 009e 1C48     		ldr	r0, .L104+16
 1274 00a0 7968     		ldr	r1, [r7, #4]
 1275 00a2 FFF7FEFF 		bl	Write_IO
 849:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1276              		.loc 1 849 0
 1277 00a6 194B     		ldr	r3, .L104+12
 1278 00a8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1279 00aa 012B     		cmp	r3, #1
 1280 00ac 01D0     		beq	.L101
 850:ProgrammingSteps.c ****         {
 851:ProgrammingSteps.c ****             return(FAILURE);
 1281              		.loc 1 851 0
 1282 00ae 0023     		movs	r3, #0
 1283 00b0 22E0     		b	.L93
 1284              	.L101:
 852:ProgrammingSteps.c ****         }
 853:ProgrammingSteps.c ****     	
 854:ProgrammingSteps.c **** 		/* Request SROM call */
 855:ProgrammingSteps.c ****         Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1285              		.loc 1 855 0
 1286 00b2 1848     		ldr	r0, .L104+20
 1287 00b4 1A49     		ldr	r1, .L104+32
 1288 00b6 FFF7FEFF 		bl	Write_IO
 856:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1289              		.loc 1 856 0
 1290 00ba 144B     		ldr	r3, .L104+12
 1291 00bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1292 00be 012B     		cmp	r3, #1
 1293 00c0 01D0     		beq	.L102
 857:ProgrammingSteps.c ****         {
 858:ProgrammingSteps.c ****             return(FAILURE);
 1294              		.loc 1 858 0
 1295 00c2 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 39


 1296 00c4 18E0     		b	.L93
 1297              	.L102:
 859:ProgrammingSteps.c ****         }
 860:ProgrammingSteps.c ****     	
 861:ProgrammingSteps.c **** 		/* Read status of the operation */
 862:ProgrammingSteps.c ****         result = PollSromStatus();
 1298              		.loc 1 862 0
 1299 00c6 FFF7FEFF 		bl	PollSromStatus
 1300 00ca 0346     		mov	r3, r0
 1301 00cc 1A46     		mov	r2, r3
 1302 00ce 0C4B     		ldr	r3, .L104
 1303 00d0 1A70     		strb	r2, [r3]
 863:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1304              		.loc 1 863 0
 1305 00d2 0B4B     		ldr	r3, .L104
 1306 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1307 00d6 012B     		cmp	r3, #1
 1308 00d8 01D0     		beq	.L103
 864:ProgrammingSteps.c ****         {
 865:ProgrammingSteps.c ****             return(FAILURE);
 1309              		.loc 1 865 0
 1310 00da 0023     		movs	r3, #0
 1311 00dc 0CE0     		b	.L93
 1312              	.L103:
 866:ProgrammingSteps.c ****         }
 867:ProgrammingSteps.c **** 		
 868:ProgrammingSteps.c **** 		/* Re-acquire chip in OPEN mode */
 869:ProgrammingSteps.c ****     	result = DeviceAcquire();
 1313              		.loc 1 869 0
 1314 00de FFF7FEFF 		bl	DeviceAcquire
 1315 00e2 0346     		mov	r3, r0
 1316 00e4 1A46     		mov	r2, r3
 1317 00e6 064B     		ldr	r3, .L104
 1318 00e8 1A70     		strb	r2, [r3]
 870:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1319              		.loc 1 870 0
 1320 00ea 054B     		ldr	r3, .L104
 1321 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1322 00ee 012B     		cmp	r3, #1
 1323 00f0 01D0     		beq	.L100
 871:ProgrammingSteps.c ****         {
 872:ProgrammingSteps.c ****             return(FAILURE);
 1324              		.loc 1 872 0
 1325 00f2 0023     		movs	r3, #0
 1326 00f4 00E0     		b	.L93
 1327              	.L100:
 873:ProgrammingSteps.c ****         }
 874:ProgrammingSteps.c ****     }
 875:ProgrammingSteps.c ****     
 876:ProgrammingSteps.c ****     return (SUCCESS);
 1328              		.loc 1 876 0
 1329 00f6 0123     		movs	r3, #1
 1330              	.L93:
 877:ProgrammingSteps.c **** }
 1331              		.loc 1 877 0
 1332 00f8 1846     		mov	r0, r3
 1333 00fa 0837     		adds	r7, r7, #8
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 40


 1334              		.cfi_def_cfa_offset 8
 1335 00fc BD46     		mov	sp, r7
 1336              		.cfi_def_cfa_register 13
 1337              		@ sp needed
 1338 00fe 80BD     		pop	{r7, pc}
 1339              	.L105:
 1340              		.align	2
 1341              	.L104:
 1342 0100 00000000 		.word	result
 1343 0104 00000000 		.word	flow
 1344 0108 00010020 		.word	536871168
 1345 010c 00000000 		.word	swd_PacketAck
 1346 0110 08000040 		.word	1073741832
 1347 0114 04000040 		.word	1073741828
 1348 0118 0A000080 		.word	-2147483638
 1349 011c B6E00100 		.word	123062
 1350 0120 0D000080 		.word	-2147483635
 1351              		.cfi_endproc
 1352              	.LFE71:
 1353              		.size	EraseAllFlash, .-EraseAllFlash
 1354              		.section	.text.ChecksumPrivileged,"ax",%progbits
 1355              		.align	2
 1356              		.global	ChecksumPrivileged
 1357              		.thumb
 1358              		.thumb_func
 1359              		.type	ChecksumPrivileged, %function
 1360              	ChecksumPrivileged:
 1361              	.LFB72:
 878:ProgrammingSteps.c **** 
 879:ProgrammingSteps.c **** /******************************************************************************
 880:ProgrammingSteps.c **** * Function Name: ChecksumPrivileged
 881:ProgrammingSteps.c **** *******************************************************************************
 882:ProgrammingSteps.c **** *
 883:ProgrammingSteps.c **** * Summary:
 884:ProgrammingSteps.c **** *  This is Step 4 of the programming sequence. In this Step, checksum of the 
 885:ProgrammingSteps.c **** *  privileged rows is calulated using system call to determine checksum. This 
 886:ProgrammingSteps.c **** *  step uses ChecksumAPI() API to store the checksum of privileged rows in a 
 887:ProgrammingSteps.c **** *  Checksum_Privileged global variable. This variable is used in step 9 to
 888:ProgrammingSteps.c **** *  calculate the checksum of user rows.
 889:ProgrammingSteps.c **** *
 890:ProgrammingSteps.c **** * Parameters:
 891:ProgrammingSteps.c **** *  None
 892:ProgrammingSteps.c **** *
 893:ProgrammingSteps.c **** * Return:
 894:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully calculated the checksum 
 895:ProgrammingSteps.c **** *            of privileged rows.
 896:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 897:ProgrammingSteps.c **** *			 message.
 898:ProgrammingSteps.c **** *
 899:ProgrammingSteps.c **** * Note:
 900:ProgrammingSteps.c **** *
 901:ProgrammingSteps.c **** ******************************************************************************/
 902:ProgrammingSteps.c **** unsigned char ChecksumPrivileged()
 903:ProgrammingSteps.c **** {        
 1362              		.loc 1 903 0
 1363              		.cfi_startproc
 1364              		@ args = 0, pretend = 0, frame = 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 41


 1365              		@ frame_needed = 1, uses_anonymous_args = 0
 1366 0000 80B5     		push	{r7, lr}
 1367              		.cfi_def_cfa_offset 8
 1368              		.cfi_offset 7, -8
 1369              		.cfi_offset 14, -4
 1370 0002 00AF     		add	r7, sp, #0
 1371              		.cfi_def_cfa_register 7
 904:ProgrammingSteps.c ****     result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_Privileged);
 1372              		.loc 1 904 0
 1373 0004 4FF40040 		mov	r0, #32768
 1374 0008 0749     		ldr	r1, .L109
 1375 000a FFF7FEFF 		bl	ChecksumAPI
 1376 000e 0346     		mov	r3, r0
 1377 0010 1A46     		mov	r2, r3
 1378 0012 064B     		ldr	r3, .L109+4
 1379 0014 1A70     		strb	r2, [r3]
 905:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1380              		.loc 1 905 0
 1381 0016 054B     		ldr	r3, .L109+4
 1382 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1383 001a 012B     		cmp	r3, #1
 1384 001c 01D0     		beq	.L107
 906:ProgrammingSteps.c **** 	{
 907:ProgrammingSteps.c **** 		return (FAILURE);
 1385              		.loc 1 907 0
 1386 001e 0023     		movs	r3, #0
 1387 0020 00E0     		b	.L108
 1388              	.L107:
 908:ProgrammingSteps.c **** 	}
 909:ProgrammingSteps.c **** 	return(SUCCESS);
 1389              		.loc 1 909 0
 1390 0022 0123     		movs	r3, #1
 1391              	.L108:
 910:ProgrammingSteps.c **** }
 1392              		.loc 1 910 0
 1393 0024 1846     		mov	r0, r3
 1394 0026 80BD     		pop	{r7, pc}
 1395              	.L110:
 1396              		.align	2
 1397              	.L109:
 1398 0028 00000000 		.word	checksum_Privileged
 1399 002c 00000000 		.word	result
 1400              		.cfi_endproc
 1401              	.LFE72:
 1402              		.size	ChecksumPrivileged, .-ChecksumPrivileged
 1403              		.section	.text.ProgramFlash,"ax",%progbits
 1404              		.align	2
 1405              		.global	ProgramFlash
 1406              		.thumb
 1407              		.thumb_func
 1408              		.type	ProgramFlash, %function
 1409              	ProgramFlash:
 1410              	.LFB73:
 911:ProgrammingSteps.c **** 
 912:ProgrammingSteps.c **** /******************************************************************************
 913:ProgrammingSteps.c **** * Function Name: ProgramFlash
 914:ProgrammingSteps.c **** *******************************************************************************
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 42


 915:ProgrammingSteps.c **** *
 916:ProgrammingSteps.c **** * Summary:
 917:ProgrammingSteps.c **** *  This is Step 5 of the programming sequence. In this Step, the whole user 
 918:ProgrammingSteps.c **** *  flash is re-programmed with the programming data in the HEX File. This 
 919:ProgrammingSteps.c **** *  function uses LoadLatch() API to latch the row data in SRAM page latch buffer
 920:ProgrammingSteps.c **** *  which is then programmed to the specific row using system calls to program
 921:ProgrammingSteps.c **** *  row.
 922:ProgrammingSteps.c **** *
 923:ProgrammingSteps.c **** * Parameters:
 924:ProgrammingSteps.c **** *  None
 925:ProgrammingSteps.c **** *
 926:ProgrammingSteps.c **** * Return:
 927:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully programs entire flash
 928:ProgrammingSteps.c **** *			 region.
 929:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 930:ProgrammingSteps.c **** *			 message.
 931:ProgrammingSteps.c **** *
 932:ProgrammingSteps.c **** * Note:
 933:ProgrammingSteps.c **** * 
 934:ProgrammingSteps.c **** ******************************************************************************/
 935:ProgrammingSteps.c **** unsigned char ProgramFlash(void)
 936:ProgrammingSteps.c **** {
 1411              		.loc 1 936 0
 1412              		.cfi_startproc
 1413              		@ args = 0, pretend = 0, frame = 144
 1414              		@ frame_needed = 1, uses_anonymous_args = 0
 1415 0000 80B5     		push	{r7, lr}
 1416              		.cfi_def_cfa_offset 8
 1417              		.cfi_offset 7, -8
 1418              		.cfi_offset 14, -4
 1419 0002 A4B0     		sub	sp, sp, #144
 1420              		.cfi_def_cfa_offset 152
 1421 0004 00AF     		add	r7, sp, #0
 1422              		.cfi_def_cfa_register 7
 937:ProgrammingSteps.c **** 	unsigned char arrayID			= 0;
 1423              		.loc 1 937 0
 1424 0006 0023     		movs	r3, #0
 1425 0008 87F88D30 		strb	r3, [r7, #141]
 938:ProgrammingSteps.c **** 	unsigned char rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
 939:ProgrammingSteps.c **** 	
 940:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1426              		.loc 1 940 0
 1427 000c 0023     		movs	r3, #0
 1428 000e A7F88A30 		strh	r3, [r7, #138]	@ movhi
 941:ProgrammingSteps.c ****     unsigned short rowCount			= 0;
 1429              		.loc 1 941 0
 1430 0012 0023     		movs	r3, #0
 1431 0014 A7F88E30 		strh	r3, [r7, #142]	@ movhi
 942:ProgrammingSteps.c **** 	
 943:ProgrammingSteps.c **** 	unsigned long parameter1 		= 0;
 1432              		.loc 1 943 0
 1433 0018 0023     		movs	r3, #0
 1434 001a C7F88430 		str	r3, [r7, #132]
 944:ProgrammingSteps.c **** 	
 945:ProgrammingSteps.c ****     /* Get the total number of flash rows in the Target PSoC 4 device */
 946:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1435              		.loc 1 946 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 43


 1436 001e FFF7FEFF 		bl	GetFlashRowCount
 1437 0022 0346     		mov	r3, r0
 1438 0024 A7F88A30 		strh	r3, [r7, #138]	@ movhi
 947:ProgrammingSteps.c ****            
 948:ProgrammingSteps.c **** 	/* Program all flash rows */
 949:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1439              		.loc 1 949 0
 1440 0028 0023     		movs	r3, #0
 1441 002a A7F88E30 		strh	r3, [r7, #142]	@ movhi
 1442 002e 5DE0     		b	.L112
 1443              	.L119:
 950:ProgrammingSteps.c **** 	{
 951:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1444              		.loc 1 951 0
 1445 0030 B7F88E20 		ldrh	r2, [r7, #142]
 1446 0034 3B1D     		adds	r3, r7, #4
 1447 0036 1046     		mov	r0, r2
 1448 0038 1946     		mov	r1, r3
 1449 003a FFF7FEFF 		bl	HEX_ReadRowData
 952:ProgrammingSteps.c **** 		
 953:ProgrammingSteps.c **** 		arrayID = rowCount/ROWS_PER_ARRAY;
 1450              		.loc 1 953 0
 1451 003e B7F88E30 		ldrh	r3, [r7, #142]
 1452 0042 1B0A     		lsrs	r3, r3, #8
 1453 0044 9BB2     		uxth	r3, r3
 1454 0046 87F88D30 		strb	r3, [r7, #141]
 954:ProgrammingSteps.c **** 		
 955:ProgrammingSteps.c **** 		result = LoadLatch(arrayID, &rowData[0], FLASH_ROW_BYTE_SIZE_HEX_FILE);
 1455              		.loc 1 955 0
 1456 004a 97F88D20 		ldrb	r2, [r7, #141]	@ zero_extendqisi2
 1457 004e 3B1D     		adds	r3, r7, #4
 1458 0050 1046     		mov	r0, r2
 1459 0052 1946     		mov	r1, r3
 1460 0054 8022     		movs	r2, #128
 1461 0056 FFF7FEFF 		bl	LoadLatch
 1462 005a 0346     		mov	r3, r0
 1463 005c 1A46     		mov	r2, r3
 1464 005e 294B     		ldr	r3, .L121
 1465 0060 1A70     		strb	r2, [r3]
 956:ProgrammingSteps.c **** 		if(result != SUCCESS)
 1466              		.loc 1 956 0
 1467 0062 284B     		ldr	r3, .L121
 1468 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1469 0066 012B     		cmp	r3, #1
 1470 0068 01D0     		beq	.L113
 957:ProgrammingSteps.c **** 		{
 958:ProgrammingSteps.c **** 			return(FAILURE);
 1471              		.loc 1 958 0
 1472 006a 0023     		movs	r3, #0
 1473 006c 45E0     		b	.L120
 1474              	.L113:
 959:ProgrammingSteps.c **** 		}
 960:ProgrammingSteps.c **** 
 961:ProgrammingSteps.c **** 	    /* Load parameter1 with Program Row - SROM command */
 962:ProgrammingSteps.c **** 	    parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 963:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 964:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x000000FF) <<  16) +	//
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 44


 1475              		.loc 1 964 0
 1476 006e B7F88E30 		ldrh	r3, [r7, #142]
 1477 0072 DBB2     		uxtb	r3, r3
 1478 0074 1A04     		lsls	r2, r3, #16
 965:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x0000FF00) << 16));
 1479              		.loc 1 965 0
 1480 0076 B7F88E30 		ldrh	r3, [r7, #142]
 1481 007a 03F47F43 		and	r3, r3, #65280
 1482 007e 1B04     		lsls	r3, r3, #16
 962:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 1483              		.loc 1 962 0
 1484 0080 1344     		add	r3, r3, r2
 1485 0082 03F55943 		add	r3, r3, #55552
 1486 0086 B633     		adds	r3, r3, #182
 1487 0088 C7F88430 		str	r3, [r7, #132]
 966:ProgrammingSteps.c ****         
 967:ProgrammingSteps.c **** 		/* Write parameters in SRAM */
 968:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE+0x00, parameter1);
 1488              		.loc 1 968 0
 1489 008c 1E48     		ldr	r0, .L121+4
 1490 008e D7F88410 		ldr	r1, [r7, #132]
 1491 0092 FFF7FEFF 		bl	Write_IO
 969:ProgrammingSteps.c **** 	   	if( swd_PacketAck != SWD_OK_ACK )
 1492              		.loc 1 969 0
 1493 0096 1D4B     		ldr	r3, .L121+8
 1494 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1495 009a 012B     		cmp	r3, #1
 1496 009c 01D0     		beq	.L115
 970:ProgrammingSteps.c **** 	    {
 971:ProgrammingSteps.c **** 	        return (FAILURE);
 1497              		.loc 1 971 0
 1498 009e 0023     		movs	r3, #0
 1499 00a0 2BE0     		b	.L120
 1500              	.L115:
 972:ProgrammingSteps.c **** 	    }
 973:ProgrammingSteps.c **** 	    
 974:ProgrammingSteps.c **** 		/* Set location of parameters */
 975:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1501              		.loc 1 975 0
 1502 00a2 1B48     		ldr	r0, .L121+12
 1503 00a4 1849     		ldr	r1, .L121+4
 1504 00a6 FFF7FEFF 		bl	Write_IO
 976:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1505              		.loc 1 976 0
 1506 00aa 184B     		ldr	r3, .L121+8
 1507 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1508 00ae 012B     		cmp	r3, #1
 1509 00b0 01D0     		beq	.L116
 977:ProgrammingSteps.c **** 	    {
 978:ProgrammingSteps.c **** 	        return (FAILURE);
 1510              		.loc 1 978 0
 1511 00b2 0023     		movs	r3, #0
 1512 00b4 21E0     		b	.L120
 1513              	.L116:
 979:ProgrammingSteps.c **** 	    }
 980:ProgrammingSteps.c **** 	    
 981:ProgrammingSteps.c **** 		/* Request SROM operation */
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 45


 982:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_PROGRAM_ROW);
 1514              		.loc 1 982 0
 1515 00b6 1748     		ldr	r0, .L121+16
 1516 00b8 1749     		ldr	r1, .L121+20
 1517 00ba FFF7FEFF 		bl	Write_IO
 983:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1518              		.loc 1 983 0
 1519 00be 134B     		ldr	r3, .L121+8
 1520 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1521 00c2 012B     		cmp	r3, #1
 1522 00c4 01D0     		beq	.L117
 984:ProgrammingSteps.c **** 	    {
 985:ProgrammingSteps.c **** 	        return (FAILURE);
 1523              		.loc 1 985 0
 1524 00c6 0023     		movs	r3, #0
 1525 00c8 17E0     		b	.L120
 1526              	.L117:
 986:ProgrammingSteps.c **** 	    }
 987:ProgrammingSteps.c **** 	    
 988:ProgrammingSteps.c **** 		/* Read status of the operation */
 989:ProgrammingSteps.c **** 	    result = PollSromStatus();
 1527              		.loc 1 989 0
 1528 00ca FFF7FEFF 		bl	PollSromStatus
 1529 00ce 0346     		mov	r3, r0
 1530 00d0 1A46     		mov	r2, r3
 1531 00d2 0C4B     		ldr	r3, .L121
 1532 00d4 1A70     		strb	r2, [r3]
 990:ProgrammingSteps.c **** 	    if ( result != SROM_SUCCESS )
 1533              		.loc 1 990 0
 1534 00d6 0B4B     		ldr	r3, .L121
 1535 00d8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1536 00da 012B     		cmp	r3, #1
 1537 00dc 01D0     		beq	.L118
 991:ProgrammingSteps.c ****         {
 992:ProgrammingSteps.c ****             return (FAILURE);
 1538              		.loc 1 992 0
 1539 00de 0023     		movs	r3, #0
 1540 00e0 0BE0     		b	.L120
 1541              	.L118:
 949:ProgrammingSteps.c **** 	{
 1542              		.loc 1 949 0 discriminator 2
 1543 00e2 B7F88E30 		ldrh	r3, [r7, #142]
 1544 00e6 0133     		adds	r3, r3, #1
 1545 00e8 A7F88E30 		strh	r3, [r7, #142]	@ movhi
 1546              	.L112:
 949:ProgrammingSteps.c **** 	{
 1547              		.loc 1 949 0 is_stmt 0 discriminator 1
 1548 00ec B7F88E20 		ldrh	r2, [r7, #142]
 1549 00f0 B7F88A30 		ldrh	r3, [r7, #138]
 1550 00f4 9A42     		cmp	r2, r3
 1551 00f6 9BD3     		bcc	.L119
 993:ProgrammingSteps.c ****         }
 994:ProgrammingSteps.c ****         
 995:ProgrammingSteps.c **** 	}
 996:ProgrammingSteps.c **** 	return ( SUCCESS );
 1552              		.loc 1 996 0 is_stmt 1
 1553 00f8 0123     		movs	r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 46


 1554              	.L120:
 997:ProgrammingSteps.c **** }
 1555              		.loc 1 997 0 discriminator 1
 1556 00fa 1846     		mov	r0, r3
 1557 00fc 9037     		adds	r7, r7, #144
 1558              		.cfi_def_cfa_offset 8
 1559 00fe BD46     		mov	sp, r7
 1560              		.cfi_def_cfa_register 13
 1561              		@ sp needed
 1562 0100 80BD     		pop	{r7, pc}
 1563              	.L122:
 1564 0102 00BF     		.align	2
 1565              	.L121:
 1566 0104 00000000 		.word	result
 1567 0108 00010020 		.word	536871168
 1568 010c 00000000 		.word	swd_PacketAck
 1569 0110 08000040 		.word	1073741832
 1570 0114 04000040 		.word	1073741828
 1571 0118 06000080 		.word	-2147483642
 1572              		.cfi_endproc
 1573              	.LFE73:
 1574              		.size	ProgramFlash, .-ProgramFlash
 1575              		.section	.text.VerifyFlash,"ax",%progbits
 1576              		.align	2
 1577              		.global	VerifyFlash
 1578              		.thumb
 1579              		.thumb_func
 1580              		.type	VerifyFlash, %function
 1581              	VerifyFlash:
 1582              	.LFB74:
 998:ProgrammingSteps.c **** 
 999:ProgrammingSteps.c **** /******************************************************************************
1000:ProgrammingSteps.c **** * Function Name: VerifyFlash
1001:ProgrammingSteps.c **** *******************************************************************************
1002:ProgrammingSteps.c **** *
1003:ProgrammingSteps.c **** * Summary:
1004:ProgrammingSteps.c **** *  This is Step 6 of the programming sequence. This is an optional step as we
1005:ProgrammingSteps.c **** *  verify the checksum explicitly. In this Step, flash region is directly read
1006:ProgrammingSteps.c **** *  using Read_IO API defined in SWD_UpperPacketLayer.h and compared with the 
1007:ProgrammingSteps.c **** *  HEX File.
1008:ProgrammingSteps.c **** *
1009:ProgrammingSteps.c **** * Parameters:
1010:ProgrammingSteps.c **** *  None
1011:ProgrammingSteps.c **** *
1012:ProgrammingSteps.c **** * Return:
1013:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the entire flash
1014:ProgrammingSteps.c **** *		     with the HEX File.
1015:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1016:ProgrammingSteps.c **** *			 message.
1017:ProgrammingSteps.c **** *
1018:ProgrammingSteps.c **** * Note:
1019:ProgrammingSteps.c **** * 
1020:ProgrammingSteps.c **** *******************************************************************************************/
1021:ProgrammingSteps.c **** unsigned char VerifyFlash(void)
1022:ProgrammingSteps.c **** { 
 1583              		.loc 1 1022 0
 1584              		.cfi_startproc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 47


 1585              		@ args = 0, pretend = 0, frame = 272
 1586              		@ frame_needed = 1, uses_anonymous_args = 0
 1587 0000 80B5     		push	{r7, lr}
 1588              		.cfi_def_cfa_offset 8
 1589              		.cfi_offset 7, -8
 1590              		.cfi_offset 14, -4
 1591 0002 C4B0     		sub	sp, sp, #272
 1592              		.cfi_def_cfa_offset 280
 1593 0004 00AF     		add	r7, sp, #0
 1594              		.cfi_def_cfa_register 7
1023:ProgrammingSteps.c ****     unsigned long  flashData 		= 0;    
 1595              		.loc 1 1023 0
 1596 0006 0023     		movs	r3, #0
 1597 0008 C7F80031 		str	r3, [r7, #256]
1024:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1598              		.loc 1 1024 0
 1599 000c 0023     		movs	r3, #0
 1600 000e A7F80A31 		strh	r3, [r7, #266]	@ movhi
1025:ProgrammingSteps.c **** 	unsigned long rowAddress 		= 0;
 1601              		.loc 1 1025 0
 1602 0012 0023     		movs	r3, #0
 1603 0014 C7F80431 		str	r3, [r7, #260]
1026:ProgrammingSteps.c ****     unsigned short rowCount;
1027:ProgrammingSteps.c ****     unsigned short  i;
1028:ProgrammingSteps.c ****     unsigned char  rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1029:ProgrammingSteps.c **** 	unsigned char  chipData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1030:ProgrammingSteps.c **** 	
1031:ProgrammingSteps.c **** 	/* Get the total number of flash rows in the Target PSoC 4 device */
1032:ProgrammingSteps.c **** 	numOfFlashRows   = GetFlashRowCount();
 1604              		.loc 1 1032 0
 1605 0018 FFF7FEFF 		bl	GetFlashRowCount
 1606 001c 0346     		mov	r3, r0
 1607 001e A7F80A31 		strh	r3, [r7, #266]	@ movhi
1033:ProgrammingSteps.c **** 
1034:ProgrammingSteps.c **** 	/* Read and Verify Flash rows */
1035:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1608              		.loc 1 1035 0
 1609 0022 0023     		movs	r3, #0
 1610 0024 A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1611 0028 74E0     		b	.L124
 1612              	.L132:
1036:ProgrammingSteps.c **** 	{
1037:ProgrammingSteps.c **** 		/* Read row from hex file */
1038:ProgrammingSteps.c **** 		
1039:ProgrammingSteps.c **** 		/* linear address of row in flash */
1040:ProgrammingSteps.c ****     	rowAddress = FLASH_ROW_BYTE_SIZE_HEX_FILE * rowCount;
 1613              		.loc 1 1040 0
 1614 002a B7F80E31 		ldrh	r3, [r7, #270]
 1615 002e DB01     		lsls	r3, r3, #7
 1616 0030 C7F80431 		str	r3, [r7, #260]
1041:ProgrammingSteps.c ****     	
1042:ProgrammingSteps.c **** 		/* Extract 128-byte row from the hex-file from address: “rowCount” into
1043:ProgrammingSteps.c **** 		   buffer - “rowData”. */
1044:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1617              		.loc 1 1044 0
 1618 0034 B7F80E21 		ldrh	r2, [r7, #270]
 1619 0038 07F18003 		add	r3, r7, #128
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 48


 1620 003c 1046     		mov	r0, r2
 1621 003e 1946     		mov	r1, r3
 1622 0040 FFF7FEFF 		bl	HEX_ReadRowData
1045:ProgrammingSteps.c **** 
1046:ProgrammingSteps.c ****     	/* Read row from chip */
1047:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 1623              		.loc 1 1047 0
 1624 0044 0023     		movs	r3, #0
 1625 0046 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1626 004a 37E0     		b	.L125
 1627              	.L128:
1048:ProgrammingSteps.c ****     	{
1049:ProgrammingSteps.c **** 			/* Read flash via AHB-interface */
1050:ProgrammingSteps.c ****        		Read_IO( rowAddress + i, &flashData);
 1628              		.loc 1 1050 0
 1629 004c B7F80C21 		ldrh	r2, [r7, #268]
 1630 0050 D7F80431 		ldr	r3, [r7, #260]
 1631 0054 1A44     		add	r2, r2, r3
 1632 0056 07F58073 		add	r3, r7, #256
 1633 005a 1046     		mov	r0, r2
 1634 005c 1946     		mov	r1, r3
 1635 005e FFF7FEFF 		bl	Read_IO
1051:ProgrammingSteps.c ****             if( swd_PacketAck != SWD_OK_ACK )
 1636              		.loc 1 1051 0
 1637 0062 324B     		ldr	r3, .L134
 1638 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1639 0066 012B     		cmp	r3, #1
 1640 0068 01D0     		beq	.L126
1052:ProgrammingSteps.c ****     	    {
1053:ProgrammingSteps.c ****     	        return (FAILURE);
 1641              		.loc 1 1053 0
 1642 006a 0023     		movs	r3, #0
 1643 006c 59E0     		b	.L133
 1644              	.L126:
1054:ProgrammingSteps.c ****     	    }
1055:ProgrammingSteps.c ****             
1056:ProgrammingSteps.c ****             chipData[i + 0] = (flashData >> 0) & 0xFF;
 1645              		.loc 1 1056 0 discriminator 2
 1646 006e B7F80C31 		ldrh	r3, [r7, #268]
 1647 0072 D7F80021 		ldr	r2, [r7, #256]
 1648 0076 D1B2     		uxtb	r1, r2
 1649 0078 3A46     		mov	r2, r7
 1650 007a D154     		strb	r1, [r2, r3]
1057:ProgrammingSteps.c ****             chipData[i + 1] = (flashData >> 8) & 0xFF;
 1651              		.loc 1 1057 0 discriminator 2
 1652 007c B7F80C31 		ldrh	r3, [r7, #268]
 1653 0080 0133     		adds	r3, r3, #1
 1654 0082 D7F80021 		ldr	r2, [r7, #256]
 1655 0086 120A     		lsrs	r2, r2, #8
 1656 0088 D1B2     		uxtb	r1, r2
 1657 008a 3A46     		mov	r2, r7
 1658 008c D154     		strb	r1, [r2, r3]
1058:ProgrammingSteps.c ****             chipData[i + 2] = (flashData >> 16) & 0xFF;
 1659              		.loc 1 1058 0 discriminator 2
 1660 008e B7F80C31 		ldrh	r3, [r7, #268]
 1661 0092 0233     		adds	r3, r3, #2
 1662 0094 D7F80021 		ldr	r2, [r7, #256]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 49


 1663 0098 120C     		lsrs	r2, r2, #16
 1664 009a D1B2     		uxtb	r1, r2
 1665 009c 3A46     		mov	r2, r7
 1666 009e D154     		strb	r1, [r2, r3]
1059:ProgrammingSteps.c ****             chipData[i + 3] = (flashData >> 24) & 0xFF;
 1667              		.loc 1 1059 0 discriminator 2
 1668 00a0 B7F80C31 		ldrh	r3, [r7, #268]
 1669 00a4 0333     		adds	r3, r3, #3
 1670 00a6 D7F80021 		ldr	r2, [r7, #256]
 1671 00aa 120E     		lsrs	r2, r2, #24
 1672 00ac D1B2     		uxtb	r1, r2
 1673 00ae 3A46     		mov	r2, r7
 1674 00b0 D154     		strb	r1, [r2, r3]
1047:ProgrammingSteps.c ****     	{
 1675              		.loc 1 1047 0 discriminator 2
 1676 00b2 B7F80C31 		ldrh	r3, [r7, #268]	@ movhi
 1677 00b6 0433     		adds	r3, r3, #4
 1678 00b8 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1679              	.L125:
1047:ProgrammingSteps.c ****     	{
 1680              		.loc 1 1047 0 is_stmt 0 discriminator 1
 1681 00bc B7F80C31 		ldrh	r3, [r7, #268]
 1682 00c0 7F2B     		cmp	r3, #127
 1683 00c2 C3D9     		bls	.L128
1060:ProgrammingSteps.c ****     	}
1061:ProgrammingSteps.c **** 
1062:ProgrammingSteps.c ****     	/* Compare the row data of HEX file with chip data */
1063:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i++)
 1684              		.loc 1 1063 0 is_stmt 1
 1685 00c4 0023     		movs	r3, #0
 1686 00c6 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1687 00ca 1AE0     		b	.L129
 1688              	.L131:
1064:ProgrammingSteps.c ****     	{
1065:ProgrammingSteps.c ****        		if (chipData[i] != rowData[i])
 1689              		.loc 1 1065 0
 1690 00cc B7F80C31 		ldrh	r3, [r7, #268]
 1691 00d0 3A46     		mov	r2, r7
 1692 00d2 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 1693 00d4 B7F80C31 		ldrh	r3, [r7, #268]
 1694 00d8 07F58871 		add	r1, r7, #272
 1695 00dc 0B44     		add	r3, r3, r1
 1696 00de 13F8903C 		ldrb	r3, [r3, #-144]	@ zero_extendqisi2
 1697 00e2 9A42     		cmp	r2, r3
 1698 00e4 08D0     		beq	.L130
1066:ProgrammingSteps.c **** 			{
1067:ProgrammingSteps.c **** 				swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1699              		.loc 1 1067 0
 1700 00e6 114B     		ldr	r3, .L134
 1701 00e8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1702 00ea 43F04003 		orr	r3, r3, #64
 1703 00ee DAB2     		uxtb	r2, r3
 1704 00f0 0E4B     		ldr	r3, .L134
 1705 00f2 1A70     		strb	r2, [r3]
1068:ProgrammingSteps.c **** 				return ( FAILURE );
 1706              		.loc 1 1068 0
 1707 00f4 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 50


 1708 00f6 14E0     		b	.L133
 1709              	.L130:
1063:ProgrammingSteps.c ****     	{
 1710              		.loc 1 1063 0 discriminator 2
 1711 00f8 B7F80C31 		ldrh	r3, [r7, #268]
 1712 00fc 0133     		adds	r3, r3, #1
 1713 00fe A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1714              	.L129:
1063:ProgrammingSteps.c ****     	{
 1715              		.loc 1 1063 0 is_stmt 0 discriminator 1
 1716 0102 B7F80C31 		ldrh	r3, [r7, #268]
 1717 0106 7F2B     		cmp	r3, #127
 1718 0108 E0D9     		bls	.L131
1035:ProgrammingSteps.c **** 	{
 1719              		.loc 1 1035 0 is_stmt 1 discriminator 2
 1720 010a B7F80E31 		ldrh	r3, [r7, #270]
 1721 010e 0133     		adds	r3, r3, #1
 1722 0110 A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1723              	.L124:
1035:ProgrammingSteps.c **** 	{
 1724              		.loc 1 1035 0 is_stmt 0 discriminator 1
 1725 0114 B7F80E21 		ldrh	r2, [r7, #270]
 1726 0118 B7F80A31 		ldrh	r3, [r7, #266]
 1727 011c 9A42     		cmp	r2, r3
 1728 011e 84D3     		bcc	.L132
1069:ProgrammingSteps.c **** 			}
1070:ProgrammingSteps.c ****     	}
1071:ProgrammingSteps.c **** 	}
1072:ProgrammingSteps.c **** 	return ( SUCCESS );
 1729              		.loc 1 1072 0 is_stmt 1
 1730 0120 0123     		movs	r3, #1
 1731              	.L133:
1073:ProgrammingSteps.c **** }
 1732              		.loc 1 1073 0 discriminator 1
 1733 0122 1846     		mov	r0, r3
 1734 0124 07F58877 		add	r7, r7, #272
 1735              		.cfi_def_cfa_offset 8
 1736 0128 BD46     		mov	sp, r7
 1737              		.cfi_def_cfa_register 13
 1738              		@ sp needed
 1739 012a 80BD     		pop	{r7, pc}
 1740              	.L135:
 1741              		.align	2
 1742              	.L134:
 1743 012c 00000000 		.word	swd_PacketAck
 1744              		.cfi_endproc
 1745              	.LFE74:
 1746              		.size	VerifyFlash, .-VerifyFlash
 1747              		.section	.text.ProgramProtectionSettings,"ax",%progbits
 1748              		.align	2
 1749              		.global	ProgramProtectionSettings
 1750              		.thumb
 1751              		.thumb_func
 1752              		.type	ProgramProtectionSettings, %function
 1753              	ProgramProtectionSettings:
 1754              	.LFB75:
1074:ProgrammingSteps.c **** 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 51


1075:ProgrammingSteps.c **** /******************************************************************************
1076:ProgrammingSteps.c **** * Function Name: ProgramProtectionSettings
1077:ProgrammingSteps.c **** *******************************************************************************
1078:ProgrammingSteps.c **** *
1079:ProgrammingSteps.c **** * Summary:
1080:ProgrammingSteps.c **** *  This is Step 7 of the programming sequence. In this step, Chip protection 
1081:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and 
1082:ProgrammingSteps.c **** *  programmed to the specific loctions in the flash.
1083:ProgrammingSteps.c **** *
1084:ProgrammingSteps.c **** * Parameters:
1085:ProgrammingSteps.c **** *  None
1086:ProgrammingSteps.c **** *
1087:ProgrammingSteps.c **** * Return:
1088:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully writes the protection
1089:ProgrammingSteps.c **** *			 settings.
1090:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1091:ProgrammingSteps.c **** *			 message.
1092:ProgrammingSteps.c **** *
1093:ProgrammingSteps.c **** * Note:
1094:ProgrammingSteps.c **** *
1095:ProgrammingSteps.c **** ******************************************************************************/
1096:ProgrammingSteps.c **** unsigned char ProgramProtectionSettings(void)
1097:ProgrammingSteps.c **** {
 1755              		.loc 1 1097 0
 1756              		.cfi_startproc
 1757              		@ args = 0, pretend = 0, frame = 48
 1758              		@ frame_needed = 1, uses_anonymous_args = 0
 1759 0000 80B5     		push	{r7, lr}
 1760              		.cfi_def_cfa_offset 8
 1761              		.cfi_offset 7, -8
 1762              		.cfi_offset 14, -4
 1763 0002 8CB0     		sub	sp, sp, #48
 1764              		.cfi_def_cfa_offset 56
 1765 0004 00AF     		add	r7, sp, #0
 1766              		.cfi_def_cfa_register 7
1098:ProgrammingSteps.c **** 	unsigned char  arrayID = 0;
 1767              		.loc 1 1098 0
 1768 0006 0023     		movs	r3, #0
 1769 0008 87F82F30 		strb	r3, [r7, #47]
1099:ProgrammingSteps.c ****     unsigned char  arrayMax = 0;
 1770              		.loc 1 1099 0
 1771 000c 0023     		movs	r3, #0
 1772 000e 87F82E30 		strb	r3, [r7, #46]
1100:ProgrammingSteps.c ****     unsigned char  rowProtectionByteSize = 0;
 1773              		.loc 1 1100 0
 1774 0012 0023     		movs	r3, #0
 1775 0014 87F82D30 		strb	r3, [r7, #45]
1101:ProgrammingSteps.c **** 	unsigned char  rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
1102:ProgrammingSteps.c **** 	unsigned char  chipProtectionData_Hex;
1103:ProgrammingSteps.c **** 	
1104:ProgrammingSteps.c **** 	unsigned short numOfFlashRows = 0;
 1776              		.loc 1 1104 0
 1777 0018 0023     		movs	r3, #0
 1778 001a 7B85     		strh	r3, [r7, #42]	@ movhi
1105:ProgrammingSteps.c **** 	
1106:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1779              		.loc 1 1106 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 52


 1780 001c 0023     		movs	r3, #0
 1781 001e 7B62     		str	r3, [r7, #36]
1107:ProgrammingSteps.c **** 	
1108:ProgrammingSteps.c **** 	/* Get total number of flash rows to determine the size of row protection data
1109:ProgrammingSteps.c **** 	   and arrayID */
1110:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1782              		.loc 1 1110 0
 1783 0020 FFF7FEFF 		bl	GetFlashRowCount
 1784 0024 0346     		mov	r3, r0
 1785 0026 7B85     		strh	r3, [r7, #42]	@ movhi
1111:ProgrammingSteps.c ****     
1112:ProgrammingSteps.c **** 	arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 1786              		.loc 1 1112 0
 1787 0028 7B8D     		ldrh	r3, [r7, #42]
 1788 002a 1B0A     		lsrs	r3, r3, #8
 1789 002c 9BB2     		uxth	r3, r3
 1790 002e 87F82E30 		strb	r3, [r7, #46]
1113:ProgrammingSteps.c ****     
1114:ProgrammingSteps.c ****     rowProtectionByteSize = numOfFlashRows / (8 * arrayMax);
 1791              		.loc 1 1114 0
 1792 0032 7A8D     		ldrh	r2, [r7, #42]
 1793 0034 97F82E30 		ldrb	r3, [r7, #46]	@ zero_extendqisi2
 1794 0038 DB00     		lsls	r3, r3, #3
 1795 003a 92FBF3F3 		sdiv	r3, r2, r3
 1796 003e 87F82D30 		strb	r3, [r7, #45]
1115:ProgrammingSteps.c **** 	
1116:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 1797              		.loc 1 1116 0
 1798 0042 FB1C     		adds	r3, r7, #3
 1799 0044 1846     		mov	r0, r3
 1800 0046 FFF7FEFF 		bl	HEX_ReadChipProtectionData
1117:ProgrammingSteps.c ****  
1118:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++)
 1801              		.loc 1 1118 0
 1802 004a 0023     		movs	r3, #0
 1803 004c 87F82F30 		strb	r3, [r7, #47]
 1804 0050 4DE0     		b	.L137
 1805              	.L143:
1119:ProgrammingSteps.c ****     {
1120:ProgrammingSteps.c ****         
1121:ProgrammingSteps.c ****         HEX_ReadRowProtectionData(rowProtectionByteSize, &rowProtectionData[0], arrayID);
 1806              		.loc 1 1121 0
 1807 0052 97F82D10 		ldrb	r1, [r7, #45]	@ zero_extendqisi2
 1808 0056 3A1D     		adds	r2, r7, #4
 1809 0058 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 1810 005c 0846     		mov	r0, r1
 1811 005e 1146     		mov	r1, r2
 1812 0060 1A46     		mov	r2, r3
 1813 0062 FFF7FEFF 		bl	HEX_ReadRowProtectionData
1122:ProgrammingSteps.c **** 
1123:ProgrammingSteps.c ****     	/* Load protection setting of current macro into volatile latch using 
1124:ProgrammingSteps.c ****     	   LoadLatch API */
1125:ProgrammingSteps.c ****     	result = LoadLatch(arrayID, &rowProtectionData[0], rowProtectionByteSize);
 1814              		.loc 1 1125 0
 1815 0066 97F82D30 		ldrb	r3, [r7, #45]	@ zero_extendqisi2
 1816 006a 9BB2     		uxth	r3, r3
 1817 006c 97F82F10 		ldrb	r1, [r7, #47]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 53


 1818 0070 3A1D     		adds	r2, r7, #4
 1819 0072 0846     		mov	r0, r1
 1820 0074 1146     		mov	r1, r2
 1821 0076 1A46     		mov	r2, r3
 1822 0078 FFF7FEFF 		bl	LoadLatch
 1823 007c 0346     		mov	r3, r0
 1824 007e 1A46     		mov	r2, r3
 1825 0080 204B     		ldr	r3, .L145
 1826 0082 1A70     		strb	r2, [r3]
1126:ProgrammingSteps.c ****     	
1127:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1827              		.loc 1 1127 0
 1828 0084 1F4B     		ldr	r3, .L145
 1829 0086 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1830 0088 012B     		cmp	r3, #1
 1831 008a 01D0     		beq	.L138
1128:ProgrammingSteps.c ****     	{
1129:ProgrammingSteps.c ****     		return(FAILURE);
 1832              		.loc 1 1129 0
 1833 008c 0023     		movs	r3, #0
 1834 008e 35E0     		b	.L144
 1835              	.L138:
1130:ProgrammingSteps.c ****     	}
1131:ProgrammingSteps.c **** 
1132:ProgrammingSteps.c ****     	/* Program protection setting into supervisory row */
1133:ProgrammingSteps.c ****     	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
1134:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
1135:ProgrammingSteps.c ****     				((unsigned long)chipProtectionData_Hex << 16) + ((unsigned long)arrayID << 24));
 1836              		.loc 1 1135 0
 1837 0090 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1838 0092 1A04     		lsls	r2, r3, #16
 1839 0094 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 1840 0098 1B06     		lsls	r3, r3, #24
1133:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 1841              		.loc 1 1133 0
 1842 009a 1344     		add	r3, r3, r2
 1843 009c 03F56043 		add	r3, r3, #57344
 1844 00a0 B633     		adds	r3, r3, #182
 1845 00a2 7B62     		str	r3, [r7, #36]
1136:ProgrammingSteps.c ****     	
1137:ProgrammingSteps.c ****     	/* Load parameter1 in CPUSS_SYSARG register */
1138:ProgrammingSteps.c ****     	Write_IO(CPUSS_SYSARG, parameter1);	    
 1846              		.loc 1 1138 0
 1847 00a4 1848     		ldr	r0, .L145+4
 1848 00a6 796A     		ldr	r1, [r7, #36]
 1849 00a8 FFF7FEFF 		bl	Write_IO
1139:ProgrammingSteps.c ****     	
1140:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1850              		.loc 1 1140 0
 1851 00ac 174B     		ldr	r3, .L145+8
 1852 00ae 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1853 00b0 012B     		cmp	r3, #1
 1854 00b2 01D0     		beq	.L140
1141:ProgrammingSteps.c ****         {
1142:ProgrammingSteps.c ****             return (FAILURE);
 1855              		.loc 1 1142 0
 1856 00b4 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 54


 1857 00b6 21E0     		b	.L144
 1858              	.L140:
1143:ProgrammingSteps.c ****         }
1144:ProgrammingSteps.c ****     	
1145:ProgrammingSteps.c ****     	/* Request SROM call */
1146:ProgrammingSteps.c ****         Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1859              		.loc 1 1146 0
 1860 00b8 1548     		ldr	r0, .L145+12
 1861 00ba 1649     		ldr	r1, .L145+16
 1862 00bc FFF7FEFF 		bl	Write_IO
1147:ProgrammingSteps.c **** 
1148:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1863              		.loc 1 1148 0
 1864 00c0 124B     		ldr	r3, .L145+8
 1865 00c2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1866 00c4 012B     		cmp	r3, #1
 1867 00c6 01D0     		beq	.L141
1149:ProgrammingSteps.c ****         {
1150:ProgrammingSteps.c ****             return (FAILURE);
 1868              		.loc 1 1150 0
 1869 00c8 0023     		movs	r3, #0
 1870 00ca 17E0     		b	.L144
 1871              	.L141:
1151:ProgrammingSteps.c ****         }
1152:ProgrammingSteps.c **** 
1153:ProgrammingSteps.c ****     	/* Read status of the operation */
1154:ProgrammingSteps.c ****     	result = PollSromStatus();
 1872              		.loc 1 1154 0
 1873 00cc FFF7FEFF 		bl	PollSromStatus
 1874 00d0 0346     		mov	r3, r0
 1875 00d2 1A46     		mov	r2, r3
 1876 00d4 0B4B     		ldr	r3, .L145
 1877 00d6 1A70     		strb	r2, [r3]
1155:ProgrammingSteps.c **** 
1156:ProgrammingSteps.c ****     	if( result != SROM_SUCCESS )
 1878              		.loc 1 1156 0
 1879 00d8 0A4B     		ldr	r3, .L145
 1880 00da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1881 00dc 012B     		cmp	r3, #1
 1882 00de 01D0     		beq	.L142
1157:ProgrammingSteps.c ****         {
1158:ProgrammingSteps.c ****             return (FAILURE);
 1883              		.loc 1 1158 0
 1884 00e0 0023     		movs	r3, #0
 1885 00e2 0BE0     		b	.L144
 1886              	.L142:
1118:ProgrammingSteps.c ****     {
 1887              		.loc 1 1118 0 discriminator 2
 1888 00e4 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 1889 00e8 0133     		adds	r3, r3, #1
 1890 00ea 87F82F30 		strb	r3, [r7, #47]
 1891              	.L137:
1118:ProgrammingSteps.c ****     {
 1892              		.loc 1 1118 0 is_stmt 0 discriminator 1
 1893 00ee 97F82F20 		ldrb	r2, [r7, #47]	@ zero_extendqisi2
 1894 00f2 97F82E30 		ldrb	r3, [r7, #46]	@ zero_extendqisi2
 1895 00f6 9A42     		cmp	r2, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 55


 1896 00f8 ABD3     		bcc	.L143
1159:ProgrammingSteps.c ****         }
1160:ProgrammingSteps.c ****     
1161:ProgrammingSteps.c ****     }
1162:ProgrammingSteps.c **** 
1163:ProgrammingSteps.c **** 	return (SUCCESS);
 1897              		.loc 1 1163 0 is_stmt 1
 1898 00fa 0123     		movs	r3, #1
 1899              	.L144:
1164:ProgrammingSteps.c **** }
 1900              		.loc 1 1164 0 discriminator 1
 1901 00fc 1846     		mov	r0, r3
 1902 00fe 3037     		adds	r7, r7, #48
 1903              		.cfi_def_cfa_offset 8
 1904 0100 BD46     		mov	sp, r7
 1905              		.cfi_def_cfa_register 13
 1906              		@ sp needed
 1907 0102 80BD     		pop	{r7, pc}
 1908              	.L146:
 1909              		.align	2
 1910              	.L145:
 1911 0104 00000000 		.word	result
 1912 0108 08000040 		.word	1073741832
 1913 010c 00000000 		.word	swd_PacketAck
 1914 0110 04000040 		.word	1073741828
 1915 0114 0D000080 		.word	-2147483635
 1916              		.cfi_endproc
 1917              	.LFE75:
 1918              		.size	ProgramProtectionSettings, .-ProgramProtectionSettings
 1919              		.section	.text.VerifyProtectionSettings,"ax",%progbits
 1920              		.align	2
 1921              		.global	VerifyProtectionSettings
 1922              		.thumb
 1923              		.thumb_func
 1924              		.type	VerifyProtectionSettings, %function
 1925              	VerifyProtectionSettings:
 1926              	.LFB76:
1165:ProgrammingSteps.c **** 
1166:ProgrammingSteps.c **** /******************************************************************************
1167:ProgrammingSteps.c **** * Function Name: VerifyProtectionSettings
1168:ProgrammingSteps.c **** *******************************************************************************
1169:ProgrammingSteps.c **** *
1170:ProgrammingSteps.c **** * Summary:
1171:ProgrammingSteps.c **** *  This is Step 8 of the programming sequence. In this step, Chip protection 
1172:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and verified 
1173:ProgrammingSteps.c **** *  with the protection settings programmed in flash.
1174:ProgrammingSteps.c **** *
1175:ProgrammingSteps.c **** * Parameters:
1176:ProgrammingSteps.c **** *  None
1177:ProgrammingSteps.c **** *
1178:ProgrammingSteps.c **** * Return:
1179:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the protection
1180:ProgrammingSteps.c **** *  			 settings.
1181:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1182:ProgrammingSteps.c **** *			 message.
1183:ProgrammingSteps.c **** *
1184:ProgrammingSteps.c **** * Note:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 56


1185:ProgrammingSteps.c **** *
1186:ProgrammingSteps.c **** ******************************************************************************/
1187:ProgrammingSteps.c **** unsigned char VerifyProtectionSettings(void)
1188:ProgrammingSteps.c **** {
 1927              		.loc 1 1188 0
 1928              		.cfi_startproc
 1929              		@ args = 0, pretend = 0, frame = 88
 1930              		@ frame_needed = 1, uses_anonymous_args = 0
 1931 0000 80B5     		push	{r7, lr}
 1932              		.cfi_def_cfa_offset 8
 1933              		.cfi_offset 7, -8
 1934              		.cfi_offset 14, -4
 1935 0002 96B0     		sub	sp, sp, #88
 1936              		.cfi_def_cfa_offset 96
 1937 0004 00AF     		add	r7, sp, #0
 1938              		.cfi_def_cfa_register 7
1189:ProgrammingSteps.c **** 	unsigned long protectionData 			= 0;
 1939              		.loc 1 1189 0
 1940 0006 0023     		movs	r3, #0
 1941 0008 BB64     		str	r3, [r7, #72]
1190:ProgrammingSteps.c **** 	unsigned long flashProtectionAddress 	= 0;
 1942              		.loc 1 1190 0
 1943 000a 0023     		movs	r3, #0
 1944 000c 7B65     		str	r3, [r7, #84]
1191:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 			= 0;
 1945              		.loc 1 1191 0
 1946 000e 0023     		movs	r3, #0
 1947 0010 A7F85030 		strh	r3, [r7, #80]	@ movhi
1192:ProgrammingSteps.c ****     unsigned char chipProtectionData_Hex 	= 0;
 1948              		.loc 1 1192 0
 1949 0014 0023     		movs	r3, #0
 1950 0016 87F84730 		strb	r3, [r7, #71]
1193:ProgrammingSteps.c **** 	unsigned char rowProtectionByteSize 	= 0;
 1951              		.loc 1 1193 0
 1952 001a 0023     		movs	r3, #0
 1953 001c 87F84F30 		strb	r3, [r7, #79]
1194:ProgrammingSteps.c **** 	unsigned char i;
1195:ProgrammingSteps.c ****     unsigned char rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
1196:ProgrammingSteps.c ****     unsigned char rowProtectionFlashData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];    
1197:ProgrammingSteps.c ****     unsigned char arrayID                   = 0;
 1954              		.loc 1 1197 0
 1955 0020 0023     		movs	r3, #0
 1956 0022 87F85230 		strb	r3, [r7, #82]
1198:ProgrammingSteps.c ****     unsigned char arrayMax                  = 0;
 1957              		.loc 1 1198 0
 1958 0026 0023     		movs	r3, #0
 1959 0028 87F84E30 		strb	r3, [r7, #78]
1199:ProgrammingSteps.c ****         
1200:ProgrammingSteps.c ****     numOfFlashRows = GetFlashRowCount();
 1960              		.loc 1 1200 0
 1961 002c FFF7FEFF 		bl	GetFlashRowCount
 1962 0030 0346     		mov	r3, r0
 1963 0032 A7F85030 		strh	r3, [r7, #80]	@ movhi
1201:ProgrammingSteps.c ****     
1202:ProgrammingSteps.c ****     arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 1964              		.loc 1 1202 0
 1965 0036 B7F85030 		ldrh	r3, [r7, #80]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 57


 1966 003a 1B0A     		lsrs	r3, r3, #8
 1967 003c 9BB2     		uxth	r3, r3
 1968 003e 87F84E30 		strb	r3, [r7, #78]
1203:ProgrammingSteps.c ****     
1204:ProgrammingSteps.c **** 	rowProtectionByteSize = numOfFlashRows/(8 * arrayMax);   
 1969              		.loc 1 1204 0
 1970 0042 B7F85020 		ldrh	r2, [r7, #80]
 1971 0046 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 1972 004a DB00     		lsls	r3, r3, #3
 1973 004c 92FBF3F3 		sdiv	r3, r2, r3
 1974 0050 87F84F30 		strb	r3, [r7, #79]
1205:ProgrammingSteps.c **** 
1206:ProgrammingSteps.c **** 	flashProtectionAddress = SFLASH_MACRO;
 1975              		.loc 1 1206 0
 1976 0054 664B     		ldr	r3, .L162
 1977 0056 7B65     		str	r3, [r7, #84]
1207:ProgrammingSteps.c **** 	
1208:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++, flashProtectionAddress += FLASH_PROTECTION_ADD
 1978              		.loc 1 1208 0
 1979 0058 0023     		movs	r3, #0
 1980 005a 87F85230 		strb	r3, [r7, #82]
 1981 005e 84E0     		b	.L148
 1982              	.L156:
1209:ProgrammingSteps.c ****     {
1210:ProgrammingSteps.c ****         /* Read Protection settings from hex-file */
1211:ProgrammingSteps.c **** 	    HEX_ReadRowProtectionData(rowProtectionByteSize,&rowProtectionData[0], arrayID);
 1983              		.loc 1 1211 0
 1984 0060 97F84F10 		ldrb	r1, [r7, #79]	@ zero_extendqisi2
 1985 0064 07F12402 		add	r2, r7, #36
 1986 0068 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 1987 006c 0846     		mov	r0, r1
 1988 006e 1146     		mov	r1, r2
 1989 0070 1A46     		mov	r2, r3
 1990 0072 FFF7FEFF 		bl	HEX_ReadRowProtectionData
1212:ProgrammingSteps.c **** 	        
1213:ProgrammingSteps.c ****         /* Read Protection settings from silicon */
1214:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize;  i += 4)
 1991              		.loc 1 1214 0
 1992 0076 0023     		movs	r3, #0
 1993 0078 87F85330 		strb	r3, [r7, #83]
 1994 007c 3EE0     		b	.L149
 1995              	.L152:
1215:ProgrammingSteps.c ****     	{
1216:ProgrammingSteps.c ****     		Read_IO(flashProtectionAddress + i, &protectionData);
 1996              		.loc 1 1216 0
 1997 007e 97F85320 		ldrb	r2, [r7, #83]	@ zero_extendqisi2
 1998 0082 7B6D     		ldr	r3, [r7, #84]
 1999 0084 1A44     		add	r2, r2, r3
 2000 0086 07F14803 		add	r3, r7, #72
 2001 008a 1046     		mov	r0, r2
 2002 008c 1946     		mov	r1, r3
 2003 008e FFF7FEFF 		bl	Read_IO
1217:ProgrammingSteps.c ****     	    
1218:ProgrammingSteps.c ****     		if( swd_PacketAck != SWD_OK_ACK )
 2004              		.loc 1 1218 0
 2005 0092 584B     		ldr	r3, .L162+4
 2006 0094 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 58


 2007 0096 012B     		cmp	r3, #1
 2008 0098 01D0     		beq	.L150
1219:ProgrammingSteps.c ****     	    {
1220:ProgrammingSteps.c ****     	        return (FAILURE);
 2009              		.loc 1 1220 0
 2010 009a 0023     		movs	r3, #0
 2011 009c A4E0     		b	.L161
 2012              	.L150:
1221:ProgrammingSteps.c ****     	    }
1222:ProgrammingSteps.c ****     		
1223:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 0] = (protectionData >> 0) & 0xFF;     
 2013              		.loc 1 1223 0 discriminator 2
 2014 009e 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2015 00a2 BA6C     		ldr	r2, [r7, #72]
 2016 00a4 D2B2     		uxtb	r2, r2
 2017 00a6 07F15801 		add	r1, r7, #88
 2018 00aa 0B44     		add	r3, r3, r1
 2019 00ac 03F8542C 		strb	r2, [r3, #-84]
1224:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 1] = (protectionData >> 8) & 0xFF;
 2020              		.loc 1 1224 0 discriminator 2
 2021 00b0 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2022 00b4 0133     		adds	r3, r3, #1
 2023 00b6 BA6C     		ldr	r2, [r7, #72]
 2024 00b8 120A     		lsrs	r2, r2, #8
 2025 00ba D2B2     		uxtb	r2, r2
 2026 00bc 07F15801 		add	r1, r7, #88
 2027 00c0 0B44     		add	r3, r3, r1
 2028 00c2 03F8542C 		strb	r2, [r3, #-84]
1225:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 2] = (protectionData >> 16) & 0xFF;
 2029              		.loc 1 1225 0 discriminator 2
 2030 00c6 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2031 00ca 0233     		adds	r3, r3, #2
 2032 00cc BA6C     		ldr	r2, [r7, #72]
 2033 00ce 120C     		lsrs	r2, r2, #16
 2034 00d0 D2B2     		uxtb	r2, r2
 2035 00d2 07F15801 		add	r1, r7, #88
 2036 00d6 0B44     		add	r3, r3, r1
 2037 00d8 03F8542C 		strb	r2, [r3, #-84]
1226:ProgrammingSteps.c ****     	    rowProtectionFlashData[i + 3] = (protectionData >> 24) & 0xFF;
 2038              		.loc 1 1226 0 discriminator 2
 2039 00dc 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2040 00e0 0333     		adds	r3, r3, #3
 2041 00e2 BA6C     		ldr	r2, [r7, #72]
 2042 00e4 120E     		lsrs	r2, r2, #24
 2043 00e6 D2B2     		uxtb	r2, r2
 2044 00e8 07F15801 		add	r1, r7, #88
 2045 00ec 0B44     		add	r3, r3, r1
 2046 00ee 03F8542C 		strb	r2, [r3, #-84]
1214:ProgrammingSteps.c ****     	{
 2047              		.loc 1 1214 0 discriminator 2
 2048 00f2 97F85330 		ldrb	r3, [r7, #83]
 2049 00f6 0433     		adds	r3, r3, #4
 2050 00f8 87F85330 		strb	r3, [r7, #83]
 2051              	.L149:
1214:ProgrammingSteps.c ****     	{
 2052              		.loc 1 1214 0 is_stmt 0 discriminator 1
 2053 00fc 97F85320 		ldrb	r2, [r7, #83]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 59


 2054 0100 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 2055 0104 9A42     		cmp	r2, r3
 2056 0106 BAD3     		bcc	.L152
1227:ProgrammingSteps.c ****     	}
1228:ProgrammingSteps.c **** 
1229:ProgrammingSteps.c ****     	/* Compare hex and silicon’s data */
1230:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize; i++ )
 2057              		.loc 1 1230 0 is_stmt 1
 2058 0108 0023     		movs	r3, #0
 2059 010a 87F85330 		strb	r3, [r7, #83]
 2060 010e 1DE0     		b	.L153
 2061              	.L155:
1231:ProgrammingSteps.c ****     	{
1232:ProgrammingSteps.c ****     		if (rowProtectionData[i] != rowProtectionFlashData[i])
 2062              		.loc 1 1232 0
 2063 0110 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2064 0114 07F15802 		add	r2, r7, #88
 2065 0118 1344     		add	r3, r3, r2
 2066 011a 13F8342C 		ldrb	r2, [r3, #-52]	@ zero_extendqisi2
 2067 011e 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2068 0122 07F15801 		add	r1, r7, #88
 2069 0126 0B44     		add	r3, r3, r1
 2070 0128 13F8543C 		ldrb	r3, [r3, #-84]	@ zero_extendqisi2
 2071 012c 9A42     		cmp	r2, r3
 2072 012e 08D0     		beq	.L154
1233:ProgrammingSteps.c ****     		{
1234:ProgrammingSteps.c ****                 /* Set the verification error bit for Flash protection data
1235:ProgrammingSteps.c ****     			   mismatch and return failure */
1236:ProgrammingSteps.c ****                 swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2073              		.loc 1 1236 0
 2074 0130 304B     		ldr	r3, .L162+4
 2075 0132 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2076 0134 43F04003 		orr	r3, r3, #64
 2077 0138 DAB2     		uxtb	r2, r3
 2078 013a 2E4B     		ldr	r3, .L162+4
 2079 013c 1A70     		strb	r2, [r3]
1237:ProgrammingSteps.c ****                 return(FAILURE);
 2080              		.loc 1 1237 0
 2081 013e 0023     		movs	r3, #0
 2082 0140 52E0     		b	.L161
 2083              	.L154:
1230:ProgrammingSteps.c ****     	{
 2084              		.loc 1 1230 0 discriminator 2
 2085 0142 97F85330 		ldrb	r3, [r7, #83]	@ zero_extendqisi2
 2086 0146 0133     		adds	r3, r3, #1
 2087 0148 87F85330 		strb	r3, [r7, #83]
 2088              	.L153:
1230:ProgrammingSteps.c ****     	{
 2089              		.loc 1 1230 0 is_stmt 0 discriminator 1
 2090 014c 97F85320 		ldrb	r2, [r7, #83]	@ zero_extendqisi2
 2091 0150 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 2092 0154 9A42     		cmp	r2, r3
 2093 0156 DBD3     		bcc	.L155
1208:ProgrammingSteps.c ****     {
 2094              		.loc 1 1208 0 is_stmt 1 discriminator 2
 2095 0158 97F85230 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 2096 015c 0133     		adds	r3, r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 60


 2097 015e 87F85230 		strb	r3, [r7, #82]
 2098 0162 7B6D     		ldr	r3, [r7, #84]
 2099 0164 03F58063 		add	r3, r3, #1024
 2100 0168 7B65     		str	r3, [r7, #84]
 2101              	.L148:
1208:ProgrammingSteps.c ****     {
 2102              		.loc 1 1208 0 is_stmt 0 discriminator 1
 2103 016a 97F85220 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 2104 016e 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 2105 0172 9A42     		cmp	r2, r3
 2106 0174 FFF474AF 		bcc	.L156
1238:ProgrammingSteps.c ****             }
1239:ProgrammingSteps.c ****     	}
1240:ProgrammingSteps.c ****     }
1241:ProgrammingSteps.c **** 
1242:ProgrammingSteps.c **** 	/* Read Chip Level Protection from hex-file */
1243:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 2107              		.loc 1 1243 0 is_stmt 1
 2108 0178 07F14703 		add	r3, r7, #71
 2109 017c 1846     		mov	r0, r3
 2110 017e FFF7FEFF 		bl	HEX_ReadChipProtectionData
1244:ProgrammingSteps.c **** 
1245:ProgrammingSteps.c **** 	/* Read Chip Level Protection from the silicon */
1246:ProgrammingSteps.c **** 	Read_IO(SFLASH_CPUSS_PROTECTION, &protectionData);
 2111              		.loc 1 1246 0
 2112 0182 07F14803 		add	r3, r7, #72
 2113 0186 1C48     		ldr	r0, .L162+8
 2114 0188 1946     		mov	r1, r3
 2115 018a FFF7FEFF 		bl	Read_IO
1247:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 2116              		.loc 1 1247 0
 2117 018e 194B     		ldr	r3, .L162+4
 2118 0190 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2119 0192 012B     		cmp	r3, #1
 2120 0194 01D0     		beq	.L157
1248:ProgrammingSteps.c ****     {
1249:ProgrammingSteps.c ****         return (FAILURE);
 2121              		.loc 1 1249 0
 2122 0196 0023     		movs	r3, #0
 2123 0198 26E0     		b	.L161
 2124              	.L157:
1250:ProgrammingSteps.c ****     }
1251:ProgrammingSteps.c **** 	
1252:ProgrammingSteps.c **** 	chipProtectionData_Chip = (protectionData >> 24) & 0x0F;
 2125              		.loc 1 1252 0
 2126 019a BB6C     		ldr	r3, [r7, #72]
 2127 019c 1B0E     		lsrs	r3, r3, #24
 2128 019e DBB2     		uxtb	r3, r3
 2129 01a0 03F00F03 		and	r3, r3, #15
 2130 01a4 DAB2     		uxtb	r2, r3
 2131 01a6 154B     		ldr	r3, .L162+12
 2132 01a8 1A70     		strb	r2, [r3]
1253:ProgrammingSteps.c **** 
1254:ProgrammingSteps.c **** 	if (chipProtectionData_Chip == CHIP_PROT_VIRGIN)
 2133              		.loc 1 1254 0
 2134 01aa 144B     		ldr	r3, .L162+12
 2135 01ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 61


 2136 01ae 002B     		cmp	r3, #0
 2137 01b0 03D1     		bne	.L158
1255:ProgrammingSteps.c **** 	{
1256:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_OPEN;
 2138              		.loc 1 1256 0
 2139 01b2 124B     		ldr	r3, .L162+12
 2140 01b4 0122     		movs	r2, #1
 2141 01b6 1A70     		strb	r2, [r3]
 2142 01b8 06E0     		b	.L159
 2143              	.L158:
1257:ProgrammingSteps.c **** 	}	
1258:ProgrammingSteps.c **** 	else if (chipProtectionData_Chip == CHIP_PROT_OPEN)
 2144              		.loc 1 1258 0
 2145 01ba 104B     		ldr	r3, .L162+12
 2146 01bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2147 01be 012B     		cmp	r3, #1
 2148 01c0 02D1     		bne	.L159
1259:ProgrammingSteps.c **** 	{
1260:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_VIRGIN;
 2149              		.loc 1 1260 0
 2150 01c2 0E4B     		ldr	r3, .L162+12
 2151 01c4 0022     		movs	r2, #0
 2152 01c6 1A70     		strb	r2, [r3]
 2153              	.L159:
1261:ProgrammingSteps.c **** 	}
1262:ProgrammingSteps.c **** 	
1263:ProgrammingSteps.c **** 	/* Compare hex’s and silicon’s chip protection data */
1264:ProgrammingSteps.c **** 	if (chipProtectionData_Chip != chipProtectionData_Hex)
 2154              		.loc 1 1264 0
 2155 01c8 0C4B     		ldr	r3, .L162+12
 2156 01ca 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2157 01cc 97F84730 		ldrb	r3, [r7, #71]	@ zero_extendqisi2
 2158 01d0 9A42     		cmp	r2, r3
 2159 01d2 08D0     		beq	.L160
1265:ProgrammingSteps.c **** 	{
1266:ProgrammingSteps.c ****         /* Set the verification error bit for Flash protection data
1267:ProgrammingSteps.c **** 		   mismatch and return failure */
1268:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2160              		.loc 1 1268 0
 2161 01d4 074B     		ldr	r3, .L162+4
 2162 01d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2163 01d8 43F04003 		orr	r3, r3, #64
 2164 01dc DAB2     		uxtb	r2, r3
 2165 01de 054B     		ldr	r3, .L162+4
 2166 01e0 1A70     		strb	r2, [r3]
1269:ProgrammingSteps.c ****         return(FAILURE);
 2167              		.loc 1 1269 0
 2168 01e2 0023     		movs	r3, #0
 2169 01e4 00E0     		b	.L161
 2170              	.L160:
1270:ProgrammingSteps.c ****     }
1271:ProgrammingSteps.c **** 
1272:ProgrammingSteps.c **** 	return (SUCCESS);
 2171              		.loc 1 1272 0
 2172 01e6 0123     		movs	r3, #1
 2173              	.L161:
1273:ProgrammingSteps.c **** }
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 62


 2174              		.loc 1 1273 0 discriminator 1
 2175 01e8 1846     		mov	r0, r3
 2176 01ea 5837     		adds	r7, r7, #88
 2177              		.cfi_def_cfa_offset 8
 2178 01ec BD46     		mov	sp, r7
 2179              		.cfi_def_cfa_register 13
 2180              		@ sp needed
 2181 01ee 80BD     		pop	{r7, pc}
 2182              	.L163:
 2183              		.align	2
 2184              	.L162:
 2185 01f0 00F0FF0F 		.word	268431360
 2186 01f4 00000000 		.word	swd_PacketAck
 2187 01f8 7CF0FF0F 		.word	268431484
 2188 01fc 00000000 		.word	chipProtectionData_Chip
 2189              		.cfi_endproc
 2190              	.LFE76:
 2191              		.size	VerifyProtectionSettings, .-VerifyProtectionSettings
 2192              		.section	.text.VerifyChecksum,"ax",%progbits
 2193              		.align	2
 2194              		.global	VerifyChecksum
 2195              		.thumb
 2196              		.thumb_func
 2197              		.type	VerifyChecksum, %function
 2198              	VerifyChecksum:
 2199              	.LFB77:
1274:ProgrammingSteps.c **** 
1275:ProgrammingSteps.c **** /******************************************************************************
1276:ProgrammingSteps.c **** * Function Name: VerifyChecksum
1277:ProgrammingSteps.c **** *******************************************************************************
1278:ProgrammingSteps.c **** *
1279:ProgrammingSteps.c **** * Summary:
1280:ProgrammingSteps.c **** *  This is Step 9 of the programming sequence. In this step, Checksum of user
1281:ProgrammingSteps.c **** *  data in flash is verified with the Checksum stored in the HEX File. This step
1282:ProgrammingSteps.c **** *  uses the Checksum of privileged rows calculated in Step 4 get the checksum
1283:ProgrammingSteps.c **** *  of user data in flash.
1284:ProgrammingSteps.c **** *
1285:ProgrammingSteps.c **** * Parameters:
1286:ProgrammingSteps.c **** *  None
1287:ProgrammingSteps.c **** *
1288:ProgrammingSteps.c **** * Return:
1289:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the checksum.
1290:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1291:ProgrammingSteps.c **** *			 message.
1292:ProgrammingSteps.c **** *
1293:ProgrammingSteps.c **** * Note:
1294:ProgrammingSteps.c **** *
1295:ProgrammingSteps.c **** ******************************************************************************/
1296:ProgrammingSteps.c **** unsigned char VerifyChecksum(void)
1297:ProgrammingSteps.c **** {
 2200              		.loc 1 1297 0
 2201              		.cfi_startproc
 2202              		@ args = 0, pretend = 0, frame = 16
 2203              		@ frame_needed = 1, uses_anonymous_args = 0
 2204 0000 80B5     		push	{r7, lr}
 2205              		.cfi_def_cfa_offset 8
 2206              		.cfi_offset 7, -8
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 63


 2207              		.cfi_offset 14, -4
 2208 0002 84B0     		sub	sp, sp, #16
 2209              		.cfi_def_cfa_offset 24
 2210 0004 00AF     		add	r7, sp, #0
 2211              		.cfi_def_cfa_register 7
1298:ProgrammingSteps.c **** 	unsigned long checksum_All 	 = 0;
 2212              		.loc 1 1298 0
 2213 0006 0023     		movs	r3, #0
 2214 0008 BB60     		str	r3, [r7, #8]
1299:ProgrammingSteps.c **** 	unsigned short chip_Checksum = 0;
 2215              		.loc 1 1299 0
 2216 000a 0023     		movs	r3, #0
 2217 000c FB81     		strh	r3, [r7, #14]	@ movhi
1300:ProgrammingSteps.c **** 	unsigned short checksumData  = 0;
 2218              		.loc 1 1300 0
 2219 000e 0023     		movs	r3, #0
 2220 0010 FB80     		strh	r3, [r7, #6]	@ movhi
1301:ProgrammingSteps.c ****     
1302:ProgrammingSteps.c **** 	/* Read the checksum of entire flash */
1303:ProgrammingSteps.c **** 	result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_All);
 2221              		.loc 1 1303 0
 2222 0012 07F10803 		add	r3, r7, #8
 2223 0016 4FF40040 		mov	r0, #32768
 2224 001a 1946     		mov	r1, r3
 2225 001c FFF7FEFF 		bl	ChecksumAPI
 2226 0020 0346     		mov	r3, r0
 2227 0022 1A46     		mov	r2, r3
 2228 0024 124B     		ldr	r3, .L169
 2229 0026 1A70     		strb	r2, [r3]
1304:ProgrammingSteps.c **** 	
1305:ProgrammingSteps.c **** 	if (result != SUCCESS)
 2230              		.loc 1 1305 0
 2231 0028 114B     		ldr	r3, .L169
 2232 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2233 002c 012B     		cmp	r3, #1
 2234 002e 01D0     		beq	.L165
1306:ProgrammingSteps.c **** 	{
1307:ProgrammingSteps.c **** 		return (FAILURE);
 2235              		.loc 1 1307 0
 2236 0030 0023     		movs	r3, #0
 2237 0032 18E0     		b	.L168
 2238              	.L165:
1308:ProgrammingSteps.c **** 	}
1309:ProgrammingSteps.c **** 	
1310:ProgrammingSteps.c **** 	/* Calculate checksum of user flash */
1311:ProgrammingSteps.c ****     chip_Checksum = (unsigned short)checksum_All - (unsigned short)checksum_Privileged;
 2239              		.loc 1 1311 0
 2240 0034 BB68     		ldr	r3, [r7, #8]
 2241 0036 9AB2     		uxth	r2, r3
 2242 0038 0E4B     		ldr	r3, .L169+4
 2243 003a 1B68     		ldr	r3, [r3]
 2244 003c 9BB2     		uxth	r3, r3
 2245 003e D31A     		subs	r3, r2, r3
 2246 0040 FB81     		strh	r3, [r7, #14]	@ movhi
1312:ProgrammingSteps.c **** 	
1313:ProgrammingSteps.c **** 	/* Read checksum from hex file */
1314:ProgrammingSteps.c **** 	HEX_ReadChecksumData(&checksumData);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 64


 2247              		.loc 1 1314 0
 2248 0042 BB1D     		adds	r3, r7, #6
 2249 0044 1846     		mov	r0, r3
 2250 0046 FFF7FEFF 		bl	HEX_ReadChecksumData
1315:ProgrammingSteps.c **** 	
1316:ProgrammingSteps.c **** 	/* Compare the checksum data of silicon and hex file */
1317:ProgrammingSteps.c **** 	if (chip_Checksum != checksumData)
 2251              		.loc 1 1317 0
 2252 004a FB88     		ldrh	r3, [r7, #6]
 2253 004c FA89     		ldrh	r2, [r7, #14]
 2254 004e 9A42     		cmp	r2, r3
 2255 0050 08D0     		beq	.L167
1318:ProgrammingSteps.c ****     {
1319:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 2256              		.loc 1 1319 0
 2257 0052 094B     		ldr	r3, .L169+8
 2258 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2259 0056 43F04003 		orr	r3, r3, #64
 2260 005a DAB2     		uxtb	r2, r3
 2261 005c 064B     		ldr	r3, .L169+8
 2262 005e 1A70     		strb	r2, [r3]
1320:ProgrammingSteps.c **** 		return (FAILURE);
 2263              		.loc 1 1320 0
 2264 0060 0023     		movs	r3, #0
 2265 0062 00E0     		b	.L168
 2266              	.L167:
1321:ProgrammingSteps.c ****     }
1322:ProgrammingSteps.c **** 	
1323:ProgrammingSteps.c **** 	return (SUCCESS);
 2267              		.loc 1 1323 0
 2268 0064 0123     		movs	r3, #1
 2269              	.L168:
1324:ProgrammingSteps.c **** }
 2270              		.loc 1 1324 0 discriminator 1
 2271 0066 1846     		mov	r0, r3
 2272 0068 1037     		adds	r7, r7, #16
 2273              		.cfi_def_cfa_offset 8
 2274 006a BD46     		mov	sp, r7
 2275              		.cfi_def_cfa_register 13
 2276              		@ sp needed
 2277 006c 80BD     		pop	{r7, pc}
 2278              	.L170:
 2279 006e 00BF     		.align	2
 2280              	.L169:
 2281 0070 00000000 		.word	result
 2282 0074 00000000 		.word	checksum_Privileged
 2283 0078 00000000 		.word	swd_PacketAck
 2284              		.cfi_endproc
 2285              	.LFE77:
 2286              		.size	VerifyChecksum, .-VerifyChecksum
 2287              		.section	.text.ReadHsspErrorStatus,"ax",%progbits
 2288              		.align	2
 2289              		.global	ReadHsspErrorStatus
 2290              		.thumb
 2291              		.thumb_func
 2292              		.type	ReadHsspErrorStatus, %function
 2293              	ReadHsspErrorStatus:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 65


 2294              	.LFB78:
1325:ProgrammingSteps.c **** 
1326:ProgrammingSteps.c **** /******************************************************************************
1327:ProgrammingSteps.c **** * Function Name: ReadHsspErrorStatus
1328:ProgrammingSteps.c **** *******************************************************************************
1329:ProgrammingSteps.c **** *
1330:ProgrammingSteps.c **** * Summary:
1331:ProgrammingSteps.c **** *  Returns the HSSP Error status in case of FAILURE return in any one of the
1332:ProgrammingSteps.c **** *  programming steps.
1333:ProgrammingSteps.c **** *
1334:ProgrammingSteps.c **** * Parameters:
1335:ProgrammingSteps.c **** *  None.
1336:ProgrammingSteps.c **** *
1337:ProgrammingSteps.c **** * Return:
1338:ProgrammingSteps.c **** *  swd_PacketAck - Each bit of this 8-bit return value has a specific meaning.
1339:ProgrammingSteps.c **** *
1340:ProgrammingSteps.c **** * Note:
1341:ProgrammingSteps.c **** *  Refer to the application note pdf for details on the Error status bit
1342:ProgrammingSteps.c **** *  definitions
1343:ProgrammingSteps.c **** ******************************************************************************/
1344:ProgrammingSteps.c **** unsigned char ReadHsspErrorStatus()
1345:ProgrammingSteps.c **** {
 2295              		.loc 1 1345 0
 2296              		.cfi_startproc
 2297              		@ args = 0, pretend = 0, frame = 0
 2298              		@ frame_needed = 1, uses_anonymous_args = 0
 2299              		@ link register save eliminated.
 2300 0000 80B4     		push	{r7}
 2301              		.cfi_def_cfa_offset 4
 2302              		.cfi_offset 7, -4
 2303 0002 00AF     		add	r7, sp, #0
 2304              		.cfi_def_cfa_register 7
1346:ProgrammingSteps.c ****     return(swd_PacketAck);
 2305              		.loc 1 1346 0
 2306 0004 034B     		ldr	r3, .L173
 2307 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
1347:ProgrammingSteps.c **** }
 2308              		.loc 1 1347 0
 2309 0008 1846     		mov	r0, r3
 2310 000a BD46     		mov	sp, r7
 2311              		.cfi_def_cfa_register 13
 2312              		@ sp needed
 2313 000c 5DF8047B 		ldr	r7, [sp], #4
 2314              		.cfi_restore 7
 2315              		.cfi_def_cfa_offset 0
 2316 0010 7047     		bx	lr
 2317              	.L174:
 2318 0012 00BF     		.align	2
 2319              	.L173:
 2320 0014 00000000 		.word	swd_PacketAck
 2321              		.cfi_endproc
 2322              	.LFE78:
 2323              		.size	ReadHsspErrorStatus, .-ReadHsspErrorStatus
 2324              		.section	.text.ExitProgrammingMode,"ax",%progbits
 2325              		.align	2
 2326              		.global	ExitProgrammingMode
 2327              		.thumb
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 66


 2328              		.thumb_func
 2329              		.type	ExitProgrammingMode, %function
 2330              	ExitProgrammingMode:
 2331              	.LFB79:
1348:ProgrammingSteps.c **** /******************************************************************************
1349:ProgrammingSteps.c **** * Function Name: ExitProgrammingMode
1350:ProgrammingSteps.c **** *******************************************************************************
1351:ProgrammingSteps.c **** *
1352:ProgrammingSteps.c **** * Summary:
1353:ProgrammingSteps.c **** *  Releases the target PSoC 4 device from Programming mode.
1354:ProgrammingSteps.c **** *
1355:ProgrammingSteps.c **** * Parameters:
1356:ProgrammingSteps.c **** *  None.
1357:ProgrammingSteps.c **** *
1358:ProgrammingSteps.c **** * Return:
1359:ProgrammingSteps.c **** *  None.
1360:ProgrammingSteps.c **** *
1361:ProgrammingSteps.c **** * Note:
1362:ProgrammingSteps.c **** *
1363:ProgrammingSteps.c **** ******************************************************************************/
1364:ProgrammingSteps.c **** void ExitProgrammingMode()
1365:ProgrammingSteps.c **** {
 2332              		.loc 1 1365 0
 2333              		.cfi_startproc
 2334              		@ args = 0, pretend = 0, frame = 0
 2335              		@ frame_needed = 1, uses_anonymous_args = 0
 2336 0000 80B5     		push	{r7, lr}
 2337              		.cfi_def_cfa_offset 8
 2338              		.cfi_offset 7, -8
 2339              		.cfi_offset 14, -4
 2340 0002 00AF     		add	r7, sp, #0
 2341              		.cfi_def_cfa_register 7
1366:ProgrammingSteps.c ****     /* Drive the SWDIO, SWDCK outputs low */
1367:ProgrammingSteps.c ****     SetSwdckLow();
 2342              		.loc 1 1367 0
 2343 0004 FFF7FEFF 		bl	SetSwdckLow
1368:ProgrammingSteps.c ****     SetSwdioLow();
 2344              		.loc 1 1368 0
 2345 0008 FFF7FEFF 		bl	SetSwdioLow
1369:ProgrammingSteps.c ****     
1370:ProgrammingSteps.c ****     /* Make SWDIO, SWDCK High-Z after completing Programming */    
1371:ProgrammingSteps.c ****     SetSwdioHizInput();
 2346              		.loc 1 1371 0
 2347 000c FFF7FEFF 		bl	SetSwdioHizInput
1372:ProgrammingSteps.c ****     SetSwdckHizInput();
 2348              		.loc 1 1372 0
 2349 0010 FFF7FEFF 		bl	SetSwdckHizInput
1373:ProgrammingSteps.c ****     
1374:ProgrammingSteps.c ****     /* Generate active low rest pulse for 100 uS */
1375:ProgrammingSteps.c ****     SetXresLow();
 2350              		.loc 1 1375 0
 2351 0014 FFF7FEFF 		bl	SetXresLow
1376:ProgrammingSteps.c ****     DelayHundredUs();    
 2352              		.loc 1 1376 0
 2353 0018 FFF7FEFF 		bl	DelayHundredUs
1377:ProgrammingSteps.c ****     SetXresHigh();
 2354              		.loc 1 1377 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 67


 2355 001c FFF7FEFF 		bl	SetXresHigh
1378:ProgrammingSteps.c **** 
1379:ProgrammingSteps.c ****     /* Make XRES High-Z after generating the reset pulse */  
1380:ProgrammingSteps.c ****     SetXresHizInput();
 2356              		.loc 1 1380 0
 2357 0020 FFF7FEFF 		bl	SetXresHizInput
1381:ProgrammingSteps.c **** }
 2358              		.loc 1 1381 0
 2359 0024 80BD     		pop	{r7, pc}
 2360              		.cfi_endproc
 2361              	.LFE79:
 2362              		.size	ExitProgrammingMode, .-ExitProgrammingMode
 2363 0026 00BF     		.text
 2364              	.Letext0:
 2365              		.file 2 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2366              		.file 3 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2367              		.file 4 "SWD_PacketLayer.h"
 2368              		.file 5 "Generated_Source\\PSoC5/core_cm3.h"
 2369              		.section	.debug_info,"",%progbits
 2370              	.Ldebug_info0:
 2371 0000 4D060000 		.4byte	0x64d
 2372 0004 0400     		.2byte	0x4
 2373 0006 00000000 		.4byte	.Ldebug_abbrev0
 2374 000a 04       		.byte	0x4
 2375 000b 01       		.uleb128 0x1
 2376 000c B9010000 		.4byte	.LASF74
 2377 0010 01       		.byte	0x1
 2378 0011 DD000000 		.4byte	.LASF75
 2379 0015 9E020000 		.4byte	.LASF76
 2380 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2381 001d 00000000 		.4byte	0
 2382 0021 00000000 		.4byte	.Ldebug_line0
 2383 0025 02       		.uleb128 0x2
 2384 0026 01       		.byte	0x1
 2385 0027 06       		.byte	0x6
 2386 0028 6E010000 		.4byte	.LASF0
 2387 002c 02       		.uleb128 0x2
 2388 002d 01       		.byte	0x1
 2389 002e 08       		.byte	0x8
 2390 002f 21030000 		.4byte	.LASF1
 2391 0033 02       		.uleb128 0x2
 2392 0034 02       		.byte	0x2
 2393 0035 05       		.byte	0x5
 2394 0036 9C000000 		.4byte	.LASF2
 2395 003a 02       		.uleb128 0x2
 2396 003b 02       		.byte	0x2
 2397 003c 07       		.byte	0x7
 2398 003d C4030000 		.4byte	.LASF3
 2399 0041 03       		.uleb128 0x3
 2400 0042 8E040000 		.4byte	.LASF9
 2401 0046 02       		.byte	0x2
 2402 0047 3F       		.byte	0x3f
 2403 0048 4C000000 		.4byte	0x4c
 2404 004c 02       		.uleb128 0x2
 2405 004d 04       		.byte	0x4
 2406 004e 05       		.byte	0x5
 2407 004f 00040000 		.4byte	.LASF4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 68


 2408 0053 02       		.uleb128 0x2
 2409 0054 04       		.byte	0x4
 2410 0055 07       		.byte	0x7
 2411 0056 35040000 		.4byte	.LASF5
 2412 005a 02       		.uleb128 0x2
 2413 005b 08       		.byte	0x8
 2414 005c 05       		.byte	0x5
 2415 005d F0000000 		.4byte	.LASF6
 2416 0061 02       		.uleb128 0x2
 2417 0062 08       		.byte	0x8
 2418 0063 07       		.byte	0x7
 2419 0064 73030000 		.4byte	.LASF7
 2420 0068 04       		.uleb128 0x4
 2421 0069 04       		.byte	0x4
 2422 006a 05       		.byte	0x5
 2423 006b 696E7400 		.ascii	"int\000"
 2424 006f 02       		.uleb128 0x2
 2425 0070 04       		.byte	0x4
 2426 0071 07       		.byte	0x7
 2427 0072 9D030000 		.4byte	.LASF8
 2428 0076 03       		.uleb128 0x3
 2429 0077 13040000 		.4byte	.LASF10
 2430 007b 03       		.byte	0x3
 2431 007c 2C       		.byte	0x2c
 2432 007d 41000000 		.4byte	0x41
 2433 0081 02       		.uleb128 0x2
 2434 0082 04       		.byte	0x4
 2435 0083 04       		.byte	0x4
 2436 0084 7A010000 		.4byte	.LASF11
 2437 0088 02       		.uleb128 0x2
 2438 0089 08       		.byte	0x8
 2439 008a 04       		.byte	0x4
 2440 008b 53040000 		.4byte	.LASF12
 2441 008f 02       		.uleb128 0x2
 2442 0090 01       		.byte	0x1
 2443 0091 08       		.byte	0x8
 2444 0092 EC030000 		.4byte	.LASF13
 2445 0096 02       		.uleb128 0x2
 2446 0097 04       		.byte	0x4
 2447 0098 07       		.byte	0x7
 2448 0099 B6000000 		.4byte	.LASF14
 2449 009d 05       		.uleb128 0x5
 2450 009e 04       		.byte	0x4
 2451 009f 2C000000 		.4byte	0x2c
 2452 00a3 06       		.uleb128 0x6
 2453 00a4 A4040000 		.4byte	.LASF77
 2454 00a8 01       		.byte	0x1
 2455 00a9 01       		.byte	0x1
 2456 00aa 48       		.byte	0x48
 2457 00ab C8000000 		.4byte	0xc8
 2458 00af 07       		.uleb128 0x7
 2459 00b0 60020000 		.4byte	.LASF15
 2460 00b4 00       		.sleb128 0
 2461 00b5 07       		.uleb128 0x7
 2462 00b6 98040000 		.4byte	.LASF16
 2463 00ba 01       		.sleb128 1
 2464 00bb 07       		.uleb128 0x7
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 69


 2465 00bc B4040000 		.4byte	.LASF17
 2466 00c0 02       		.sleb128 2
 2467 00c1 07       		.uleb128 0x7
 2468 00c2 00000000 		.4byte	.LASF18
 2469 00c6 03       		.sleb128 3
 2470 00c7 00       		.byte	0
 2471 00c8 08       		.uleb128 0x8
 2472 00c9 AA030000 		.4byte	.LASF19
 2473 00cd 01       		.byte	0x1
 2474 00ce 68       		.byte	0x68
 2475 00cf 2C000000 		.4byte	0x2c
 2476 00d3 00000000 		.4byte	.LFB63
 2477 00d7 9C000000 		.4byte	.LFE63-.LFB63
 2478 00db 01       		.uleb128 0x1
 2479 00dc 9C       		.byte	0x9c
 2480 00dd F0000000 		.4byte	0xf0
 2481 00e1 09       		.uleb128 0x9
 2482 00e2 AC010000 		.4byte	.LASF21
 2483 00e6 01       		.byte	0x1
 2484 00e7 6A       		.byte	0x6a
 2485 00e8 53000000 		.4byte	0x53
 2486 00ec 02       		.uleb128 0x2
 2487 00ed 91       		.byte	0x91
 2488 00ee 74       		.sleb128 -12
 2489 00ef 00       		.byte	0
 2490 00f0 0A       		.uleb128 0xa
 2491 00f1 2F030000 		.4byte	.LASF45
 2492 00f5 01       		.byte	0x1
 2493 00f6 C5       		.byte	0xc5
 2494 00f7 2C000000 		.4byte	0x2c
 2495 00fb 00000000 		.4byte	.LFB64
 2496 00ff 18000000 		.4byte	.LFE64-.LFB64
 2497 0103 01       		.uleb128 0x1
 2498 0104 9C       		.byte	0x9c
 2499 0105 08       		.uleb128 0x8
 2500 0106 DC040000 		.4byte	.LASF20
 2501 010a 01       		.byte	0x1
 2502 010b DF       		.byte	0xdf
 2503 010c 2C000000 		.4byte	0x2c
 2504 0110 00000000 		.4byte	.LFB65
 2505 0114 94000000 		.4byte	.LFE65-.LFB65
 2506 0118 01       		.uleb128 0x1
 2507 0119 9C       		.byte	0x9c
 2508 011a 3B010000 		.4byte	0x13b
 2509 011e 09       		.uleb128 0x9
 2510 011f 0A010000 		.4byte	.LASF22
 2511 0123 01       		.byte	0x1
 2512 0124 E1       		.byte	0xe1
 2513 0125 53000000 		.4byte	0x53
 2514 0129 02       		.uleb128 0x2
 2515 012a 91       		.byte	0x91
 2516 012b 74       		.sleb128 -12
 2517 012c 09       		.uleb128 0x9
 2518 012d 9F010000 		.4byte	.LASF23
 2519 0131 01       		.byte	0x1
 2520 0132 E2       		.byte	0xe2
 2521 0133 53000000 		.4byte	0x53
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 70


 2522 0137 02       		.uleb128 0x2
 2523 0138 91       		.byte	0x91
 2524 0139 70       		.sleb128 -16
 2525 013a 00       		.byte	0
 2526 013b 0B       		.uleb128 0xb
 2527 013c CB000000 		.4byte	.LASF24
 2528 0140 01       		.byte	0x1
 2529 0141 2601     		.2byte	0x126
 2530 0143 2C000000 		.4byte	0x2c
 2531 0147 00000000 		.4byte	.LFB66
 2532 014b A4000000 		.4byte	.LFE66-.LFB66
 2533 014f 01       		.uleb128 0x1
 2534 0150 9C       		.byte	0x9c
 2535 0151 65010000 		.4byte	0x165
 2536 0155 0C       		.uleb128 0xc
 2537 0156 6E040000 		.4byte	.LASF25
 2538 015a 01       		.byte	0x1
 2539 015b 2801     		.2byte	0x128
 2540 015d 2C000000 		.4byte	0x2c
 2541 0161 02       		.uleb128 0x2
 2542 0162 91       		.byte	0x91
 2543 0163 77       		.sleb128 -9
 2544 0164 00       		.byte	0
 2545 0165 0B       		.uleb128 0xb
 2546 0166 09040000 		.4byte	.LASF26
 2547 016a 01       		.byte	0x1
 2548 016b 7501     		.2byte	0x175
 2549 016d 2C000000 		.4byte	0x2c
 2550 0171 00000000 		.4byte	.LFB67
 2551 0175 24010000 		.4byte	.LFE67-.LFB67
 2552 0179 01       		.uleb128 0x1
 2553 017a 9C       		.byte	0x9c
 2554 017b D8010000 		.4byte	0x1d8
 2555 017f 0D       		.uleb128 0xd
 2556 0180 2D040000 		.4byte	.LASF27
 2557 0184 01       		.byte	0x1
 2558 0185 7501     		.2byte	0x175
 2559 0187 2C000000 		.4byte	0x2c
 2560 018b 02       		.uleb128 0x2
 2561 018c 91       		.byte	0x91
 2562 018d 67       		.sleb128 -25
 2563 018e 0D       		.uleb128 0xd
 2564 018f 87000000 		.4byte	.LASF28
 2565 0193 01       		.byte	0x1
 2566 0194 7501     		.2byte	0x175
 2567 0196 9D000000 		.4byte	0x9d
 2568 019a 02       		.uleb128 0x2
 2569 019b 91       		.byte	0x91
 2570 019c 60       		.sleb128 -32
 2571 019d 0D       		.uleb128 0xd
 2572 019e 41010000 		.4byte	.LASF29
 2573 01a2 01       		.byte	0x1
 2574 01a3 7501     		.2byte	0x175
 2575 01a5 3A000000 		.4byte	0x3a
 2576 01a9 02       		.uleb128 0x2
 2577 01aa 91       		.byte	0x91
 2578 01ab 64       		.sleb128 -28
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 71


 2579 01ac 0C       		.uleb128 0xc
 2580 01ad 0A010000 		.4byte	.LASF22
 2581 01b1 01       		.byte	0x1
 2582 01b2 7701     		.2byte	0x177
 2583 01b4 53000000 		.4byte	0x53
 2584 01b8 02       		.uleb128 0x2
 2585 01b9 91       		.byte	0x91
 2586 01ba 70       		.sleb128 -16
 2587 01bb 0C       		.uleb128 0xc
 2588 01bc 15010000 		.4byte	.LASF30
 2589 01c0 01       		.byte	0x1
 2590 01c1 7801     		.2byte	0x178
 2591 01c3 53000000 		.4byte	0x53
 2592 01c7 02       		.uleb128 0x2
 2593 01c8 91       		.byte	0x91
 2594 01c9 6C       		.sleb128 -20
 2595 01ca 0E       		.uleb128 0xe
 2596 01cb 6900     		.ascii	"i\000"
 2597 01cd 01       		.byte	0x1
 2598 01ce 7901     		.2byte	0x179
 2599 01d0 3A000000 		.4byte	0x3a
 2600 01d4 02       		.uleb128 0x2
 2601 01d5 91       		.byte	0x91
 2602 01d6 76       		.sleb128 -10
 2603 01d7 00       		.byte	0
 2604 01d8 0B       		.uleb128 0xb
 2605 01d9 47040000 		.4byte	.LASF31
 2606 01dd 01       		.byte	0x1
 2607 01de DD01     		.2byte	0x1dd
 2608 01e0 2C000000 		.4byte	0x2c
 2609 01e4 00000000 		.4byte	.LFB68
 2610 01e8 AC000000 		.4byte	.LFE68-.LFB68
 2611 01ec 01       		.uleb128 0x1
 2612 01ed 9C       		.byte	0x9c
 2613 01ee 2F020000 		.4byte	0x22f
 2614 01f2 0D       		.uleb128 0xd
 2615 01f3 FE000000 		.4byte	.LASF32
 2616 01f7 01       		.byte	0x1
 2617 01f8 DD01     		.2byte	0x1dd
 2618 01fa 3A000000 		.4byte	0x3a
 2619 01fe 02       		.uleb128 0x2
 2620 01ff 91       		.byte	0x91
 2621 0200 6E       		.sleb128 -18
 2622 0201 0D       		.uleb128 0xd
 2623 0202 38010000 		.4byte	.LASF33
 2624 0206 01       		.byte	0x1
 2625 0207 DD01     		.2byte	0x1dd
 2626 0209 2F020000 		.4byte	0x22f
 2627 020d 02       		.uleb128 0x2
 2628 020e 91       		.byte	0x91
 2629 020f 68       		.sleb128 -24
 2630 0210 0C       		.uleb128 0xc
 2631 0211 0A010000 		.4byte	.LASF22
 2632 0215 01       		.byte	0x1
 2633 0216 DF01     		.2byte	0x1df
 2634 0218 53000000 		.4byte	0x53
 2635 021c 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 72


 2636 021d 91       		.byte	0x91
 2637 021e 74       		.sleb128 -12
 2638 021f 0C       		.uleb128 0xc
 2639 0220 DE030000 		.4byte	.LASF34
 2640 0224 01       		.byte	0x1
 2641 0225 E001     		.2byte	0x1e0
 2642 0227 53000000 		.4byte	0x53
 2643 022b 02       		.uleb128 0x2
 2644 022c 91       		.byte	0x91
 2645 022d 70       		.sleb128 -16
 2646 022e 00       		.byte	0
 2647 022f 05       		.uleb128 0x5
 2648 0230 04       		.byte	0x4
 2649 0231 53000000 		.4byte	0x53
 2650 0235 0B       		.uleb128 0xb
 2651 0236 11000000 		.4byte	.LASF35
 2652 023a 01       		.byte	0x1
 2653 023b 2702     		.2byte	0x227
 2654 023d 2C000000 		.4byte	0x2c
 2655 0241 00000000 		.4byte	.LFB69
 2656 0245 34010000 		.4byte	.LFE69-.LFB69
 2657 0249 01       		.uleb128 0x1
 2658 024a 9C       		.byte	0x9c
 2659 024b 7D020000 		.4byte	0x27d
 2660 024f 0C       		.uleb128 0xc
 2661 0250 BF000000 		.4byte	.LASF36
 2662 0254 01       		.byte	0x1
 2663 0255 2902     		.2byte	0x229
 2664 0257 53000000 		.4byte	0x53
 2665 025b 02       		.uleb128 0x2
 2666 025c 91       		.byte	0x91
 2667 025d 70       		.sleb128 -16
 2668 025e 0C       		.uleb128 0xc
 2669 025f 3E030000 		.4byte	.LASF37
 2670 0263 01       		.byte	0x1
 2671 0264 2A02     		.2byte	0x22a
 2672 0266 3A000000 		.4byte	0x3a
 2673 026a 02       		.uleb128 0x2
 2674 026b 91       		.byte	0x91
 2675 026c 76       		.sleb128 -10
 2676 026d 0C       		.uleb128 0xc
 2677 026e D7030000 		.4byte	.LASF38
 2678 0272 01       		.byte	0x1
 2679 0273 2B02     		.2byte	0x22b
 2680 0275 53000000 		.4byte	0x53
 2681 0279 02       		.uleb128 0x2
 2682 027a 91       		.byte	0x91
 2683 027b 6C       		.sleb128 -20
 2684 027c 00       		.byte	0
 2685 027d 0B       		.uleb128 0xb
 2686 027e 8F010000 		.4byte	.LASF39
 2687 0282 01       		.byte	0x1
 2688 0283 B302     		.2byte	0x2b3
 2689 0285 2C000000 		.4byte	0x2c
 2690 0289 00000000 		.4byte	.LFB70
 2691 028d 00010000 		.4byte	.LFE70-.LFB70
 2692 0291 01       		.uleb128 0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 73


 2693 0292 9C       		.byte	0x9c
 2694 0293 F0020000 		.4byte	0x2f0
 2695 0297 0E       		.uleb128 0xe
 2696 0298 6900     		.ascii	"i\000"
 2697 029a 01       		.byte	0x1
 2698 029b B502     		.2byte	0x2b5
 2699 029d 2C000000 		.4byte	0x2c
 2700 02a1 02       		.uleb128 0x2
 2701 02a2 91       		.byte	0x91
 2702 02a3 77       		.sleb128 -9
 2703 02a4 0C       		.uleb128 0xc
 2704 02a5 A6000000 		.4byte	.LASF40
 2705 02a9 01       		.byte	0x1
 2706 02aa B602     		.2byte	0x2b6
 2707 02ac 53000000 		.4byte	0x53
 2708 02b0 02       		.uleb128 0x2
 2709 02b1 91       		.byte	0x91
 2710 02b2 6C       		.sleb128 -20
 2711 02b3 0C       		.uleb128 0xc
 2712 02b4 CF040000 		.4byte	.LASF41
 2713 02b8 01       		.byte	0x1
 2714 02b9 B702     		.2byte	0x2b7
 2715 02bb 53000000 		.4byte	0x53
 2716 02bf 02       		.uleb128 0x2
 2717 02c0 91       		.byte	0x91
 2718 02c1 68       		.sleb128 -24
 2719 02c2 0C       		.uleb128 0xc
 2720 02c3 0A010000 		.4byte	.LASF22
 2721 02c7 01       		.byte	0x1
 2722 02c8 B902     		.2byte	0x2b9
 2723 02ca 53000000 		.4byte	0x53
 2724 02ce 02       		.uleb128 0x2
 2725 02cf 91       		.byte	0x91
 2726 02d0 70       		.sleb128 -16
 2727 02d1 0C       		.uleb128 0xc
 2728 02d2 5E000000 		.4byte	.LASF42
 2729 02d6 01       		.byte	0x1
 2730 02d7 BA02     		.2byte	0x2ba
 2731 02d9 53000000 		.4byte	0x53
 2732 02dd 02       		.uleb128 0x2
 2733 02de 91       		.byte	0x91
 2734 02df 64       		.sleb128 -28
 2735 02e0 0C       		.uleb128 0xc
 2736 02e1 6D000000 		.4byte	.LASF43
 2737 02e5 01       		.byte	0x1
 2738 02e6 BB02     		.2byte	0x2bb
 2739 02e8 53000000 		.4byte	0x53
 2740 02ec 02       		.uleb128 0x2
 2741 02ed 91       		.byte	0x91
 2742 02ee 60       		.sleb128 -32
 2743 02ef 00       		.byte	0
 2744 02f0 0B       		.uleb128 0xb
 2745 02f1 1F000000 		.4byte	.LASF44
 2746 02f5 01       		.byte	0x1
 2747 02f6 1303     		.2byte	0x313
 2748 02f8 2C000000 		.4byte	0x2c
 2749 02fc 00000000 		.4byte	.LFB71
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 74


 2750 0300 24010000 		.4byte	.LFE71-.LFB71
 2751 0304 01       		.uleb128 0x1
 2752 0305 9C       		.byte	0x9c
 2753 0306 1A030000 		.4byte	0x31a
 2754 030a 0C       		.uleb128 0xc
 2755 030b 0A010000 		.4byte	.LASF22
 2756 030f 01       		.byte	0x1
 2757 0310 1503     		.2byte	0x315
 2758 0312 53000000 		.4byte	0x53
 2759 0316 02       		.uleb128 0x2
 2760 0317 91       		.byte	0x91
 2761 0318 74       		.sleb128 -12
 2762 0319 00       		.byte	0
 2763 031a 0F       		.uleb128 0xf
 2764 031b 8A030000 		.4byte	.LASF46
 2765 031f 01       		.byte	0x1
 2766 0320 8603     		.2byte	0x386
 2767 0322 2C000000 		.4byte	0x2c
 2768 0326 00000000 		.4byte	.LFB72
 2769 032a 30000000 		.4byte	.LFE72-.LFB72
 2770 032e 01       		.uleb128 0x1
 2771 032f 9C       		.byte	0x9c
 2772 0330 0B       		.uleb128 0xb
 2773 0331 4D010000 		.4byte	.LASF47
 2774 0335 01       		.byte	0x1
 2775 0336 A703     		.2byte	0x3a7
 2776 0338 2C000000 		.4byte	0x2c
 2777 033c 00000000 		.4byte	.LFB73
 2778 0340 1C010000 		.4byte	.LFE73-.LFB73
 2779 0344 01       		.uleb128 0x1
 2780 0345 9C       		.byte	0x9c
 2781 0346 97030000 		.4byte	0x397
 2782 034a 0C       		.uleb128 0xc
 2783 034b 2D040000 		.4byte	.LASF27
 2784 034f 01       		.byte	0x1
 2785 0350 A903     		.2byte	0x3a9
 2786 0352 2C000000 		.4byte	0x2c
 2787 0356 02       		.uleb128 0x2
 2788 0357 91       		.byte	0x91
 2789 0358 75       		.sleb128 -11
 2790 0359 0C       		.uleb128 0xc
 2791 035a 87000000 		.4byte	.LASF28
 2792 035e 01       		.byte	0x1
 2793 035f AA03     		.2byte	0x3aa
 2794 0361 97030000 		.4byte	0x397
 2795 0365 03       		.uleb128 0x3
 2796 0366 91       		.byte	0x91
 2797 0367 EC7E     		.sleb128 -148
 2798 0369 0C       		.uleb128 0xc
 2799 036a 29050000 		.4byte	.LASF48
 2800 036e 01       		.byte	0x1
 2801 036f AC03     		.2byte	0x3ac
 2802 0371 3A000000 		.4byte	0x3a
 2803 0375 02       		.uleb128 0x2
 2804 0376 91       		.byte	0x91
 2805 0377 72       		.sleb128 -14
 2806 0378 0C       		.uleb128 0xc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 75


 2807 0379 85040000 		.4byte	.LASF49
 2808 037d 01       		.byte	0x1
 2809 037e AD03     		.2byte	0x3ad
 2810 0380 3A000000 		.4byte	0x3a
 2811 0384 02       		.uleb128 0x2
 2812 0385 91       		.byte	0x91
 2813 0386 76       		.sleb128 -10
 2814 0387 0C       		.uleb128 0xc
 2815 0388 0A010000 		.4byte	.LASF22
 2816 038c 01       		.byte	0x1
 2817 038d AF03     		.2byte	0x3af
 2818 038f 53000000 		.4byte	0x53
 2819 0393 02       		.uleb128 0x2
 2820 0394 91       		.byte	0x91
 2821 0395 6C       		.sleb128 -20
 2822 0396 00       		.byte	0
 2823 0397 10       		.uleb128 0x10
 2824 0398 2C000000 		.4byte	0x2c
 2825 039c A7030000 		.4byte	0x3a7
 2826 03a0 11       		.uleb128 0x11
 2827 03a1 96000000 		.4byte	0x96
 2828 03a5 7F       		.byte	0x7f
 2829 03a6 00       		.byte	0
 2830 03a7 0B       		.uleb128 0xb
 2831 03a8 67030000 		.4byte	.LASF50
 2832 03ac 01       		.byte	0x1
 2833 03ad FD03     		.2byte	0x3fd
 2834 03af 2C000000 		.4byte	0x2c
 2835 03b3 00000000 		.4byte	.LFB74
 2836 03b7 30010000 		.4byte	.LFE74-.LFB74
 2837 03bb 01       		.uleb128 0x1
 2838 03bc 9C       		.byte	0x9c
 2839 03bd 2B040000 		.4byte	0x42b
 2840 03c1 0C       		.uleb128 0xc
 2841 03c2 17030000 		.4byte	.LASF51
 2842 03c6 01       		.byte	0x1
 2843 03c7 FF03     		.2byte	0x3ff
 2844 03c9 53000000 		.4byte	0x53
 2845 03cd 02       		.uleb128 0x2
 2846 03ce 91       		.byte	0x91
 2847 03cf 68       		.sleb128 -24
 2848 03d0 0C       		.uleb128 0xc
 2849 03d1 29050000 		.4byte	.LASF48
 2850 03d5 01       		.byte	0x1
 2851 03d6 0004     		.2byte	0x400
 2852 03d8 3A000000 		.4byte	0x3a
 2853 03dc 02       		.uleb128 0x2
 2854 03dd 91       		.byte	0x91
 2855 03de 72       		.sleb128 -14
 2856 03df 0C       		.uleb128 0xc
 2857 03e0 7C000000 		.4byte	.LASF52
 2858 03e4 01       		.byte	0x1
 2859 03e5 0104     		.2byte	0x401
 2860 03e7 53000000 		.4byte	0x53
 2861 03eb 02       		.uleb128 0x2
 2862 03ec 91       		.byte	0x91
 2863 03ed 6C       		.sleb128 -20
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 76


 2864 03ee 0C       		.uleb128 0xc
 2865 03ef 85040000 		.4byte	.LASF49
 2866 03f3 01       		.byte	0x1
 2867 03f4 0204     		.2byte	0x402
 2868 03f6 3A000000 		.4byte	0x3a
 2869 03fa 02       		.uleb128 0x2
 2870 03fb 91       		.byte	0x91
 2871 03fc 76       		.sleb128 -10
 2872 03fd 0E       		.uleb128 0xe
 2873 03fe 6900     		.ascii	"i\000"
 2874 0400 01       		.byte	0x1
 2875 0401 0304     		.2byte	0x403
 2876 0403 3A000000 		.4byte	0x3a
 2877 0407 02       		.uleb128 0x2
 2878 0408 91       		.byte	0x91
 2879 0409 74       		.sleb128 -12
 2880 040a 0C       		.uleb128 0xc
 2881 040b 87000000 		.4byte	.LASF28
 2882 040f 01       		.byte	0x1
 2883 0410 0404     		.2byte	0x404
 2884 0412 97030000 		.4byte	0x397
 2885 0416 03       		.uleb128 0x3
 2886 0417 91       		.byte	0x91
 2887 0418 E87E     		.sleb128 -152
 2888 041a 0C       		.uleb128 0xc
 2889 041b 95020000 		.4byte	.LASF53
 2890 041f 01       		.byte	0x1
 2891 0420 0504     		.2byte	0x405
 2892 0422 97030000 		.4byte	0x397
 2893 0426 03       		.uleb128 0x3
 2894 0427 91       		.byte	0x91
 2895 0428 E87D     		.sleb128 -280
 2896 042a 00       		.byte	0
 2897 042b 0B       		.uleb128 0xb
 2898 042c 44000000 		.4byte	.LASF54
 2899 0430 01       		.byte	0x1
 2900 0431 4804     		.2byte	0x448
 2901 0433 2C000000 		.4byte	0x2c
 2902 0437 00000000 		.4byte	.LFB75
 2903 043b 18010000 		.4byte	.LFE75-.LFB75
 2904 043f 01       		.uleb128 0x1
 2905 0440 9C       		.byte	0x9c
 2906 0441 AF040000 		.4byte	0x4af
 2907 0445 0C       		.uleb128 0xc
 2908 0446 2D040000 		.4byte	.LASF27
 2909 044a 01       		.byte	0x1
 2910 044b 4A04     		.2byte	0x44a
 2911 044d 2C000000 		.4byte	0x2c
 2912 0451 02       		.uleb128 0x2
 2913 0452 91       		.byte	0x91
 2914 0453 77       		.sleb128 -9
 2915 0454 0C       		.uleb128 0xc
 2916 0455 FF040000 		.4byte	.LASF55
 2917 0459 01       		.byte	0x1
 2918 045a 4B04     		.2byte	0x44b
 2919 045c 2C000000 		.4byte	0x2c
 2920 0460 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 77


 2921 0461 91       		.byte	0x91
 2922 0462 76       		.sleb128 -10
 2923 0463 0C       		.uleb128 0xc
 2924 0464 51030000 		.4byte	.LASF56
 2925 0468 01       		.byte	0x1
 2926 0469 4C04     		.2byte	0x44c
 2927 046b 2C000000 		.4byte	0x2c
 2928 046f 02       		.uleb128 0x2
 2929 0470 91       		.byte	0x91
 2930 0471 75       		.sleb128 -11
 2931 0472 0C       		.uleb128 0xc
 2932 0473 BD040000 		.4byte	.LASF57
 2933 0477 01       		.byte	0x1
 2934 0478 4D04     		.2byte	0x44d
 2935 047a AF040000 		.4byte	0x4af
 2936 047e 02       		.uleb128 0x2
 2937 047f 91       		.byte	0x91
 2938 0480 4C       		.sleb128 -52
 2939 0481 0C       		.uleb128 0xc
 2940 0482 6E040000 		.4byte	.LASF25
 2941 0486 01       		.byte	0x1
 2942 0487 4E04     		.2byte	0x44e
 2943 0489 2C000000 		.4byte	0x2c
 2944 048d 02       		.uleb128 0x2
 2945 048e 91       		.byte	0x91
 2946 048f 4B       		.sleb128 -53
 2947 0490 0C       		.uleb128 0xc
 2948 0491 29050000 		.4byte	.LASF48
 2949 0495 01       		.byte	0x1
 2950 0496 5004     		.2byte	0x450
 2951 0498 3A000000 		.4byte	0x3a
 2952 049c 02       		.uleb128 0x2
 2953 049d 91       		.byte	0x91
 2954 049e 72       		.sleb128 -14
 2955 049f 0C       		.uleb128 0xc
 2956 04a0 0A010000 		.4byte	.LASF22
 2957 04a4 01       		.byte	0x1
 2958 04a5 5204     		.2byte	0x452
 2959 04a7 53000000 		.4byte	0x53
 2960 04ab 02       		.uleb128 0x2
 2961 04ac 91       		.byte	0x91
 2962 04ad 6C       		.sleb128 -20
 2963 04ae 00       		.byte	0
 2964 04af 10       		.uleb128 0x10
 2965 04b0 2C000000 		.4byte	0x2c
 2966 04b4 BF040000 		.4byte	0x4bf
 2967 04b8 11       		.uleb128 0x11
 2968 04b9 96000000 		.4byte	0x96
 2969 04bd 1F       		.byte	0x1f
 2970 04be 00       		.byte	0
 2971 04bf 0B       		.uleb128 0xb
 2972 04c0 47020000 		.4byte	.LASF58
 2973 04c4 01       		.byte	0x1
 2974 04c5 A304     		.2byte	0x4a3
 2975 04c7 2C000000 		.4byte	0x2c
 2976 04cb 00000000 		.4byte	.LFB76
 2977 04cf 00020000 		.4byte	.LFE76-.LFB76
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 78


 2978 04d3 01       		.uleb128 0x1
 2979 04d4 9C       		.byte	0x9c
 2980 04d5 6F050000 		.4byte	0x56f
 2981 04d9 0C       		.uleb128 0xc
 2982 04da 80010000 		.4byte	.LASF59
 2983 04de 01       		.byte	0x1
 2984 04df A504     		.2byte	0x4a5
 2985 04e1 53000000 		.4byte	0x53
 2986 04e5 02       		.uleb128 0x2
 2987 04e6 91       		.byte	0x91
 2988 04e7 68       		.sleb128 -24
 2989 04e8 0C       		.uleb128 0xc
 2990 04e9 2D000000 		.4byte	.LASF60
 2991 04ed 01       		.byte	0x1
 2992 04ee A604     		.2byte	0x4a6
 2993 04f0 53000000 		.4byte	0x53
 2994 04f4 02       		.uleb128 0x2
 2995 04f5 91       		.byte	0x91
 2996 04f6 74       		.sleb128 -12
 2997 04f7 0C       		.uleb128 0xc
 2998 04f8 29050000 		.4byte	.LASF48
 2999 04fc 01       		.byte	0x1
 3000 04fd A704     		.2byte	0x4a7
 3001 04ff 3A000000 		.4byte	0x3a
 3002 0503 02       		.uleb128 0x2
 3003 0504 91       		.byte	0x91
 3004 0505 70       		.sleb128 -16
 3005 0506 0C       		.uleb128 0xc
 3006 0507 6E040000 		.4byte	.LASF25
 3007 050b 01       		.byte	0x1
 3008 050c A804     		.2byte	0x4a8
 3009 050e 2C000000 		.4byte	0x2c
 3010 0512 02       		.uleb128 0x2
 3011 0513 91       		.byte	0x91
 3012 0514 67       		.sleb128 -25
 3013 0515 0C       		.uleb128 0xc
 3014 0516 51030000 		.4byte	.LASF56
 3015 051a 01       		.byte	0x1
 3016 051b A904     		.2byte	0x4a9
 3017 051d 2C000000 		.4byte	0x2c
 3018 0521 02       		.uleb128 0x2
 3019 0522 91       		.byte	0x91
 3020 0523 6F       		.sleb128 -17
 3021 0524 0E       		.uleb128 0xe
 3022 0525 6900     		.ascii	"i\000"
 3023 0527 01       		.byte	0x1
 3024 0528 AA04     		.2byte	0x4aa
 3025 052a 2C000000 		.4byte	0x2c
 3026 052e 02       		.uleb128 0x2
 3027 052f 91       		.byte	0x91
 3028 0530 73       		.sleb128 -13
 3029 0531 0C       		.uleb128 0xc
 3030 0532 BD040000 		.4byte	.LASF57
 3031 0536 01       		.byte	0x1
 3032 0537 AB04     		.2byte	0x4ab
 3033 0539 AF040000 		.4byte	0x4af
 3034 053d 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 79


 3035 053e 91       		.byte	0x91
 3036 053f 44       		.sleb128 -60
 3037 0540 0C       		.uleb128 0xc
 3038 0541 70020000 		.4byte	.LASF61
 3039 0545 01       		.byte	0x1
 3040 0546 AC04     		.2byte	0x4ac
 3041 0548 AF040000 		.4byte	0x4af
 3042 054c 03       		.uleb128 0x3
 3043 054d 91       		.byte	0x91
 3044 054e A47F     		.sleb128 -92
 3045 0550 0C       		.uleb128 0xc
 3046 0551 2D040000 		.4byte	.LASF27
 3047 0555 01       		.byte	0x1
 3048 0556 AD04     		.2byte	0x4ad
 3049 0558 2C000000 		.4byte	0x2c
 3050 055c 02       		.uleb128 0x2
 3051 055d 91       		.byte	0x91
 3052 055e 72       		.sleb128 -14
 3053 055f 0C       		.uleb128 0xc
 3054 0560 FF040000 		.4byte	.LASF55
 3055 0564 01       		.byte	0x1
 3056 0565 AE04     		.2byte	0x4ae
 3057 0567 2C000000 		.4byte	0x2c
 3058 056b 02       		.uleb128 0x2
 3059 056c 91       		.byte	0x91
 3060 056d 6E       		.sleb128 -18
 3061 056e 00       		.byte	0
 3062 056f 0B       		.uleb128 0xb
 3063 0570 F1030000 		.4byte	.LASF62
 3064 0574 01       		.byte	0x1
 3065 0575 1005     		.2byte	0x510
 3066 0577 2C000000 		.4byte	0x2c
 3067 057b 00000000 		.4byte	.LFB77
 3068 057f 7C000000 		.4byte	.LFE77-.LFB77
 3069 0583 01       		.uleb128 0x1
 3070 0584 9C       		.byte	0x9c
 3071 0585 B7050000 		.4byte	0x5b7
 3072 0589 0C       		.uleb128 0xc
 3073 058a 1B040000 		.4byte	.LASF63
 3074 058e 01       		.byte	0x1
 3075 058f 1205     		.2byte	0x512
 3076 0591 53000000 		.4byte	0x53
 3077 0595 02       		.uleb128 0x2
 3078 0596 91       		.byte	0x91
 3079 0597 70       		.sleb128 -16
 3080 0598 0C       		.uleb128 0xc
 3081 0599 87020000 		.4byte	.LASF64
 3082 059d 01       		.byte	0x1
 3083 059e 1305     		.2byte	0x513
 3084 05a0 3A000000 		.4byte	0x3a
 3085 05a4 02       		.uleb128 0x2
 3086 05a5 91       		.byte	0x91
 3087 05a6 76       		.sleb128 -10
 3088 05a7 0C       		.uleb128 0xc
 3089 05a8 8F000000 		.4byte	.LASF65
 3090 05ac 01       		.byte	0x1
 3091 05ad 1405     		.2byte	0x514
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 80


 3092 05af 3A000000 		.4byte	0x3a
 3093 05b3 02       		.uleb128 0x2
 3094 05b4 91       		.byte	0x91
 3095 05b5 6E       		.sleb128 -18
 3096 05b6 00       		.byte	0
 3097 05b7 12       		.uleb128 0x12
 3098 05b8 08050000 		.4byte	.LASF66
 3099 05bc 01       		.byte	0x1
 3100 05bd 4005     		.2byte	0x540
 3101 05bf 2C000000 		.4byte	0x2c
 3102 05c3 00000000 		.4byte	.LFB78
 3103 05c7 18000000 		.4byte	.LFE78-.LFB78
 3104 05cb 01       		.uleb128 0x1
 3105 05cc 9C       		.byte	0x9c
 3106 05cd 13       		.uleb128 0x13
 3107 05ce 5A040000 		.4byte	.LASF78
 3108 05d2 01       		.byte	0x1
 3109 05d3 5405     		.2byte	0x554
 3110 05d5 00000000 		.4byte	.LFB79
 3111 05d9 26000000 		.4byte	.LFE79-.LFB79
 3112 05dd 01       		.uleb128 0x1
 3113 05de 9C       		.byte	0x9c
 3114 05df 14       		.uleb128 0x14
 3115 05e0 F1040000 		.4byte	.LASF67
 3116 05e4 04       		.byte	0x4
 3117 05e5 55       		.byte	0x55
 3118 05e6 2C000000 		.4byte	0x2c
 3119 05ea 15       		.uleb128 0x15
 3120 05eb 1C050000 		.4byte	.LASF68
 3121 05ef 05       		.byte	0x5
 3122 05f0 9606     		.2byte	0x696
 3123 05f2 F6050000 		.4byte	0x5f6
 3124 05f6 16       		.uleb128 0x16
 3125 05f7 76000000 		.4byte	0x76
 3126 05fb 17       		.uleb128 0x17
 3127 05fc 5A010000 		.4byte	.LASF69
 3128 0600 01       		.byte	0x1
 3129 0601 42       		.byte	0x42
 3130 0602 53000000 		.4byte	0x53
 3131 0606 05       		.uleb128 0x5
 3132 0607 03       		.byte	0x3
 3133 0608 00000000 		.4byte	checksum_Privileged
 3134 060c 17       		.uleb128 0x17
 3135 060d B9030000 		.4byte	.LASF70
 3136 0611 01       		.byte	0x1
 3137 0612 43       		.byte	0x43
 3138 0613 53000000 		.4byte	0x53
 3139 0617 05       		.uleb128 0x5
 3140 0618 03       		.byte	0x3
 3141 0619 00000000 		.4byte	statusCode
 3142 061d 17       		.uleb128 0x17
 3143 061e 69020000 		.4byte	.LASF71
 3144 0622 01       		.byte	0x1
 3145 0623 45       		.byte	0x45
 3146 0624 2C000000 		.4byte	0x2c
 3147 0628 05       		.uleb128 0x5
 3148 0629 03       		.byte	0x3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 81


 3149 062a 00000000 		.4byte	result
 3150 062e 17       		.uleb128 0x17
 3151 062f 20010000 		.4byte	.LASF72
 3152 0633 01       		.byte	0x1
 3153 0634 46       		.byte	0x46
 3154 0635 2C000000 		.4byte	0x2c
 3155 0639 05       		.uleb128 0x5
 3156 063a 03       		.byte	0x3
 3157 063b 00000000 		.4byte	chipProtectionData_Chip
 3158 063f 17       		.uleb128 0x17
 3159 0640 28040000 		.4byte	.LASF73
 3160 0644 01       		.byte	0x1
 3161 0645 48       		.byte	0x48
 3162 0646 A3000000 		.4byte	0xa3
 3163 064a 05       		.uleb128 0x5
 3164 064b 03       		.byte	0x3
 3165 064c 00000000 		.4byte	flow
 3166 0650 00       		.byte	0
 3167              		.section	.debug_abbrev,"",%progbits
 3168              	.Ldebug_abbrev0:
 3169 0000 01       		.uleb128 0x1
 3170 0001 11       		.uleb128 0x11
 3171 0002 01       		.byte	0x1
 3172 0003 25       		.uleb128 0x25
 3173 0004 0E       		.uleb128 0xe
 3174 0005 13       		.uleb128 0x13
 3175 0006 0B       		.uleb128 0xb
 3176 0007 03       		.uleb128 0x3
 3177 0008 0E       		.uleb128 0xe
 3178 0009 1B       		.uleb128 0x1b
 3179 000a 0E       		.uleb128 0xe
 3180 000b 55       		.uleb128 0x55
 3181 000c 17       		.uleb128 0x17
 3182 000d 11       		.uleb128 0x11
 3183 000e 01       		.uleb128 0x1
 3184 000f 10       		.uleb128 0x10
 3185 0010 17       		.uleb128 0x17
 3186 0011 00       		.byte	0
 3187 0012 00       		.byte	0
 3188 0013 02       		.uleb128 0x2
 3189 0014 24       		.uleb128 0x24
 3190 0015 00       		.byte	0
 3191 0016 0B       		.uleb128 0xb
 3192 0017 0B       		.uleb128 0xb
 3193 0018 3E       		.uleb128 0x3e
 3194 0019 0B       		.uleb128 0xb
 3195 001a 03       		.uleb128 0x3
 3196 001b 0E       		.uleb128 0xe
 3197 001c 00       		.byte	0
 3198 001d 00       		.byte	0
 3199 001e 03       		.uleb128 0x3
 3200 001f 16       		.uleb128 0x16
 3201 0020 00       		.byte	0
 3202 0021 03       		.uleb128 0x3
 3203 0022 0E       		.uleb128 0xe
 3204 0023 3A       		.uleb128 0x3a
 3205 0024 0B       		.uleb128 0xb
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 82


 3206 0025 3B       		.uleb128 0x3b
 3207 0026 0B       		.uleb128 0xb
 3208 0027 49       		.uleb128 0x49
 3209 0028 13       		.uleb128 0x13
 3210 0029 00       		.byte	0
 3211 002a 00       		.byte	0
 3212 002b 04       		.uleb128 0x4
 3213 002c 24       		.uleb128 0x24
 3214 002d 00       		.byte	0
 3215 002e 0B       		.uleb128 0xb
 3216 002f 0B       		.uleb128 0xb
 3217 0030 3E       		.uleb128 0x3e
 3218 0031 0B       		.uleb128 0xb
 3219 0032 03       		.uleb128 0x3
 3220 0033 08       		.uleb128 0x8
 3221 0034 00       		.byte	0
 3222 0035 00       		.byte	0
 3223 0036 05       		.uleb128 0x5
 3224 0037 0F       		.uleb128 0xf
 3225 0038 00       		.byte	0
 3226 0039 0B       		.uleb128 0xb
 3227 003a 0B       		.uleb128 0xb
 3228 003b 49       		.uleb128 0x49
 3229 003c 13       		.uleb128 0x13
 3230 003d 00       		.byte	0
 3231 003e 00       		.byte	0
 3232 003f 06       		.uleb128 0x6
 3233 0040 04       		.uleb128 0x4
 3234 0041 01       		.byte	0x1
 3235 0042 03       		.uleb128 0x3
 3236 0043 0E       		.uleb128 0xe
 3237 0044 0B       		.uleb128 0xb
 3238 0045 0B       		.uleb128 0xb
 3239 0046 3A       		.uleb128 0x3a
 3240 0047 0B       		.uleb128 0xb
 3241 0048 3B       		.uleb128 0x3b
 3242 0049 0B       		.uleb128 0xb
 3243 004a 01       		.uleb128 0x1
 3244 004b 13       		.uleb128 0x13
 3245 004c 00       		.byte	0
 3246 004d 00       		.byte	0
 3247 004e 07       		.uleb128 0x7
 3248 004f 28       		.uleb128 0x28
 3249 0050 00       		.byte	0
 3250 0051 03       		.uleb128 0x3
 3251 0052 0E       		.uleb128 0xe
 3252 0053 1C       		.uleb128 0x1c
 3253 0054 0D       		.uleb128 0xd
 3254 0055 00       		.byte	0
 3255 0056 00       		.byte	0
 3256 0057 08       		.uleb128 0x8
 3257 0058 2E       		.uleb128 0x2e
 3258 0059 01       		.byte	0x1
 3259 005a 3F       		.uleb128 0x3f
 3260 005b 19       		.uleb128 0x19
 3261 005c 03       		.uleb128 0x3
 3262 005d 0E       		.uleb128 0xe
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 83


 3263 005e 3A       		.uleb128 0x3a
 3264 005f 0B       		.uleb128 0xb
 3265 0060 3B       		.uleb128 0x3b
 3266 0061 0B       		.uleb128 0xb
 3267 0062 27       		.uleb128 0x27
 3268 0063 19       		.uleb128 0x19
 3269 0064 49       		.uleb128 0x49
 3270 0065 13       		.uleb128 0x13
 3271 0066 11       		.uleb128 0x11
 3272 0067 01       		.uleb128 0x1
 3273 0068 12       		.uleb128 0x12
 3274 0069 06       		.uleb128 0x6
 3275 006a 40       		.uleb128 0x40
 3276 006b 18       		.uleb128 0x18
 3277 006c 9642     		.uleb128 0x2116
 3278 006e 19       		.uleb128 0x19
 3279 006f 01       		.uleb128 0x1
 3280 0070 13       		.uleb128 0x13
 3281 0071 00       		.byte	0
 3282 0072 00       		.byte	0
 3283 0073 09       		.uleb128 0x9
 3284 0074 34       		.uleb128 0x34
 3285 0075 00       		.byte	0
 3286 0076 03       		.uleb128 0x3
 3287 0077 0E       		.uleb128 0xe
 3288 0078 3A       		.uleb128 0x3a
 3289 0079 0B       		.uleb128 0xb
 3290 007a 3B       		.uleb128 0x3b
 3291 007b 0B       		.uleb128 0xb
 3292 007c 49       		.uleb128 0x49
 3293 007d 13       		.uleb128 0x13
 3294 007e 02       		.uleb128 0x2
 3295 007f 18       		.uleb128 0x18
 3296 0080 00       		.byte	0
 3297 0081 00       		.byte	0
 3298 0082 0A       		.uleb128 0xa
 3299 0083 2E       		.uleb128 0x2e
 3300 0084 00       		.byte	0
 3301 0085 3F       		.uleb128 0x3f
 3302 0086 19       		.uleb128 0x19
 3303 0087 03       		.uleb128 0x3
 3304 0088 0E       		.uleb128 0xe
 3305 0089 3A       		.uleb128 0x3a
 3306 008a 0B       		.uleb128 0xb
 3307 008b 3B       		.uleb128 0x3b
 3308 008c 0B       		.uleb128 0xb
 3309 008d 27       		.uleb128 0x27
 3310 008e 19       		.uleb128 0x19
 3311 008f 49       		.uleb128 0x49
 3312 0090 13       		.uleb128 0x13
 3313 0091 11       		.uleb128 0x11
 3314 0092 01       		.uleb128 0x1
 3315 0093 12       		.uleb128 0x12
 3316 0094 06       		.uleb128 0x6
 3317 0095 40       		.uleb128 0x40
 3318 0096 18       		.uleb128 0x18
 3319 0097 9742     		.uleb128 0x2117
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 84


 3320 0099 19       		.uleb128 0x19
 3321 009a 00       		.byte	0
 3322 009b 00       		.byte	0
 3323 009c 0B       		.uleb128 0xb
 3324 009d 2E       		.uleb128 0x2e
 3325 009e 01       		.byte	0x1
 3326 009f 3F       		.uleb128 0x3f
 3327 00a0 19       		.uleb128 0x19
 3328 00a1 03       		.uleb128 0x3
 3329 00a2 0E       		.uleb128 0xe
 3330 00a3 3A       		.uleb128 0x3a
 3331 00a4 0B       		.uleb128 0xb
 3332 00a5 3B       		.uleb128 0x3b
 3333 00a6 05       		.uleb128 0x5
 3334 00a7 27       		.uleb128 0x27
 3335 00a8 19       		.uleb128 0x19
 3336 00a9 49       		.uleb128 0x49
 3337 00aa 13       		.uleb128 0x13
 3338 00ab 11       		.uleb128 0x11
 3339 00ac 01       		.uleb128 0x1
 3340 00ad 12       		.uleb128 0x12
 3341 00ae 06       		.uleb128 0x6
 3342 00af 40       		.uleb128 0x40
 3343 00b0 18       		.uleb128 0x18
 3344 00b1 9642     		.uleb128 0x2116
 3345 00b3 19       		.uleb128 0x19
 3346 00b4 01       		.uleb128 0x1
 3347 00b5 13       		.uleb128 0x13
 3348 00b6 00       		.byte	0
 3349 00b7 00       		.byte	0
 3350 00b8 0C       		.uleb128 0xc
 3351 00b9 34       		.uleb128 0x34
 3352 00ba 00       		.byte	0
 3353 00bb 03       		.uleb128 0x3
 3354 00bc 0E       		.uleb128 0xe
 3355 00bd 3A       		.uleb128 0x3a
 3356 00be 0B       		.uleb128 0xb
 3357 00bf 3B       		.uleb128 0x3b
 3358 00c0 05       		.uleb128 0x5
 3359 00c1 49       		.uleb128 0x49
 3360 00c2 13       		.uleb128 0x13
 3361 00c3 02       		.uleb128 0x2
 3362 00c4 18       		.uleb128 0x18
 3363 00c5 00       		.byte	0
 3364 00c6 00       		.byte	0
 3365 00c7 0D       		.uleb128 0xd
 3366 00c8 05       		.uleb128 0x5
 3367 00c9 00       		.byte	0
 3368 00ca 03       		.uleb128 0x3
 3369 00cb 0E       		.uleb128 0xe
 3370 00cc 3A       		.uleb128 0x3a
 3371 00cd 0B       		.uleb128 0xb
 3372 00ce 3B       		.uleb128 0x3b
 3373 00cf 05       		.uleb128 0x5
 3374 00d0 49       		.uleb128 0x49
 3375 00d1 13       		.uleb128 0x13
 3376 00d2 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 85


 3377 00d3 18       		.uleb128 0x18
 3378 00d4 00       		.byte	0
 3379 00d5 00       		.byte	0
 3380 00d6 0E       		.uleb128 0xe
 3381 00d7 34       		.uleb128 0x34
 3382 00d8 00       		.byte	0
 3383 00d9 03       		.uleb128 0x3
 3384 00da 08       		.uleb128 0x8
 3385 00db 3A       		.uleb128 0x3a
 3386 00dc 0B       		.uleb128 0xb
 3387 00dd 3B       		.uleb128 0x3b
 3388 00de 05       		.uleb128 0x5
 3389 00df 49       		.uleb128 0x49
 3390 00e0 13       		.uleb128 0x13
 3391 00e1 02       		.uleb128 0x2
 3392 00e2 18       		.uleb128 0x18
 3393 00e3 00       		.byte	0
 3394 00e4 00       		.byte	0
 3395 00e5 0F       		.uleb128 0xf
 3396 00e6 2E       		.uleb128 0x2e
 3397 00e7 00       		.byte	0
 3398 00e8 3F       		.uleb128 0x3f
 3399 00e9 19       		.uleb128 0x19
 3400 00ea 03       		.uleb128 0x3
 3401 00eb 0E       		.uleb128 0xe
 3402 00ec 3A       		.uleb128 0x3a
 3403 00ed 0B       		.uleb128 0xb
 3404 00ee 3B       		.uleb128 0x3b
 3405 00ef 05       		.uleb128 0x5
 3406 00f0 27       		.uleb128 0x27
 3407 00f1 19       		.uleb128 0x19
 3408 00f2 49       		.uleb128 0x49
 3409 00f3 13       		.uleb128 0x13
 3410 00f4 11       		.uleb128 0x11
 3411 00f5 01       		.uleb128 0x1
 3412 00f6 12       		.uleb128 0x12
 3413 00f7 06       		.uleb128 0x6
 3414 00f8 40       		.uleb128 0x40
 3415 00f9 18       		.uleb128 0x18
 3416 00fa 9642     		.uleb128 0x2116
 3417 00fc 19       		.uleb128 0x19
 3418 00fd 00       		.byte	0
 3419 00fe 00       		.byte	0
 3420 00ff 10       		.uleb128 0x10
 3421 0100 01       		.uleb128 0x1
 3422 0101 01       		.byte	0x1
 3423 0102 49       		.uleb128 0x49
 3424 0103 13       		.uleb128 0x13
 3425 0104 01       		.uleb128 0x1
 3426 0105 13       		.uleb128 0x13
 3427 0106 00       		.byte	0
 3428 0107 00       		.byte	0
 3429 0108 11       		.uleb128 0x11
 3430 0109 21       		.uleb128 0x21
 3431 010a 00       		.byte	0
 3432 010b 49       		.uleb128 0x49
 3433 010c 13       		.uleb128 0x13
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 86


 3434 010d 2F       		.uleb128 0x2f
 3435 010e 0B       		.uleb128 0xb
 3436 010f 00       		.byte	0
 3437 0110 00       		.byte	0
 3438 0111 12       		.uleb128 0x12
 3439 0112 2E       		.uleb128 0x2e
 3440 0113 00       		.byte	0
 3441 0114 3F       		.uleb128 0x3f
 3442 0115 19       		.uleb128 0x19
 3443 0116 03       		.uleb128 0x3
 3444 0117 0E       		.uleb128 0xe
 3445 0118 3A       		.uleb128 0x3a
 3446 0119 0B       		.uleb128 0xb
 3447 011a 3B       		.uleb128 0x3b
 3448 011b 05       		.uleb128 0x5
 3449 011c 27       		.uleb128 0x27
 3450 011d 19       		.uleb128 0x19
 3451 011e 49       		.uleb128 0x49
 3452 011f 13       		.uleb128 0x13
 3453 0120 11       		.uleb128 0x11
 3454 0121 01       		.uleb128 0x1
 3455 0122 12       		.uleb128 0x12
 3456 0123 06       		.uleb128 0x6
 3457 0124 40       		.uleb128 0x40
 3458 0125 18       		.uleb128 0x18
 3459 0126 9742     		.uleb128 0x2117
 3460 0128 19       		.uleb128 0x19
 3461 0129 00       		.byte	0
 3462 012a 00       		.byte	0
 3463 012b 13       		.uleb128 0x13
 3464 012c 2E       		.uleb128 0x2e
 3465 012d 00       		.byte	0
 3466 012e 3F       		.uleb128 0x3f
 3467 012f 19       		.uleb128 0x19
 3468 0130 03       		.uleb128 0x3
 3469 0131 0E       		.uleb128 0xe
 3470 0132 3A       		.uleb128 0x3a
 3471 0133 0B       		.uleb128 0xb
 3472 0134 3B       		.uleb128 0x3b
 3473 0135 05       		.uleb128 0x5
 3474 0136 27       		.uleb128 0x27
 3475 0137 19       		.uleb128 0x19
 3476 0138 11       		.uleb128 0x11
 3477 0139 01       		.uleb128 0x1
 3478 013a 12       		.uleb128 0x12
 3479 013b 06       		.uleb128 0x6
 3480 013c 40       		.uleb128 0x40
 3481 013d 18       		.uleb128 0x18
 3482 013e 9642     		.uleb128 0x2116
 3483 0140 19       		.uleb128 0x19
 3484 0141 00       		.byte	0
 3485 0142 00       		.byte	0
 3486 0143 14       		.uleb128 0x14
 3487 0144 34       		.uleb128 0x34
 3488 0145 00       		.byte	0
 3489 0146 03       		.uleb128 0x3
 3490 0147 0E       		.uleb128 0xe
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 87


 3491 0148 3A       		.uleb128 0x3a
 3492 0149 0B       		.uleb128 0xb
 3493 014a 3B       		.uleb128 0x3b
 3494 014b 0B       		.uleb128 0xb
 3495 014c 49       		.uleb128 0x49
 3496 014d 13       		.uleb128 0x13
 3497 014e 3F       		.uleb128 0x3f
 3498 014f 19       		.uleb128 0x19
 3499 0150 3C       		.uleb128 0x3c
 3500 0151 19       		.uleb128 0x19
 3501 0152 00       		.byte	0
 3502 0153 00       		.byte	0
 3503 0154 15       		.uleb128 0x15
 3504 0155 34       		.uleb128 0x34
 3505 0156 00       		.byte	0
 3506 0157 03       		.uleb128 0x3
 3507 0158 0E       		.uleb128 0xe
 3508 0159 3A       		.uleb128 0x3a
 3509 015a 0B       		.uleb128 0xb
 3510 015b 3B       		.uleb128 0x3b
 3511 015c 05       		.uleb128 0x5
 3512 015d 49       		.uleb128 0x49
 3513 015e 13       		.uleb128 0x13
 3514 015f 3F       		.uleb128 0x3f
 3515 0160 19       		.uleb128 0x19
 3516 0161 3C       		.uleb128 0x3c
 3517 0162 19       		.uleb128 0x19
 3518 0163 00       		.byte	0
 3519 0164 00       		.byte	0
 3520 0165 16       		.uleb128 0x16
 3521 0166 35       		.uleb128 0x35
 3522 0167 00       		.byte	0
 3523 0168 49       		.uleb128 0x49
 3524 0169 13       		.uleb128 0x13
 3525 016a 00       		.byte	0
 3526 016b 00       		.byte	0
 3527 016c 17       		.uleb128 0x17
 3528 016d 34       		.uleb128 0x34
 3529 016e 00       		.byte	0
 3530 016f 03       		.uleb128 0x3
 3531 0170 0E       		.uleb128 0xe
 3532 0171 3A       		.uleb128 0x3a
 3533 0172 0B       		.uleb128 0xb
 3534 0173 3B       		.uleb128 0x3b
 3535 0174 0B       		.uleb128 0xb
 3536 0175 49       		.uleb128 0x49
 3537 0176 13       		.uleb128 0x13
 3538 0177 3F       		.uleb128 0x3f
 3539 0178 19       		.uleb128 0x19
 3540 0179 02       		.uleb128 0x2
 3541 017a 18       		.uleb128 0x18
 3542 017b 00       		.byte	0
 3543 017c 00       		.byte	0
 3544 017d 00       		.byte	0
 3545              		.section	.debug_aranges,"",%progbits
 3546 0000 9C000000 		.4byte	0x9c
 3547 0004 0200     		.2byte	0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 88


 3548 0006 00000000 		.4byte	.Ldebug_info0
 3549 000a 04       		.byte	0x4
 3550 000b 00       		.byte	0
 3551 000c 0000     		.2byte	0
 3552 000e 0000     		.2byte	0
 3553 0010 00000000 		.4byte	.LFB63
 3554 0014 9C000000 		.4byte	.LFE63-.LFB63
 3555 0018 00000000 		.4byte	.LFB64
 3556 001c 18000000 		.4byte	.LFE64-.LFB64
 3557 0020 00000000 		.4byte	.LFB65
 3558 0024 94000000 		.4byte	.LFE65-.LFB65
 3559 0028 00000000 		.4byte	.LFB66
 3560 002c A4000000 		.4byte	.LFE66-.LFB66
 3561 0030 00000000 		.4byte	.LFB67
 3562 0034 24010000 		.4byte	.LFE67-.LFB67
 3563 0038 00000000 		.4byte	.LFB68
 3564 003c AC000000 		.4byte	.LFE68-.LFB68
 3565 0040 00000000 		.4byte	.LFB69
 3566 0044 34010000 		.4byte	.LFE69-.LFB69
 3567 0048 00000000 		.4byte	.LFB70
 3568 004c 00010000 		.4byte	.LFE70-.LFB70
 3569 0050 00000000 		.4byte	.LFB71
 3570 0054 24010000 		.4byte	.LFE71-.LFB71
 3571 0058 00000000 		.4byte	.LFB72
 3572 005c 30000000 		.4byte	.LFE72-.LFB72
 3573 0060 00000000 		.4byte	.LFB73
 3574 0064 1C010000 		.4byte	.LFE73-.LFB73
 3575 0068 00000000 		.4byte	.LFB74
 3576 006c 30010000 		.4byte	.LFE74-.LFB74
 3577 0070 00000000 		.4byte	.LFB75
 3578 0074 18010000 		.4byte	.LFE75-.LFB75
 3579 0078 00000000 		.4byte	.LFB76
 3580 007c 00020000 		.4byte	.LFE76-.LFB76
 3581 0080 00000000 		.4byte	.LFB77
 3582 0084 7C000000 		.4byte	.LFE77-.LFB77
 3583 0088 00000000 		.4byte	.LFB78
 3584 008c 18000000 		.4byte	.LFE78-.LFB78
 3585 0090 00000000 		.4byte	.LFB79
 3586 0094 26000000 		.4byte	.LFE79-.LFB79
 3587 0098 00000000 		.4byte	0
 3588 009c 00000000 		.4byte	0
 3589              		.section	.debug_ranges,"",%progbits
 3590              	.Ldebug_ranges0:
 3591 0000 00000000 		.4byte	.LFB63
 3592 0004 9C000000 		.4byte	.LFE63
 3593 0008 00000000 		.4byte	.LFB64
 3594 000c 18000000 		.4byte	.LFE64
 3595 0010 00000000 		.4byte	.LFB65
 3596 0014 94000000 		.4byte	.LFE65
 3597 0018 00000000 		.4byte	.LFB66
 3598 001c A4000000 		.4byte	.LFE66
 3599 0020 00000000 		.4byte	.LFB67
 3600 0024 24010000 		.4byte	.LFE67
 3601 0028 00000000 		.4byte	.LFB68
 3602 002c AC000000 		.4byte	.LFE68
 3603 0030 00000000 		.4byte	.LFB69
 3604 0034 34010000 		.4byte	.LFE69
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 89


 3605 0038 00000000 		.4byte	.LFB70
 3606 003c 00010000 		.4byte	.LFE70
 3607 0040 00000000 		.4byte	.LFB71
 3608 0044 24010000 		.4byte	.LFE71
 3609 0048 00000000 		.4byte	.LFB72
 3610 004c 30000000 		.4byte	.LFE72
 3611 0050 00000000 		.4byte	.LFB73
 3612 0054 1C010000 		.4byte	.LFE73
 3613 0058 00000000 		.4byte	.LFB74
 3614 005c 30010000 		.4byte	.LFE74
 3615 0060 00000000 		.4byte	.LFB75
 3616 0064 18010000 		.4byte	.LFE75
 3617 0068 00000000 		.4byte	.LFB76
 3618 006c 00020000 		.4byte	.LFE76
 3619 0070 00000000 		.4byte	.LFB77
 3620 0074 7C000000 		.4byte	.LFE77
 3621 0078 00000000 		.4byte	.LFB78
 3622 007c 18000000 		.4byte	.LFE78
 3623 0080 00000000 		.4byte	.LFB79
 3624 0084 26000000 		.4byte	.LFE79
 3625 0088 00000000 		.4byte	0
 3626 008c 00000000 		.4byte	0
 3627              		.section	.debug_line,"",%progbits
 3628              	.Ldebug_line0:
 3629 0000 F4040000 		.section	.debug_str,"MS",%progbits,1
 3629      02004F01 
 3629      00000201 
 3629      FB0E0D00 
 3629      01010101 
 3630              	.LASF18:
 3631 0000 57524F4E 		.ascii	"WRONG_TRANSITION\000"
 3631      475F5452 
 3631      414E5349 
 3631      54494F4E 
 3631      00
 3632              	.LASF35:
 3633 0011 44657669 		.ascii	"DeviceAcquire\000"
 3633      63654163 
 3633      71756972 
 3633      6500
 3634              	.LASF44:
 3635 001f 45726173 		.ascii	"EraseAllFlash\000"
 3635      65416C6C 
 3635      466C6173 
 3635      6800
 3636              	.LASF60:
 3637 002d 666C6173 		.ascii	"flashProtectionAddress\000"
 3637      6850726F 
 3637      74656374 
 3637      696F6E41 
 3637      64647265 
 3638              	.LASF54:
 3639 0044 50726F67 		.ascii	"ProgramProtectionSettings\000"
 3639      72616D50 
 3639      726F7465 
 3639      6374696F 
 3639      6E536574 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 90


 3640              	.LASF42:
 3641 005e 73696C69 		.ascii	"siliconIdData1\000"
 3641      636F6E49 
 3641      64446174 
 3641      613100
 3642              	.LASF43:
 3643 006d 73696C69 		.ascii	"siliconIdData2\000"
 3643      636F6E49 
 3643      64446174 
 3643      613200
 3644              	.LASF52:
 3645 007c 726F7741 		.ascii	"rowAddress\000"
 3645      64647265 
 3645      737300
 3646              	.LASF28:
 3647 0087 726F7744 		.ascii	"rowData\000"
 3647      61746100 
 3648              	.LASF65:
 3649 008f 63686563 		.ascii	"checksumData\000"
 3649      6B73756D 
 3649      44617461 
 3649      00
 3650              	.LASF2:
 3651 009c 73686F72 		.ascii	"short int\000"
 3651      7420696E 
 3651      7400
 3652              	.LASF40:
 3653 00a6 64657669 		.ascii	"deviceSiliconID\000"
 3653      63655369 
 3653      6C69636F 
 3653      6E494400 
 3654              	.LASF14:
 3655 00b6 73697A65 		.ascii	"sizetype\000"
 3655      74797065 
 3655      00
 3656              	.LASF36:
 3657 00bf 63686970 		.ascii	"chip_DAP_Id\000"
 3657      5F444150 
 3657      5F496400 
 3658              	.LASF24:
 3659 00cb 47657454 		.ascii	"GetTransitionMode\000"
 3659      72616E73 
 3659      6974696F 
 3659      6E4D6F64 
 3659      6500
 3660              	.LASF75:
 3661 00dd 50726F67 		.ascii	"ProgrammingSteps.c\000"
 3661      72616D6D 
 3661      696E6753 
 3661      74657073 
 3661      2E6300
 3662              	.LASF6:
 3663 00f0 6C6F6E67 		.ascii	"long long int\000"
 3663      206C6F6E 
 3663      6720696E 
 3663      7400
 3664              	.LASF32:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 91


 3665 00fe 63686563 		.ascii	"checksumRow\000"
 3665      6B73756D 
 3665      526F7700 
 3666              	.LASF22:
 3667 010a 70617261 		.ascii	"parameter1\000"
 3667      6D657465 
 3667      723100
 3668              	.LASF30:
 3669 0115 70617261 		.ascii	"parameter2\000"
 3669      6D657465 
 3669      723200
 3670              	.LASF72:
 3671 0120 63686970 		.ascii	"chipProtectionData_Chip\000"
 3671      50726F74 
 3671      65637469 
 3671      6F6E4461 
 3671      74615F43 
 3672              	.LASF33:
 3673 0138 63686563 		.ascii	"checksum\000"
 3673      6B73756D 
 3673      00
 3674              	.LASF29:
 3675 0141 726F7742 		.ascii	"rowByteSize\000"
 3675      79746553 
 3675      697A6500 
 3676              	.LASF47:
 3677 014d 50726F67 		.ascii	"ProgramFlash\000"
 3677      72616D46 
 3677      6C617368 
 3677      00
 3678              	.LASF69:
 3679 015a 63686563 		.ascii	"checksum_Privileged\000"
 3679      6B73756D 
 3679      5F507269 
 3679      76696C65 
 3679      67656400 
 3680              	.LASF0:
 3681 016e 7369676E 		.ascii	"signed char\000"
 3681      65642063 
 3681      68617200 
 3682              	.LASF11:
 3683 017a 666C6F61 		.ascii	"float\000"
 3683      7400
 3684              	.LASF59:
 3685 0180 70726F74 		.ascii	"protectionData\000"
 3685      65637469 
 3685      6F6E4461 
 3685      746100
 3686              	.LASF39:
 3687 018f 56657269 		.ascii	"VerifySiliconId\000"
 3687      66795369 
 3687      6C69636F 
 3687      6E496400 
 3688              	.LASF23:
 3689 019f 63686970 		.ascii	"chipProtData\000"
 3689      50726F74 
 3689      44617461 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 92


 3689      00
 3690              	.LASF21:
 3691 01ac 74696D65 		.ascii	"time_elapsed\000"
 3691      5F656C61 
 3691      70736564 
 3691      00
 3692              	.LASF74:
 3693 01b9 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 3693      4320342E 
 3693      392E3320 
 3693      32303135 
 3693      30333033 
 3694 01ec 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 3694      20726576 
 3694      6973696F 
 3694      6E203232 
 3694      31323230 
 3695 021f 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 3695      66756E63 
 3695      74696F6E 
 3695      2D736563 
 3695      74696F6E 
 3696              	.LASF58:
 3697 0247 56657269 		.ascii	"VerifyProtectionSettings\000"
 3697      66795072 
 3697      6F746563 
 3697      74696F6E 
 3697      53657474 
 3698              	.LASF15:
 3699 0260 4F50454E 		.ascii	"OPEN_XXX\000"
 3699      5F585858 
 3699      00
 3700              	.LASF71:
 3701 0269 72657375 		.ascii	"result\000"
 3701      6C7400
 3702              	.LASF61:
 3703 0270 726F7750 		.ascii	"rowProtectionFlashData\000"
 3703      726F7465 
 3703      6374696F 
 3703      6E466C61 
 3703      73684461 
 3704              	.LASF64:
 3705 0287 63686970 		.ascii	"chip_Checksum\000"
 3705      5F436865 
 3705      636B7375 
 3705      6D00
 3706              	.LASF53:
 3707 0295 63686970 		.ascii	"chipData\000"
 3707      44617461 
 3707      00
 3708              	.LASF76:
 3709 029e 5C5C4745 		.ascii	"\\\\GEORGE-OFFICE2\\Users\\George\\Box Sync\\Backbo"
 3709      4F524745 
 3709      2D4F4646 
 3709      49434532 
 3709      5C557365 
 3710 02cb 6E655C44 		.ascii	"ne\\Design\\Testing\\TestStation\\Software\\HSSP\\A"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 93


 3710      65736967 
 3710      6E5C5465 
 3710      7374696E 
 3710      675C5465 
 3711 02f8 4E383438 		.ascii	"N84858\\A_Hssp_Programmer.cydsn\000"
 3711      35385C41 
 3711      5F487373 
 3711      705F5072 
 3711      6F677261 
 3712              	.LASF51:
 3713 0317 666C6173 		.ascii	"flashData\000"
 3713      68446174 
 3713      6100
 3714              	.LASF1:
 3715 0321 756E7369 		.ascii	"unsigned char\000"
 3715      676E6564 
 3715      20636861 
 3715      7200
 3716              	.LASF45:
 3717 032f 52656164 		.ascii	"ReadSromStatus\000"
 3717      53726F6D 
 3717      53746174 
 3717      757300
 3718              	.LASF37:
 3719 033e 746F7461 		.ascii	"total_packet_count\000"
 3719      6C5F7061 
 3719      636B6574 
 3719      5F636F75 
 3719      6E7400
 3720              	.LASF56:
 3721 0351 726F7750 		.ascii	"rowProtectionByteSize\000"
 3721      726F7465 
 3721      6374696F 
 3721      6E427974 
 3721      6553697A 
 3722              	.LASF50:
 3723 0367 56657269 		.ascii	"VerifyFlash\000"
 3723      6679466C 
 3723      61736800 
 3724              	.LASF7:
 3725 0373 6C6F6E67 		.ascii	"long long unsigned int\000"
 3725      206C6F6E 
 3725      6720756E 
 3725      7369676E 
 3725      65642069 
 3726              	.LASF46:
 3727 038a 43686563 		.ascii	"ChecksumPrivileged\000"
 3727      6B73756D 
 3727      50726976 
 3727      696C6567 
 3727      656400
 3728              	.LASF8:
 3729 039d 756E7369 		.ascii	"unsigned int\000"
 3729      676E6564 
 3729      20696E74 
 3729      00
 3730              	.LASF19:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 94


 3731 03aa 506F6C6C 		.ascii	"PollSromStatus\000"
 3731      53726F6D 
 3731      53746174 
 3731      757300
 3732              	.LASF70:
 3733 03b9 73746174 		.ascii	"statusCode\000"
 3733      7573436F 
 3733      646500
 3734              	.LASF3:
 3735 03c4 73686F72 		.ascii	"short unsigned int\000"
 3735      7420756E 
 3735      7369676E 
 3735      65642069 
 3735      6E7400
 3736              	.LASF38:
 3737 03d7 73746174 		.ascii	"status\000"
 3737      757300
 3738              	.LASF34:
 3739 03de 63686563 		.ascii	"checksum_chip\000"
 3739      6B73756D 
 3739      5F636869 
 3739      7000
 3740              	.LASF13:
 3741 03ec 63686172 		.ascii	"char\000"
 3741      00
 3742              	.LASF62:
 3743 03f1 56657269 		.ascii	"VerifyChecksum\000"
 3743      66794368 
 3743      65636B73 
 3743      756D00
 3744              	.LASF4:
 3745 0400 6C6F6E67 		.ascii	"long int\000"
 3745      20696E74 
 3745      00
 3746              	.LASF26:
 3747 0409 4C6F6164 		.ascii	"LoadLatch\000"
 3747      4C617463 
 3747      6800
 3748              	.LASF10:
 3749 0413 696E7433 		.ascii	"int32_t\000"
 3749      325F7400 
 3750              	.LASF63:
 3751 041b 63686563 		.ascii	"checksum_All\000"
 3751      6B73756D 
 3751      5F416C6C 
 3751      00
 3752              	.LASF73:
 3753 0428 666C6F77 		.ascii	"flow\000"
 3753      00
 3754              	.LASF27:
 3755 042d 61727261 		.ascii	"arrayID\000"
 3755      79494400 
 3756              	.LASF5:
 3757 0435 6C6F6E67 		.ascii	"long unsigned int\000"
 3757      20756E73 
 3757      69676E65 
 3757      6420696E 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 95


 3757      7400
 3758              	.LASF31:
 3759 0447 43686563 		.ascii	"ChecksumAPI\000"
 3759      6B73756D 
 3759      41504900 
 3760              	.LASF12:
 3761 0453 646F7562 		.ascii	"double\000"
 3761      6C6500
 3762              	.LASF78:
 3763 045a 45786974 		.ascii	"ExitProgrammingMode\000"
 3763      50726F67 
 3763      72616D6D 
 3763      696E674D 
 3763      6F646500 
 3764              	.LASF25:
 3765 046e 63686970 		.ascii	"chipProtectionData_Hex\000"
 3765      50726F74 
 3765      65637469 
 3765      6F6E4461 
 3765      74615F48 
 3766              	.LASF49:
 3767 0485 726F7743 		.ascii	"rowCount\000"
 3767      6F756E74 
 3767      00
 3768              	.LASF9:
 3769 048e 5F5F696E 		.ascii	"__int32_t\000"
 3769      7433325F 
 3769      7400
 3770              	.LASF16:
 3771 0498 56495247 		.ascii	"VIRGIN_OPEN\000"
 3771      494E5F4F 
 3771      50454E00 
 3772              	.LASF77:
 3773 04a4 5472616E 		.ascii	"Transition_mode\000"
 3773      73697469 
 3773      6F6E5F6D 
 3773      6F646500 
 3774              	.LASF17:
 3775 04b4 50524F54 		.ascii	"PROT_XXX\000"
 3775      5F585858 
 3775      00
 3776              	.LASF57:
 3777 04bd 726F7750 		.ascii	"rowProtectionData\000"
 3777      726F7465 
 3777      6374696F 
 3777      6E446174 
 3777      6100
 3778              	.LASF41:
 3779 04cf 68657853 		.ascii	"hexSiliconId\000"
 3779      696C6963 
 3779      6F6E4964 
 3779      00
 3780              	.LASF20:
 3781 04dc 47657443 		.ascii	"GetChipProtectionVal\000"
 3781      68697050 
 3781      726F7465 
 3781      6374696F 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cc8Cq8Td.s 			page 96


 3781      6E56616C 
 3782              	.LASF67:
 3783 04f1 7377645F 		.ascii	"swd_PacketAck\000"
 3783      5061636B 
 3783      65744163 
 3783      6B00
 3784              	.LASF55:
 3785 04ff 61727261 		.ascii	"arrayMax\000"
 3785      794D6178 
 3785      00
 3786              	.LASF66:
 3787 0508 52656164 		.ascii	"ReadHsspErrorStatus\000"
 3787      48737370 
 3787      4572726F 
 3787      72537461 
 3787      74757300 
 3788              	.LASF68:
 3789 051c 49544D5F 		.ascii	"ITM_RxBuffer\000"
 3789      52784275 
 3789      66666572 
 3789      00
 3790              	.LASF48:
 3791 0529 6E756D4F 		.ascii	"numOfFlashRows\000"
 3791      66466C61 
 3791      7368526F 
 3791      777300
 3792              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
