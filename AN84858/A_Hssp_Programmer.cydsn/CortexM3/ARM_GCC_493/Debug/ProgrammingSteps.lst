ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ProgrammingSteps.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	checksum_Privileged
  19              		.bss
  20              		.align	2
  21              		.type	checksum_Privileged, %object
  22              		.size	checksum_Privileged, 4
  23              	checksum_Privileged:
  24 0000 00000000 		.space	4
  25              		.global	statusCode
  26              		.align	2
  27              		.type	statusCode, %object
  28              		.size	statusCode, 4
  29              	statusCode:
  30 0004 00000000 		.space	4
  31              		.global	result
  32              		.type	result, %object
  33              		.size	result, 1
  34              	result:
  35 0008 00       		.space	1
  36              		.global	chipProtectionData_Chip
  37              		.type	chipProtectionData_Chip, %object
  38              		.size	chipProtectionData_Chip, 1
  39              	chipProtectionData_Chip:
  40 0009 00       		.space	1
  41              		.comm	flow,1,1
  42 000a 0000     		.section	.text.PollSromStatus,"ax",%progbits
  43              		.align	2
  44              		.global	PollSromStatus
  45              		.thumb
  46              		.thumb_func
  47              		.type	PollSromStatus, %function
  48              	PollSromStatus:
  49              	.LFB63:
  50              		.file 1 "ProgrammingSteps.c"
   1:ProgrammingSteps.c **** /******************************************************************************
   2:ProgrammingSteps.c **** * File Name: ProgrammingSteps.c
   3:ProgrammingSteps.c **** * Version 1.0
   4:ProgrammingSteps.c **** *
   5:ProgrammingSteps.c **** * Description:
   6:ProgrammingSteps.c **** *  This file provides the source code for the high level Programming functions 
   7:ProgrammingSteps.c **** *  used by the main code to program target PSoC 4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 2


   8:ProgrammingSteps.c **** *
   9:ProgrammingSteps.c **** * Owner:
  10:ProgrammingSteps.c **** *	Tushar Rastogi, Application Engineer (tusr@cypress.com)
  11:ProgrammingSteps.c **** *
  12:ProgrammingSteps.c **** * Related Document:
  13:ProgrammingSteps.c **** *	AN84858 - PSoC 4 Programming using an External Microcontroller (HSSP)
  14:ProgrammingSteps.c **** *
  15:ProgrammingSteps.c **** * Hardware Dependency:
  16:ProgrammingSteps.c **** *   PSoC 5LP Development Kit - CY8CKIT-050
  17:ProgrammingSteps.c **** *
  18:ProgrammingSteps.c **** * Code Tested With:
  19:ProgrammingSteps.c **** *	PSoC Creator 3.2
  20:ProgrammingSteps.c **** *	ARM GCC 4.8.4
  21:ProgrammingSteps.c **** *	CY8CKIT-050
  22:ProgrammingSteps.c **** *
  23:ProgrammingSteps.c **** *******************************************************************************
  24:ProgrammingSteps.c **** * Copyright (2015), Cypress Semiconductor Corporation.
  25:ProgrammingSteps.c **** *******************************************************************************
  26:ProgrammingSteps.c **** * This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  27:ProgrammingSteps.c **** * protected by and subject to worldwide patent protection (United States and
  28:ProgrammingSteps.c **** * foreign), United States copyright laws and international treaty provisions.
  29:ProgrammingSteps.c **** * Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
  30:ProgrammingSteps.c **** * license to copy, use, modify, create derivative works of, and compile the
  31:ProgrammingSteps.c **** * Cypress Source Code and derivative works for the sole purpose of creating
  32:ProgrammingSteps.c **** * custom software in support of licensee product to be used only in conjunction
  33:ProgrammingSteps.c **** * with a Cypress integrated circuit as specified in the applicable agreement.
  34:ProgrammingSteps.c **** * Any reproduction, modification, translation, compilation, or representation
  35:ProgrammingSteps.c **** * of this software except as specified above is prohibited without the express
  36:ProgrammingSteps.c **** * written permission of Cypress.
  37:ProgrammingSteps.c **** *
  38:ProgrammingSteps.c **** * Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
  39:ProgrammingSteps.c **** * REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  40:ProgrammingSteps.c **** * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  41:ProgrammingSteps.c **** * Cypress reserves the right to make changes without further notice to the
  42:ProgrammingSteps.c **** * materials described herein. Cypress does not assume any liability arising out
  43:ProgrammingSteps.c **** * of the application or use of any product or circuit described herein. Cypress
  44:ProgrammingSteps.c **** * does not authorize its products for use as critical components in life-support
  45:ProgrammingSteps.c **** * systems where a malfunction or failure may reasonably be expected to result in
  46:ProgrammingSteps.c **** * significant injury to the user. The inclusion of Cypress' product in a life-
  47:ProgrammingSteps.c **** * support systems application implies that the manufacturer assumes all risk of
  48:ProgrammingSteps.c **** * such use and in doing so indemnifies Cypress against all charges. Use may be
  49:ProgrammingSteps.c **** * limited by and subject to the applicable Cypress software license agreement.
  50:ProgrammingSteps.c **** ******************************************************************************/
  51:ProgrammingSteps.c **** 
  52:ProgrammingSteps.c **** /******************************************************************************
  53:ProgrammingSteps.c **** *   Header file Inclusion
  54:ProgrammingSteps.c **** ******************************************************************************/
  55:ProgrammingSteps.c **** #include "ProgrammingSteps.h"
  56:ProgrammingSteps.c **** #include "SWD_PhysicalLayer.h"
  57:ProgrammingSteps.c **** #include "SWD_UpperPacketLayer.h"
  58:ProgrammingSteps.c **** #include "SWD_PacketLayer.h"
  59:ProgrammingSteps.c **** #include "DataFetch.h"
  60:ProgrammingSteps.c **** #include "Timeout.h"
  61:ProgrammingSteps.c **** #include "project.h"
  62:ProgrammingSteps.c **** 
  63:ProgrammingSteps.c **** /******************************************************************************
  64:ProgrammingSteps.c **** *   Global Variable definitions
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 3


  65:ProgrammingSteps.c **** ******************************************************************************/
  66:ProgrammingSteps.c **** unsigned long checksum_Privileged 		= 0;
  67:ProgrammingSteps.c **** unsigned long statusCode 				= 0;
  68:ProgrammingSteps.c **** 
  69:ProgrammingSteps.c **** unsigned char result 					= 0;
  70:ProgrammingSteps.c **** unsigned char chipProtectionData_Chip	= 0;
  71:ProgrammingSteps.c **** 
  72:ProgrammingSteps.c **** enum Transition_mode {OPEN_XXX, VIRGIN_OPEN, PROT_XXX, WRONG_TRANSITION } flow;
  73:ProgrammingSteps.c **** 
  74:ProgrammingSteps.c **** /******************************************************************************
  75:ProgrammingSteps.c **** *   Function Definitions
  76:ProgrammingSteps.c **** ******************************************************************************/
  77:ProgrammingSteps.c **** 
  78:ProgrammingSteps.c **** 
  79:ProgrammingSteps.c **** /******************************************************************************
  80:ProgrammingSteps.c **** * Function Name: PollSromStatus
  81:ProgrammingSteps.c **** *******************************************************************************
  82:ProgrammingSteps.c **** * Summary:
  83:ProgrammingSteps.c **** *  Polls the SROM_SYSREQ_BIT and SROM_PRIVILEGED_BIT in the CPUSS_SYSREQ 
  84:ProgrammingSteps.c **** *  register till it is reset or a timeout condition occurred, whichever is 
  85:ProgrammingSteps.c **** *  earlier. For a SROM polling timeout error, the timeout error status bit is 
  86:ProgrammingSteps.c **** *  set in swd_PacketAck variable and CPUSS_SYSARG register is read to get the 
  87:ProgrammingSteps.c **** *  error status code. If timeout does not happen, the CPUSS_SYSARG register is 
  88:ProgrammingSteps.c **** *  read to determine if the task executed successfully.
  89:ProgrammingSteps.c **** *
  90:ProgrammingSteps.c **** * Parameters:
  91:ProgrammingSteps.c **** *  None.
  92:ProgrammingSteps.c **** *
  93:ProgrammingSteps.c **** * Return:
  94:ProgrammingSteps.c **** *  SUCCESS - SROM executed the task successfully
  95:ProgrammingSteps.c **** *  FAILURE - SROM task is not executed successfully and a timeout error occured.
  96:ProgrammingSteps.c **** *            The failure code is stored in the statusCode global variable.
  97:ProgrammingSteps.c **** *
  98:ProgrammingSteps.c **** * Note:
  99:ProgrammingSteps.c **** *  This function is called after non volatile memory operations like Read,  
 100:ProgrammingSteps.c **** *  Write of Flash, to check if SROM task has been executed which is indicated
 101:ProgrammingSteps.c **** *  by SUCCESS. The status is read from the CPUSS_SYSARG register.
 102:ProgrammingSteps.c **** *
 103:ProgrammingSteps.c **** ******************************************************************************/
 104:ProgrammingSteps.c **** unsigned char PollSromStatus(void)
 105:ProgrammingSteps.c **** {
  51              		.loc 1 105 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 8
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55 0000 80B5     		push	{r7, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 82B0     		sub	sp, sp, #8
  60              		.cfi_def_cfa_offset 16
  61 0004 00AF     		add	r7, sp, #0
  62              		.cfi_def_cfa_register 7
 106:ProgrammingSteps.c ****     unsigned long time_elapsed = 0;
  63              		.loc 1 106 0
  64 0006 0023     		movs	r3, #0
  65 0008 7B60     		str	r3, [r7, #4]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 4


  66              	.L3:
 107:ProgrammingSteps.c ****     
 108:ProgrammingSteps.c ****     do
 109:ProgrammingSteps.c ****     {
 110:ProgrammingSteps.c **** 	    /* Read CPUSS_SYSREQ register and check if SROM_SYSREQ_BIT and 
 111:ProgrammingSteps.c **** 		SROM_PRIVILEGED_BIT are reset to 0 */
 112:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSREQ, &statusCode);
  67              		.loc 1 112 0 discriminator 2
  68 000a 2048     		ldr	r0, .L7
  69 000c 2049     		ldr	r1, .L7+4
  70 000e FFF7FEFF 		bl	Read_IO
 113:ProgrammingSteps.c **** 		
 114:ProgrammingSteps.c **** 		statusCode &= (SROM_SYSREQ_BIT | SROM_PRIVILEGED_BIT);
  71              		.loc 1 114 0 discriminator 2
  72 0012 1F4B     		ldr	r3, .L7+4
  73 0014 1B68     		ldr	r3, [r3]
  74 0016 03F01043 		and	r3, r3, #-1879048192
  75 001a 1D4A     		ldr	r2, .L7+4
  76 001c 1360     		str	r3, [r2]
 115:ProgrammingSteps.c **** 	    
 116:ProgrammingSteps.c **** 		time_elapsed++;
  77              		.loc 1 116 0 discriminator 2
  78 001e 7B68     		ldr	r3, [r7, #4]
  79 0020 0133     		adds	r3, r3, #1
  80 0022 7B60     		str	r3, [r7, #4]
 117:ProgrammingSteps.c **** 		
 118:ProgrammingSteps.c ****     }while ((statusCode != 0) && (time_elapsed <= SROM_POLLING_TIMEOUT));
  81              		.loc 1 118 0 discriminator 2
  82 0024 1A4B     		ldr	r3, .L7+4
  83 0026 1B68     		ldr	r3, [r3]
  84 0028 002B     		cmp	r3, #0
  85 002a 04D0     		beq	.L2
  86              		.loc 1 118 0 is_stmt 0 discriminator 1
  87 002c 7B68     		ldr	r3, [r7, #4]
  88 002e 42F6B002 		movw	r2, #10416
  89 0032 9342     		cmp	r3, r2
  90 0034 E9D9     		bls	.L3
  91              	.L2:
 119:ProgrammingSteps.c **** 	
 120:ProgrammingSteps.c **** 	/* If time exceeds the timeout value, set the SROM_TIMEOUT_ERROR bit in 
 121:ProgrammingSteps.c **** 	   swd_PacketAck */
 122:ProgrammingSteps.c ****     if (time_elapsed > SROM_POLLING_TIMEOUT )
  92              		.loc 1 122 0 is_stmt 1
  93 0036 7B68     		ldr	r3, [r7, #4]
  94 0038 42F6B002 		movw	r2, #10416
  95 003c 9342     		cmp	r3, r2
  96 003e 0CD9     		bls	.L4
 123:ProgrammingSteps.c ****     {
 124:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
  97              		.loc 1 124 0
  98 0040 144B     		ldr	r3, .L7+8
  99 0042 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 100 0044 43F02003 		orr	r3, r3, #32
 101 0048 DAB2     		uxtb	r2, r3
 102 004a 124B     		ldr	r3, .L7+8
 103 004c 1A70     		strb	r2, [r3]
 125:ProgrammingSteps.c **** 		
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 5


 126:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSARG, &statusCode);
 104              		.loc 1 126 0
 105 004e 1248     		ldr	r0, .L7+12
 106 0050 0F49     		ldr	r1, .L7+4
 107 0052 FFF7FEFF 		bl	Read_IO
 127:ProgrammingSteps.c **** 	    
 128:ProgrammingSteps.c **** 		return (FAILURE);
 108              		.loc 1 128 0
 109 0056 0023     		movs	r3, #0
 110 0058 14E0     		b	.L5
 111              	.L4:
 129:ProgrammingSteps.c ****     }
 130:ProgrammingSteps.c **** 	
 131:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to check if the SROM command executed 
 132:ProgrammingSteps.c **** 	successfully else set SROM_TIMEOUT_ERROR in swd_PacketAck */
 133:ProgrammingSteps.c **** 	Read_IO (CPUSS_SYSARG, &statusCode);
 112              		.loc 1 133 0
 113 005a 0F48     		ldr	r0, .L7+12
 114 005c 0C49     		ldr	r1, .L7+4
 115 005e FFF7FEFF 		bl	Read_IO
 134:ProgrammingSteps.c **** 	
 135:ProgrammingSteps.c **** 	if ((statusCode & SROM_STATUS_SUCCESS_MASK) != SROM_STATUS_SUCCEEDED)
 116              		.loc 1 135 0
 117 0062 0B4B     		ldr	r3, .L7+4
 118 0064 1B68     		ldr	r3, [r3]
 119 0066 03F07043 		and	r3, r3, #-268435456
 120 006a B3F1204F 		cmp	r3, #-1610612736
 121 006e 08D0     		beq	.L6
 136:ProgrammingSteps.c **** 	{
 137:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
 122              		.loc 1 137 0
 123 0070 084B     		ldr	r3, .L7+8
 124 0072 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 125 0074 43F02003 		orr	r3, r3, #32
 126 0078 DAB2     		uxtb	r2, r3
 127 007a 064B     		ldr	r3, .L7+8
 128 007c 1A70     		strb	r2, [r3]
 138:ProgrammingSteps.c **** 		
 139:ProgrammingSteps.c **** 		return (FAILURE);
 129              		.loc 1 139 0
 130 007e 0023     		movs	r3, #0
 131 0080 00E0     		b	.L5
 132              	.L6:
 140:ProgrammingSteps.c ****     }
 141:ProgrammingSteps.c **** 	else
 142:ProgrammingSteps.c **** 	    return (SUCCESS);
 133              		.loc 1 142 0
 134 0082 0123     		movs	r3, #1
 135              	.L5:
 143:ProgrammingSteps.c **** 
 144:ProgrammingSteps.c **** }
 136              		.loc 1 144 0
 137 0084 1846     		mov	r0, r3
 138 0086 0837     		adds	r7, r7, #8
 139              		.cfi_def_cfa_offset 8
 140 0088 BD46     		mov	sp, r7
 141              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 6


 142              		@ sp needed
 143 008a 80BD     		pop	{r7, pc}
 144              	.L8:
 145              		.align	2
 146              	.L7:
 147 008c 04001040 		.word	1074790404
 148 0090 00000000 		.word	statusCode
 149 0094 00000000 		.word	swd_PacketAck
 150 0098 08001040 		.word	1074790408
 151              		.cfi_endproc
 152              	.LFE63:
 153              		.size	PollSromStatus, .-PollSromStatus
 154              		.section	.text.SetIMO48MHz,"ax",%progbits
 155              		.align	2
 156              		.global	SetIMO48MHz
 157              		.thumb
 158              		.thumb_func
 159              		.type	SetIMO48MHz, %function
 160              	SetIMO48MHz:
 161              	.LFB64:
 145:ProgrammingSteps.c **** #if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY)
 146:ProgrammingSteps.c **** /******************************************************************************
 147:ProgrammingSteps.c **** * Function Name: SetIMO48MHz
 148:ProgrammingSteps.c **** *******************************************************************************
 149:ProgrammingSteps.c **** * Summary:
 150:ProgrammingSteps.c **** * Set IMO to 48 MHz 
 151:ProgrammingSteps.c **** *
 152:ProgrammingSteps.c **** * Parameters:
 153:ProgrammingSteps.c **** *  None.
 154:ProgrammingSteps.c **** *
 155:ProgrammingSteps.c **** * Return:
 156:ProgrammingSteps.c **** *  None
 157:ProgrammingSteps.c **** *
 158:ProgrammingSteps.c **** * Note:
 159:ProgrammingSteps.c **** *  This function is required to be called before any flash operation.
 160:ProgrammingSteps.c **** *  This function sets the IMO to 48 MHz before flash write/erase operations
 161:ProgrammingSteps.c **** *  and is part of the device acquire routine.
 162:ProgrammingSteps.c **** *
 163:ProgrammingSteps.c **** ******************************************************************************/
 164:ProgrammingSteps.c **** void SetIMO48MHz(void)
 165:ProgrammingSteps.c **** {    
 162              		.loc 1 165 0
 163              		.cfi_startproc
 164              		@ args = 0, pretend = 0, frame = 8
 165              		@ frame_needed = 1, uses_anonymous_args = 0
 166 0000 80B5     		push	{r7, lr}
 167              		.cfi_def_cfa_offset 8
 168              		.cfi_offset 7, -8
 169              		.cfi_offset 14, -4
 170 0002 82B0     		sub	sp, sp, #8
 171              		.cfi_def_cfa_offset 16
 172 0004 00AF     		add	r7, sp, #0
 173              		.cfi_def_cfa_register 7
 166:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 174              		.loc 1 166 0
 175 0006 0023     		movs	r3, #0
 176 0008 7B60     		str	r3, [r7, #4]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 7


 167:ProgrammingSteps.c **** 	
 168:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 169:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 177              		.loc 1 169 0
 178 000a 4EF6B603 		movw	r3, #59574
 179 000e 7B60     		str	r3, [r7, #4]
 170:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_SET_IMO_48MHZ) << 8));
 171:ProgrammingSteps.c **** 	
 172:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 173:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 180              		.loc 1 173 0
 181 0010 0548     		ldr	r0, .L10
 182 0012 7968     		ldr	r1, [r7, #4]
 183 0014 FFF7FEFF 		bl	Write_IO
 174:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_SET_IMO_48MHZ);
 184              		.loc 1 174 0
 185 0018 0448     		ldr	r0, .L10+4
 186 001a 0549     		ldr	r1, .L10+8
 187 001c FFF7FEFF 		bl	Write_IO
 175:ProgrammingSteps.c **** }
 188              		.loc 1 175 0
 189 0020 0837     		adds	r7, r7, #8
 190              		.cfi_def_cfa_offset 8
 191 0022 BD46     		mov	sp, r7
 192              		.cfi_def_cfa_register 13
 193              		@ sp needed
 194 0024 80BD     		pop	{r7, pc}
 195              	.L11:
 196 0026 00BF     		.align	2
 197              	.L10:
 198 0028 08001040 		.word	1074790408
 199 002c 04001040 		.word	1074790404
 200 0030 15000080 		.word	-2147483627
 201              		.cfi_endproc
 202              	.LFE64:
 203              		.size	SetIMO48MHz, .-SetIMO48MHz
 204              		.section	.text.ReadSromStatus,"ax",%progbits
 205              		.align	2
 206              		.global	ReadSromStatus
 207              		.thumb
 208              		.thumb_func
 209              		.type	ReadSromStatus, %function
 210              	ReadSromStatus:
 211              	.LFB65:
 176:ProgrammingSteps.c **** #endif
 177:ProgrammingSteps.c **** /******************************************************************************
 178:ProgrammingSteps.c **** * Function Name: ReadSromStatus
 179:ProgrammingSteps.c **** *******************************************************************************
 180:ProgrammingSteps.c **** *
 181:ProgrammingSteps.c **** * Summary:
 182:ProgrammingSteps.c **** *  It reads the StatusCode global variable and returns LSB of this long variable
 183:ProgrammingSteps.c **** *  to main.c.
 184:ProgrammingSteps.c **** *
 185:ProgrammingSteps.c **** * Parameters:
 186:ProgrammingSteps.c **** *  None.
 187:ProgrammingSteps.c **** *
 188:ProgrammingSteps.c **** * Return:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 8


 189:ProgrammingSteps.c **** * LSB of statusCode - LSB of statusCode global variable contains the error code
 190:ProgrammingSteps.c **** *
 191:ProgrammingSteps.c **** * Note:
 192:ProgrammingSteps.c **** * This function is called from main.c when SROM_TIMEOUT_ERROR bit is set in the
 193:ProgrammingSteps.c **** * swd_PacketAck. 
 194:ProgrammingSteps.c **** *
 195:ProgrammingSteps.c **** ******************************************************************************/
 196:ProgrammingSteps.c **** 
 197:ProgrammingSteps.c **** unsigned char ReadSromStatus(void)
 198:ProgrammingSteps.c **** {
 212              		.loc 1 198 0
 213              		.cfi_startproc
 214              		@ args = 0, pretend = 0, frame = 0
 215              		@ frame_needed = 1, uses_anonymous_args = 0
 216              		@ link register save eliminated.
 217 0000 80B4     		push	{r7}
 218              		.cfi_def_cfa_offset 4
 219              		.cfi_offset 7, -4
 220 0002 00AF     		add	r7, sp, #0
 221              		.cfi_def_cfa_register 7
 199:ProgrammingSteps.c **** 	return((unsigned char)statusCode);
 222              		.loc 1 199 0
 223 0004 034B     		ldr	r3, .L14
 224 0006 1B68     		ldr	r3, [r3]
 225 0008 DBB2     		uxtb	r3, r3
 200:ProgrammingSteps.c **** }
 226              		.loc 1 200 0
 227 000a 1846     		mov	r0, r3
 228 000c BD46     		mov	sp, r7
 229              		.cfi_def_cfa_register 13
 230              		@ sp needed
 231 000e 5DF8047B 		ldr	r7, [sp], #4
 232              		.cfi_restore 7
 233              		.cfi_def_cfa_offset 0
 234 0012 7047     		bx	lr
 235              	.L15:
 236              		.align	2
 237              	.L14:
 238 0014 00000000 		.word	statusCode
 239              		.cfi_endproc
 240              	.LFE65:
 241              		.size	ReadSromStatus, .-ReadSromStatus
 242              		.section	.text.GetChipProtectionVal,"ax",%progbits
 243              		.align	2
 244              		.global	GetChipProtectionVal
 245              		.thumb
 246              		.thumb_func
 247              		.type	GetChipProtectionVal, %function
 248              	GetChipProtectionVal:
 249              	.LFB66:
 201:ProgrammingSteps.c **** 
 202:ProgrammingSteps.c **** /******************************************************************************
 203:ProgrammingSteps.c **** * Function Name: GetChipProtectionVal
 204:ProgrammingSteps.c **** *******************************************************************************
 205:ProgrammingSteps.c **** * Summary:
 206:ProgrammingSteps.c **** *  This sub-routine is used to read the Chip Protection Setting by using SROM 
 207:ProgrammingSteps.c **** *  System Calls. System call to read Silicon Id returns Chip protection settings
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 9


 208:ProgrammingSteps.c **** *  in the CPUSS_SYSREQ register. The location of the data is bit [15:12] in the
 209:ProgrammingSteps.c **** *  32-bit register.
 210:ProgrammingSteps.c **** *
 211:ProgrammingSteps.c **** * Parameters:
 212:ProgrammingSteps.c **** *  None.
 213:ProgrammingSteps.c **** *
 214:ProgrammingSteps.c **** * Return:
 215:ProgrammingSteps.c **** *  chipProtectionData_Chip - 1 byte chip protection setting read from the chip
 216:ProgrammingSteps.c **** *
 217:ProgrammingSteps.c **** * Note:
 218:ProgrammingSteps.c **** * This function is called in the "Step 3. Erase All Flash" to read the chip
 219:ProgrammingSteps.c **** * protection settings to take decision whether to move the protection state
 220:ProgrammingSteps.c **** *  to open and then erase the flash or directly erase the flash.
 221:ProgrammingSteps.c **** *
 222:ProgrammingSteps.c **** ******************************************************************************/
 223:ProgrammingSteps.c **** unsigned char GetChipProtectionVal(void)
 224:ProgrammingSteps.c **** {
 250              		.loc 1 224 0
 251              		.cfi_startproc
 252              		@ args = 0, pretend = 0, frame = 8
 253              		@ frame_needed = 1, uses_anonymous_args = 0
 254 0000 80B5     		push	{r7, lr}
 255              		.cfi_def_cfa_offset 8
 256              		.cfi_offset 7, -8
 257              		.cfi_offset 14, -4
 258 0002 82B0     		sub	sp, sp, #8
 259              		.cfi_def_cfa_offset 16
 260 0004 00AF     		add	r7, sp, #0
 261              		.cfi_def_cfa_register 7
 225:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 262              		.loc 1 225 0
 263 0006 0023     		movs	r3, #0
 264 0008 7B60     		str	r3, [r7, #4]
 226:ProgrammingSteps.c **** 	unsigned long chipProtData 		= 0;
 265              		.loc 1 226 0
 266 000a 0023     		movs	r3, #0
 267 000c 3B60     		str	r3, [r7]
 227:ProgrammingSteps.c **** 	
 228:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 229:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 268              		.loc 1 229 0
 269 000e 4DF2B633 		movw	r3, #54198
 270 0012 7B60     		str	r3, [r7, #4]
 230:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 231:ProgrammingSteps.c **** 	
 232:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 233:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 271              		.loc 1 233 0
 272 0014 1A48     		ldr	r0, .L23
 273 0016 7968     		ldr	r1, [r7, #4]
 274 0018 FFF7FEFF 		bl	Write_IO
 234:ProgrammingSteps.c ****     
 235:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 275              		.loc 1 235 0
 276 001c 194B     		ldr	r3, .L23+4
 277 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 278 0020 012B     		cmp	r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 10


 279 0022 01D0     		beq	.L17
 236:ProgrammingSteps.c ****     {
 237:ProgrammingSteps.c ****         return(FAILURE);
 280              		.loc 1 237 0
 281 0024 0023     		movs	r3, #0
 282 0026 27E0     		b	.L22
 283              	.L17:
 238:ProgrammingSteps.c ****     }
 239:ProgrammingSteps.c **** 	
 240:ProgrammingSteps.c **** 	/* Request system call by writing to CPUSS_SYSREQ register */
 241:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 284              		.loc 1 241 0
 285 0028 1748     		ldr	r0, .L23+8
 286 002a 4FF00041 		mov	r1, #-2147483648
 287 002e FFF7FEFF 		bl	Write_IO
 242:ProgrammingSteps.c ****     
 243:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 288              		.loc 1 243 0
 289 0032 144B     		ldr	r3, .L23+4
 290 0034 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 291 0036 012B     		cmp	r3, #1
 292 0038 01D0     		beq	.L19
 244:ProgrammingSteps.c ****     {
 245:ProgrammingSteps.c ****         return(FAILURE);
 293              		.loc 1 245 0
 294 003a 0023     		movs	r3, #0
 295 003c 1CE0     		b	.L22
 296              	.L19:
 246:ProgrammingSteps.c ****     }
 247:ProgrammingSteps.c **** 	
 248:ProgrammingSteps.c **** 	/* Read status of the operation */
 249:ProgrammingSteps.c ****     result = PollSromStatus();
 297              		.loc 1 249 0
 298 003e FFF7FEFF 		bl	PollSromStatus
 299 0042 0346     		mov	r3, r0
 300 0044 1A46     		mov	r2, r3
 301 0046 114B     		ldr	r3, .L23+12
 302 0048 1A70     		strb	r2, [r3]
 250:ProgrammingSteps.c ****     
 251:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 303              		.loc 1 251 0
 304 004a 104B     		ldr	r3, .L23+12
 305 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 306 004e 012B     		cmp	r3, #1
 307 0050 01D0     		beq	.L20
 252:ProgrammingSteps.c ****     {
 253:ProgrammingSteps.c ****         return(FAILURE);
 308              		.loc 1 253 0
 309 0052 0023     		movs	r3, #0
 310 0054 10E0     		b	.L22
 311              	.L20:
 254:ProgrammingSteps.c ****     }
 255:ProgrammingSteps.c **** 	
 256:ProgrammingSteps.c **** 	/* Read CPUSS_SYSREQ register to get the current protection setting of the
 257:ProgrammingSteps.c **** 	   chip */
 258:ProgrammingSteps.c ****     Read_IO( CPUSS_SYSREQ, &chipProtData);
 312              		.loc 1 258 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 11


 313 0056 3B46     		mov	r3, r7
 314 0058 0B48     		ldr	r0, .L23+8
 315 005a 1946     		mov	r1, r3
 316 005c FFF7FEFF 		bl	Read_IO
 259:ProgrammingSteps.c ****     
 260:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 317              		.loc 1 260 0
 318 0060 084B     		ldr	r3, .L23+4
 319 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 320 0064 012B     		cmp	r3, #1
 321 0066 01D0     		beq	.L21
 261:ProgrammingSteps.c ****     {
 262:ProgrammingSteps.c ****         return(FAILURE);
 322              		.loc 1 262 0
 323 0068 0023     		movs	r3, #0
 324 006a 05E0     		b	.L22
 325              	.L21:
 263:ProgrammingSteps.c ****     }
 264:ProgrammingSteps.c **** 
 265:ProgrammingSteps.c ****     chipProtectionData_Chip = (unsigned char)(chipProtData >> 12);
 326              		.loc 1 265 0
 327 006c 3B68     		ldr	r3, [r7]
 328 006e 1B0B     		lsrs	r3, r3, #12
 329 0070 DAB2     		uxtb	r2, r3
 330 0072 074B     		ldr	r3, .L23+16
 331 0074 1A70     		strb	r2, [r3]
 266:ProgrammingSteps.c **** 	
 267:ProgrammingSteps.c **** 	return(SUCCESS);
 332              		.loc 1 267 0
 333 0076 0123     		movs	r3, #1
 334              	.L22:
 268:ProgrammingSteps.c **** }
 335              		.loc 1 268 0 discriminator 1
 336 0078 1846     		mov	r0, r3
 337 007a 0837     		adds	r7, r7, #8
 338              		.cfi_def_cfa_offset 8
 339 007c BD46     		mov	sp, r7
 340              		.cfi_def_cfa_register 13
 341              		@ sp needed
 342 007e 80BD     		pop	{r7, pc}
 343              	.L24:
 344              		.align	2
 345              	.L23:
 346 0080 08001040 		.word	1074790408
 347 0084 00000000 		.word	swd_PacketAck
 348 0088 04001040 		.word	1074790404
 349 008c 00000000 		.word	result
 350 0090 00000000 		.word	chipProtectionData_Chip
 351              		.cfi_endproc
 352              	.LFE66:
 353              		.size	GetChipProtectionVal, .-GetChipProtectionVal
 354              		.section	.text.GetTransitionMode,"ax",%progbits
 355              		.align	2
 356              		.global	GetTransitionMode
 357              		.thumb
 358              		.thumb_func
 359              		.type	GetTransitionMode, %function
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 12


 360              	GetTransitionMode:
 361              	.LFB67:
 269:ProgrammingSteps.c **** 
 270:ProgrammingSteps.c **** /******************************************************************************
 271:ProgrammingSteps.c **** * Function Name: GetTransitionMode
 272:ProgrammingSteps.c **** *******************************************************************************
 273:ProgrammingSteps.c **** *
 274:ProgrammingSteps.c **** * Summary:
 275:ProgrammingSteps.c **** *  It reads the chipProtectionData_Chip global variable which contains the Chip
 276:ProgrammingSteps.c **** *  protection setting stored in the Chip and chipProtectionData_Hex from the 
 277:ProgrammingSteps.c **** *  hex file which contains the Chip protection setting stored in the HEX file. 
 278:ProgrammingSteps.c **** *  The function then validates if the two settings correspond to a valid
 279:ProgrammingSteps.c **** *  transition.
 280:ProgrammingSteps.c **** *
 281:ProgrammingSteps.c **** * Parameters:
 282:ProgrammingSteps.c **** *  None.
 283:ProgrammingSteps.c **** *
 284:ProgrammingSteps.c **** * Return:
 285:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the transition is valid.
 286:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the transition is invalid.
 287:ProgrammingSteps.c **** *  Stores the transition in the global enum flow.
 288:ProgrammingSteps.c **** *
 289:ProgrammingSteps.c **** * Note:
 290:ProgrammingSteps.c **** * This function is called in "Step 3. Erase All Flash" to take decision on
 291:ProgrammingSteps.c **** * basis of the global enum flow.
 292:ProgrammingSteps.c **** *
 293:ProgrammingSteps.c **** ******************************************************************************/
 294:ProgrammingSteps.c **** unsigned char GetTransitionMode(void)
 295:ProgrammingSteps.c **** {
 362              		.loc 1 295 0
 363              		.cfi_startproc
 364              		@ args = 0, pretend = 0, frame = 8
 365              		@ frame_needed = 1, uses_anonymous_args = 0
 366 0000 80B5     		push	{r7, lr}
 367              		.cfi_def_cfa_offset 8
 368              		.cfi_offset 7, -8
 369              		.cfi_offset 14, -4
 370 0002 82B0     		sub	sp, sp, #8
 371              		.cfi_def_cfa_offset 16
 372 0004 00AF     		add	r7, sp, #0
 373              		.cfi_def_cfa_register 7
 296:ProgrammingSteps.c **** 	unsigned char chipProtectionData_Hex;
 297:ProgrammingSteps.c **** 	
 298:ProgrammingSteps.c **** 	/* Get the chip protection setting in the HEX file */
 299:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 374              		.loc 1 299 0
 375 0006 FB1D     		adds	r3, r7, #7
 376 0008 1846     		mov	r0, r3
 377 000a FFF7FEFF 		bl	HEX_ReadChipProtectionData
 300:ProgrammingSteps.c **** 	
 301:ProgrammingSteps.c **** 	/* enum variable flow stores the transition (current protection setting to 
 302:ProgrammingSteps.c **** 	   setting in hex file) of the chip */
 303:ProgrammingSteps.c **** 	flow = WRONG_TRANSITION;
 378              		.loc 1 303 0
 379 000e 224B     		ldr	r3, .L42
 380 0010 0322     		movs	r2, #3
 381 0012 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 13


 304:ProgrammingSteps.c **** 	
 305:ProgrammingSteps.c **** 	switch (chipProtectionData_Chip)
 382              		.loc 1 305 0
 383 0014 214B     		ldr	r3, .L42+4
 384 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 385 0018 012B     		cmp	r3, #1
 386 001a 0ED0     		beq	.L27
 387 001c 022B     		cmp	r3, #2
 388 001e 17D0     		beq	.L28
 389 0020 002B     		cmp	r3, #0
 390 0022 23D1     		bne	.L41
 306:ProgrammingSteps.c **** 	{
 307:ProgrammingSteps.c **** 		/* virgin to open protection setting is the only allowed transition */
 308:ProgrammingSteps.c **** 		case CHIP_PROT_VIRGIN:
 309:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_OPEN)
 391              		.loc 1 309 0
 392 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 393 0026 012B     		cmp	r3, #1
 394 0028 03D1     		bne	.L30
 310:ProgrammingSteps.c ****                 flow = VIRGIN_OPEN;
 395              		.loc 1 310 0
 396 002a 1B4B     		ldr	r3, .L42
 397 002c 0122     		movs	r2, #1
 398 002e 1A70     		strb	r2, [r3]
 311:ProgrammingSteps.c ****             else
 312:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 313:ProgrammingSteps.c ****             break;
 399              		.loc 1 313 0
 400 0030 20E0     		b	.L32
 401              	.L30:
 312:ProgrammingSteps.c ****             break;
 402              		.loc 1 312 0
 403 0032 194B     		ldr	r3, .L42
 404 0034 0322     		movs	r2, #3
 405 0036 1A70     		strb	r2, [r3]
 406              		.loc 1 313 0
 407 0038 1CE0     		b	.L32
 408              	.L27:
 314:ProgrammingSteps.c **** 		
 315:ProgrammingSteps.c **** 		/* All transitions from Open are allowed other than transition to virgin
 316:ProgrammingSteps.c **** 		   mode */
 317:ProgrammingSteps.c **** 		case CHIP_PROT_OPEN:
 318:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_VIRGIN)
 409              		.loc 1 318 0
 410 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 411 003c 002B     		cmp	r3, #0
 412 003e 03D1     		bne	.L33
 319:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 413              		.loc 1 319 0
 414 0040 154B     		ldr	r3, .L42
 415 0042 0322     		movs	r2, #3
 416 0044 1A70     		strb	r2, [r3]
 320:ProgrammingSteps.c ****             else
 321:ProgrammingSteps.c ****                 flow = OPEN_XXX;
 322:ProgrammingSteps.c ****             break;
 417              		.loc 1 322 0
 418 0046 15E0     		b	.L32
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 14


 419              	.L33:
 321:ProgrammingSteps.c ****             break;
 420              		.loc 1 321 0
 421 0048 134B     		ldr	r3, .L42
 422 004a 0022     		movs	r2, #0
 423 004c 1A70     		strb	r2, [r3]
 424              		.loc 1 322 0
 425 004e 11E0     		b	.L32
 426              	.L28:
 323:ProgrammingSteps.c ****         
 324:ProgrammingSteps.c **** 		/* Protected to Protected and Protected to Open are the allowed
 325:ProgrammingSteps.c **** 		   transitions */
 326:ProgrammingSteps.c **** 		case CHIP_PROT_PROTECTED:
 327:ProgrammingSteps.c ****             if ((chipProtectionData_Hex == CHIP_PROT_OPEN) || (chipProtectionData_Hex == CHIP_PROT_
 427              		.loc 1 327 0
 428 0050 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 429 0052 012B     		cmp	r3, #1
 430 0054 02D0     		beq	.L35
 431              		.loc 1 327 0 is_stmt 0 discriminator 1
 432 0056 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 433 0058 022B     		cmp	r3, #2
 434 005a 03D1     		bne	.L36
 435              	.L35:
 328:ProgrammingSteps.c ****                 flow = PROT_XXX;
 436              		.loc 1 328 0 is_stmt 1
 437 005c 0E4B     		ldr	r3, .L42
 438 005e 0222     		movs	r2, #2
 439 0060 1A70     		strb	r2, [r3]
 329:ProgrammingSteps.c ****             else
 330:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 331:ProgrammingSteps.c ****             break;
 440              		.loc 1 331 0
 441 0062 07E0     		b	.L32
 442              	.L36:
 330:ProgrammingSteps.c ****             break;
 443              		.loc 1 330 0
 444 0064 0C4B     		ldr	r3, .L42
 445 0066 0322     		movs	r2, #3
 446 0068 1A70     		strb	r2, [r3]
 447              		.loc 1 331 0
 448 006a 03E0     		b	.L32
 449              	.L41:
 332:ProgrammingSteps.c ****         
 333:ProgrammingSteps.c **** 		default:
 334:ProgrammingSteps.c ****             flow = WRONG_TRANSITION;
 450              		.loc 1 334 0
 451 006c 0A4B     		ldr	r3, .L42
 452 006e 0322     		movs	r2, #3
 453 0070 1A70     		strb	r2, [r3]
 335:ProgrammingSteps.c ****             break;
 454              		.loc 1 335 0
 455 0072 00BF     		nop
 456              	.L32:
 336:ProgrammingSteps.c **** 	}
 337:ProgrammingSteps.c **** 	
 338:ProgrammingSteps.c **** 	/* Set TRANSITION_ERROR bit high in Swd_PacketAck to show wrong transition
 339:ProgrammingSteps.c **** 	   error */
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 15


 340:ProgrammingSteps.c **** 	if (flow == WRONG_TRANSITION)
 457              		.loc 1 340 0
 458 0074 084B     		ldr	r3, .L42
 459 0076 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 460 0078 032B     		cmp	r3, #3
 461 007a 08D1     		bne	.L38
 341:ProgrammingSteps.c **** 	{
 342:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | TRANSITION_ERROR;
 462              		.loc 1 342 0
 463 007c 084B     		ldr	r3, .L42+8
 464 007e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 465 0080 63F07F03 		orn	r3, r3, #127
 466 0084 DAB2     		uxtb	r2, r3
 467 0086 064B     		ldr	r3, .L42+8
 468 0088 1A70     		strb	r2, [r3]
 343:ProgrammingSteps.c **** 		return(FAILURE);
 469              		.loc 1 343 0
 470 008a 0023     		movs	r3, #0
 471 008c 00E0     		b	.L40
 472              	.L38:
 344:ProgrammingSteps.c **** 	}
 345:ProgrammingSteps.c **** 	return(SUCCESS);
 473              		.loc 1 345 0
 474 008e 0123     		movs	r3, #1
 475              	.L40:
 346:ProgrammingSteps.c **** }
 476              		.loc 1 346 0 discriminator 1
 477 0090 1846     		mov	r0, r3
 478 0092 0837     		adds	r7, r7, #8
 479              		.cfi_def_cfa_offset 8
 480 0094 BD46     		mov	sp, r7
 481              		.cfi_def_cfa_register 13
 482              		@ sp needed
 483 0096 80BD     		pop	{r7, pc}
 484              	.L43:
 485              		.align	2
 486              	.L42:
 487 0098 00000000 		.word	flow
 488 009c 00000000 		.word	chipProtectionData_Chip
 489 00a0 00000000 		.word	swd_PacketAck
 490              		.cfi_endproc
 491              	.LFE67:
 492              		.size	GetTransitionMode, .-GetTransitionMode
 493              		.section	.text.LoadLatch,"ax",%progbits
 494              		.align	2
 495              		.global	LoadLatch
 496              		.thumb
 497              		.thumb_func
 498              		.type	LoadLatch, %function
 499              	LoadLatch:
 500              	.LFB68:
 347:ProgrammingSteps.c **** 
 348:ProgrammingSteps.c **** /******************************************************************************
 349:ProgrammingSteps.c **** * Function Name: LoadLatch
 350:ProgrammingSteps.c **** *******************************************************************************
 351:ProgrammingSteps.c **** *
 352:ProgrammingSteps.c **** * Summary:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 16


 353:ProgrammingSteps.c **** *  This function loads the page latch buffer with data to be programmed in to a
 354:ProgrammingSteps.c **** *  row of flash (or flash protection area). Data is loaded into the page latch 
 355:ProgrammingSteps.c **** *  buffer starting at the location specified by the SRAM_PARAMS_BASE input parameter. 
 356:ProgrammingSteps.c **** *  Data loaded into the page latch buffer will remain until a program operation is 
 357:ProgrammingSteps.c **** *  performed, which clears the page latch contents.
 358:ProgrammingSteps.c **** *
 359:ProgrammingSteps.c **** * Parameters:
 360:ProgrammingSteps.c **** *  arrayID - Array Number of the flash
 361:ProgrammingSteps.c **** *  rowData - Array containing 128 bytes of programming data
 362:ProgrammingSteps.c **** *  rowByteSize - Number of bytes in the current row to be loaded using parameter2
 363:ProgrammingSteps.c **** *
 364:ProgrammingSteps.c **** * Return:
 365:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Data is successfully latched
 366:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Data is not latched successfully
 367:ProgrammingSteps.c **** *
 368:ProgrammingSteps.c **** * Note:
 369:ProgrammingSteps.c **** * This function is called in "Step 5. Program Flash" and 
 370:ProgrammingSteps.c **** * "Step 7. Program Protection Settings" to latch the programming data in SRAM.
 371:ProgrammingSteps.c **** *
 372:ProgrammingSteps.c **** ******************************************************************************/
 373:ProgrammingSteps.c **** unsigned char LoadLatch(unsigned char arrayID, unsigned char * rowData, unsigned short rowByteSize)
 374:ProgrammingSteps.c **** {
 501              		.loc 1 374 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 24
 504              		@ frame_needed = 1, uses_anonymous_args = 0
 505 0000 80B5     		push	{r7, lr}
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 7, -8
 508              		.cfi_offset 14, -4
 509 0002 86B0     		sub	sp, sp, #24
 510              		.cfi_def_cfa_offset 32
 511 0004 00AF     		add	r7, sp, #0
 512              		.cfi_def_cfa_register 7
 513 0006 0346     		mov	r3, r0
 514 0008 3960     		str	r1, [r7]
 515 000a FB71     		strb	r3, [r7, #7]
 516 000c 1346     		mov	r3, r2	@ movhi
 517 000e BB80     		strh	r3, [r7, #4]	@ movhi
 375:ProgrammingSteps.c **** 		unsigned long parameter1 = 0;
 518              		.loc 1 375 0
 519 0010 0023     		movs	r3, #0
 520 0012 3B61     		str	r3, [r7, #16]
 376:ProgrammingSteps.c **** 		unsigned long parameter2 = 0;
 521              		.loc 1 376 0
 522 0014 0023     		movs	r3, #0
 523 0016 FB60     		str	r3, [r7, #12]
 377:ProgrammingSteps.c **** 		unsigned short i = 0;
 524              		.loc 1 377 0
 525 0018 0023     		movs	r3, #0
 526 001a FB82     		strh	r3, [r7, #22]	@ movhi
 378:ProgrammingSteps.c **** 		
 379:ProgrammingSteps.c **** 		/* Load parameter1 with the SROM command to load the page latch buffer
 380:ProgrammingSteps.c **** 		   with programming data */
 381:ProgrammingSteps.c **** 		parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 382:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 383:ProgrammingSteps.c **** 					(0x00 << 16) + ((unsigned long)arrayID << 24);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 17


 527              		.loc 1 383 0
 528 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 529 001e 1B06     		lsls	r3, r3, #24
 381:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 530              		.loc 1 381 0
 531 0020 03F55743 		add	r3, r3, #55040
 532 0024 B633     		adds	r3, r3, #182
 533 0026 3B61     		str	r3, [r7, #16]
 384:ProgrammingSteps.c **** 		
 385:ProgrammingSteps.c **** 		/* Number of Bytes to load minus 1 */
 386:ProgrammingSteps.c **** 		parameter2 = (rowByteSize - 1);
 534              		.loc 1 386 0
 535 0028 BB88     		ldrh	r3, [r7, #4]
 536 002a 013B     		subs	r3, r3, #1
 537 002c FB60     		str	r3, [r7, #12]
 387:ProgrammingSteps.c **** 		
 388:ProgrammingSteps.c **** 		/* Write parameter1 in SRAM */
 389:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE + 0x00, parameter1);
 538              		.loc 1 389 0
 539 002e 3648     		ldr	r0, .L54
 540 0030 3969     		ldr	r1, [r7, #16]
 541 0032 FFF7FEFF 		bl	Write_IO
 390:ProgrammingSteps.c **** 		
 391:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 542              		.loc 1 391 0
 543 0036 354B     		ldr	r3, .L54+4
 544 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 545 003a 012B     		cmp	r3, #1
 546 003c 01D0     		beq	.L45
 392:ProgrammingSteps.c **** 	    {
 393:ProgrammingSteps.c **** 	        return (FAILURE);
 547              		.loc 1 393 0
 548 003e 0023     		movs	r3, #0
 549 0040 5DE0     		b	.L46
 550              	.L45:
 394:ProgrammingSteps.c **** 	    }
 395:ProgrammingSteps.c **** 	    
 396:ProgrammingSteps.c **** 		/* Write parameter2 in SRAM */
 397:ProgrammingSteps.c **** 		Write_IO(SRAM_PARAMS_BASE + 0x04, parameter2);
 551              		.loc 1 397 0
 552 0042 3348     		ldr	r0, .L54+8
 553 0044 F968     		ldr	r1, [r7, #12]
 554 0046 FFF7FEFF 		bl	Write_IO
 398:ProgrammingSteps.c **** 		
 399:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 555              		.loc 1 399 0
 556 004a 304B     		ldr	r3, .L54+4
 557 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 558 004e 012B     		cmp	r3, #1
 559 0050 01D0     		beq	.L47
 400:ProgrammingSteps.c **** 	    {
 401:ProgrammingSteps.c **** 	        return (FAILURE);
 560              		.loc 1 401 0
 561 0052 0023     		movs	r3, #0
 562 0054 53E0     		b	.L46
 563              	.L47:
 402:ProgrammingSteps.c **** 	    }
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 18


 403:ProgrammingSteps.c **** 		
 404:ProgrammingSteps.c **** 		/* Put row data into SRAM buffer */
 405:ProgrammingSteps.c **** 	    for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 564              		.loc 1 405 0
 565 0056 0023     		movs	r3, #0
 566 0058 FB82     		strh	r3, [r7, #22]	@ movhi
 567 005a 2CE0     		b	.L48
 568              	.L50:
 406:ProgrammingSteps.c **** 	    {
 407:ProgrammingSteps.c **** 	     	parameter1 = (rowData[i] << 0) + (rowData[i + 1] << 8) + (rowData[i + 2] << 16) + (rowData[i
 569              		.loc 1 407 0
 570 005c FB8A     		ldrh	r3, [r7, #22]
 571 005e 3A68     		ldr	r2, [r7]
 572 0060 1344     		add	r3, r3, r2
 573 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 574 0064 1946     		mov	r1, r3
 575 0066 FB8A     		ldrh	r3, [r7, #22]
 576 0068 0133     		adds	r3, r3, #1
 577 006a 3A68     		ldr	r2, [r7]
 578 006c 1344     		add	r3, r3, r2
 579 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 580 0070 1B02     		lsls	r3, r3, #8
 581 0072 CA18     		adds	r2, r1, r3
 582 0074 FB8A     		ldrh	r3, [r7, #22]
 583 0076 0233     		adds	r3, r3, #2
 584 0078 3968     		ldr	r1, [r7]
 585 007a 0B44     		add	r3, r3, r1
 586 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 587 007e 1B04     		lsls	r3, r3, #16
 588 0080 1A44     		add	r2, r2, r3
 589 0082 FB8A     		ldrh	r3, [r7, #22]
 590 0084 0333     		adds	r3, r3, #3
 591 0086 3968     		ldr	r1, [r7]
 592 0088 0B44     		add	r3, r3, r1
 593 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 594 008c 1B06     		lsls	r3, r3, #24
 595 008e 1344     		add	r3, r3, r2
 596 0090 3B61     		str	r3, [r7, #16]
 408:ProgrammingSteps.c **** 	        
 409:ProgrammingSteps.c **** 			/* Write parameter1 in SRAM */
 410:ProgrammingSteps.c **** 			Write_IO(SRAM_PARAMS_BASE + 0x08 + i, parameter1);
 597              		.loc 1 410 0
 598 0092 FB8A     		ldrh	r3, [r7, #22]
 599 0094 03F10053 		add	r3, r3, #536870912
 600 0098 03F58473 		add	r3, r3, #264
 601 009c 1846     		mov	r0, r3
 602 009e 3969     		ldr	r1, [r7, #16]
 603 00a0 FFF7FEFF 		bl	Write_IO
 411:ProgrammingSteps.c **** 			
 412:ProgrammingSteps.c **** 			if( swd_PacketAck != SWD_OK_ACK )
 604              		.loc 1 412 0
 605 00a4 194B     		ldr	r3, .L54+4
 606 00a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 607 00a8 012B     		cmp	r3, #1
 608 00aa 01D0     		beq	.L49
 413:ProgrammingSteps.c ****     	    {
 414:ProgrammingSteps.c ****     	        return (FAILURE);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 19


 609              		.loc 1 414 0
 610 00ac 0023     		movs	r3, #0
 611 00ae 26E0     		b	.L46
 612              	.L49:
 405:ProgrammingSteps.c **** 	    {
 613              		.loc 1 405 0 discriminator 2
 614 00b0 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 615 00b2 0433     		adds	r3, r3, #4
 616 00b4 FB82     		strh	r3, [r7, #22]	@ movhi
 617              	.L48:
 405:ProgrammingSteps.c **** 	    {
 618              		.loc 1 405 0 is_stmt 0 discriminator 1
 619 00b6 FB8A     		ldrh	r3, [r7, #22]
 620 00b8 7F2B     		cmp	r3, #127
 621 00ba CFD9     		bls	.L50
 415:ProgrammingSteps.c ****     	    }
 416:ProgrammingSteps.c **** 		}
 417:ProgrammingSteps.c **** 
 418:ProgrammingSteps.c **** 	    /*  Call "Load Latch" SROM API */
 419:ProgrammingSteps.c **** 		
 420:ProgrammingSteps.c **** 		/* Set location of parameters */
 421:ProgrammingSteps.c **** 	    Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 622              		.loc 1 421 0 is_stmt 1
 623 00bc 1548     		ldr	r0, .L54+12
 624 00be 1249     		ldr	r1, .L54
 625 00c0 FFF7FEFF 		bl	Write_IO
 422:ProgrammingSteps.c **** 		
 423:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 626              		.loc 1 423 0
 627 00c4 114B     		ldr	r3, .L54+4
 628 00c6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 629 00c8 012B     		cmp	r3, #1
 630 00ca 01D0     		beq	.L51
 424:ProgrammingSteps.c **** 	    {
 425:ProgrammingSteps.c **** 	        return (FAILURE);
 631              		.loc 1 425 0
 632 00cc 0023     		movs	r3, #0
 633 00ce 16E0     		b	.L46
 634              	.L51:
 426:ProgrammingSteps.c **** 	    }
 427:ProgrammingSteps.c **** 	    
 428:ProgrammingSteps.c **** 		/* Request SROM operation */
 429:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_LOAD_LATCH);
 635              		.loc 1 429 0
 636 00d0 1148     		ldr	r0, .L54+16
 637 00d2 1249     		ldr	r1, .L54+20
 638 00d4 FFF7FEFF 		bl	Write_IO
 430:ProgrammingSteps.c **** 		
 431:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 639              		.loc 1 431 0
 640 00d8 0C4B     		ldr	r3, .L54+4
 641 00da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 642 00dc 012B     		cmp	r3, #1
 643 00de 01D0     		beq	.L52
 432:ProgrammingSteps.c **** 	    {
 433:ProgrammingSteps.c **** 	        return (FAILURE);
 644              		.loc 1 433 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 20


 645 00e0 0023     		movs	r3, #0
 646 00e2 0CE0     		b	.L46
 647              	.L52:
 434:ProgrammingSteps.c **** 	    }
 435:ProgrammingSteps.c **** 	    
 436:ProgrammingSteps.c **** 		/* Read status of the operation */
 437:ProgrammingSteps.c **** 		result = PollSromStatus();
 648              		.loc 1 437 0
 649 00e4 FFF7FEFF 		bl	PollSromStatus
 650 00e8 0346     		mov	r3, r0
 651 00ea 1A46     		mov	r2, r3
 652 00ec 0C4B     		ldr	r3, .L54+24
 653 00ee 1A70     		strb	r2, [r3]
 438:ProgrammingSteps.c **** 	    
 439:ProgrammingSteps.c **** 		if ( result != SROM_SUCCESS )
 654              		.loc 1 439 0
 655 00f0 0B4B     		ldr	r3, .L54+24
 656 00f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 657 00f4 012B     		cmp	r3, #1
 658 00f6 01D0     		beq	.L53
 440:ProgrammingSteps.c ****         {
 441:ProgrammingSteps.c ****             return (FAILURE);
 659              		.loc 1 441 0
 660 00f8 0023     		movs	r3, #0
 661 00fa 00E0     		b	.L46
 662              	.L53:
 442:ProgrammingSteps.c ****         }
 443:ProgrammingSteps.c **** 	
 444:ProgrammingSteps.c **** 	return (SUCCESS);
 663              		.loc 1 444 0
 664 00fc 0123     		movs	r3, #1
 665              	.L46:
 445:ProgrammingSteps.c **** }
 666              		.loc 1 445 0
 667 00fe 1846     		mov	r0, r3
 668 0100 1837     		adds	r7, r7, #24
 669              		.cfi_def_cfa_offset 8
 670 0102 BD46     		mov	sp, r7
 671              		.cfi_def_cfa_register 13
 672              		@ sp needed
 673 0104 80BD     		pop	{r7, pc}
 674              	.L55:
 675 0106 00BF     		.align	2
 676              	.L54:
 677 0108 00010020 		.word	536871168
 678 010c 00000000 		.word	swd_PacketAck
 679 0110 04010020 		.word	536871172
 680 0114 08001040 		.word	1074790408
 681 0118 04001040 		.word	1074790404
 682 011c 04000080 		.word	-2147483644
 683 0120 00000000 		.word	result
 684              		.cfi_endproc
 685              	.LFE68:
 686              		.size	LoadLatch, .-LoadLatch
 687              		.section	.text.ChecksumAPI,"ax",%progbits
 688              		.align	2
 689              		.global	ChecksumAPI
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 21


 690              		.thumb
 691              		.thumb_func
 692              		.type	ChecksumAPI, %function
 693              	ChecksumAPI:
 694              	.LFB69:
 446:ProgrammingSteps.c **** 
 447:ProgrammingSteps.c **** /******************************************************************************
 448:ProgrammingSteps.c **** * Function Name: ChecksumAPI
 449:ProgrammingSteps.c **** *******************************************************************************
 450:ProgrammingSteps.c **** *
 451:ProgrammingSteps.c **** * Summary:
 452:ProgrammingSteps.c **** *  This function reads either the whole flash memory or a row of flash. When 
 453:ProgrammingSteps.c **** *  performing a checksum on the whole flash, the user code and the supervisory 
 454:ProgrammingSteps.c **** *  flash regions are included. When performing a checksum only on one row of 
 455:ProgrammingSteps.c **** *  flash, the flash row number is passed as a parameter. For computing Checksum
 456:ProgrammingSteps.c **** *  of entire flash, ChecksumRow input parameter is loaded as macro
 457:ProgrammingSteps.c **** *  CHECKSUM_ENTIRE_FLASH (0x8000).
 458:ProgrammingSteps.c **** *
 459:ProgrammingSteps.c **** * Parameters:
 460:ProgrammingSteps.c **** *  checksumRow: Row number of flash for which checksum has to be calculated. 
 461:ProgrammingSteps.c **** *  				To compute checksum of entire flash, this variable is set to 
 462:ProgrammingSteps.c **** *  				CHECKSUM_ENTIRE_FLASH (0x8000).
 463:ProgrammingSteps.c **** *  
 464:ProgrammingSteps.c **** *  checksum: This variable is loaded with the checksum after the execution of
 465:ProgrammingSteps.c **** *			 the function.
 466:ProgrammingSteps.c **** *
 467:ProgrammingSteps.c **** * Return:
 468:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Checksum System call is successfully executed.
 469:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Checksum system call fails to execute.
 470:ProgrammingSteps.c **** *
 471:ProgrammingSteps.c **** * Note:
 472:ProgrammingSteps.c **** * This function is called in "Step 4. Checksum Privileged Calculation" and 
 473:ProgrammingSteps.c **** * "Step 9. Verify Checksum" to calculate the checksum of flash privileged rows
 474:ProgrammingSteps.c **** * and entire flash, respectively.
 475:ProgrammingSteps.c **** *
 476:ProgrammingSteps.c **** ******************************************************************************/
 477:ProgrammingSteps.c **** unsigned char ChecksumAPI(unsigned short checksumRow, unsigned long *checksum)
 478:ProgrammingSteps.c **** {
 695              		.loc 1 478 0
 696              		.cfi_startproc
 697              		@ args = 0, pretend = 0, frame = 16
 698              		@ frame_needed = 1, uses_anonymous_args = 0
 699 0000 80B5     		push	{r7, lr}
 700              		.cfi_def_cfa_offset 8
 701              		.cfi_offset 7, -8
 702              		.cfi_offset 14, -4
 703 0002 84B0     		sub	sp, sp, #16
 704              		.cfi_def_cfa_offset 24
 705 0004 00AF     		add	r7, sp, #0
 706              		.cfi_def_cfa_register 7
 707 0006 0346     		mov	r3, r0
 708 0008 3960     		str	r1, [r7]
 709 000a FB80     		strh	r3, [r7, #6]	@ movhi
 479:ProgrammingSteps.c **** 	unsigned long parameter1 	= 0;
 710              		.loc 1 479 0
 711 000c 0023     		movs	r3, #0
 712 000e FB60     		str	r3, [r7, #12]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 22


 480:ProgrammingSteps.c **** 	unsigned long checksum_chip = 0 ;
 713              		.loc 1 480 0
 714 0010 0023     		movs	r3, #0
 715 0012 BB60     		str	r3, [r7, #8]
 481:ProgrammingSteps.c **** 	
 482:ProgrammingSteps.c **** 	/* Load parameter1 with the SROM command to compute checksum of whole
 483:ProgrammingSteps.c **** 	   flash */
 484:ProgrammingSteps.c **** 	parameter1 = ((unsigned long)SROM_KEY1 << 00) + (((unsigned long)SROM_KEY2 + //
 485:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 716              		.loc 1 485 0
 717 0014 FB88     		ldrh	r3, [r7, #6]
 718 0016 DBB2     		uxtb	r3, r3
 719 0018 1A04     		lsls	r2, r3, #16
 486:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 720              		.loc 1 486 0
 721 001a FB88     		ldrh	r3, [r7, #6]
 722 001c 03F47F43 		and	r3, r3, #65280
 723 0020 1B04     		lsls	r3, r3, #16
 485:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 724              		.loc 1 485 0
 725 0022 1344     		add	r3, r3, r2
 484:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 726              		.loc 1 484 0
 727 0024 03F55E43 		add	r3, r3, #56832
 728 0028 B633     		adds	r3, r3, #182
 729 002a FB60     		str	r3, [r7, #12]
 487:ProgrammingSteps.c **** 	
 488:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 command */
 489:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 730              		.loc 1 489 0
 731 002c 1A48     		ldr	r0, .L63
 732 002e F968     		ldr	r1, [r7, #12]
 733 0030 FFF7FEFF 		bl	Write_IO
 490:ProgrammingSteps.c **** 	
 491:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 734              		.loc 1 491 0
 735 0034 194B     		ldr	r3, .L63+4
 736 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 737 0038 012B     		cmp	r3, #1
 738 003a 01D0     		beq	.L57
 492:ProgrammingSteps.c ****     {
 493:ProgrammingSteps.c ****         return(FAILURE);
 739              		.loc 1 493 0
 740 003c 0023     		movs	r3, #0
 741 003e 27E0     		b	.L62
 742              	.L57:
 494:ProgrammingSteps.c ****     }
 495:ProgrammingSteps.c **** 	
 496:ProgrammingSteps.c **** 	/* Request SROM operation */
 497:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_CHECKSUM);
 743              		.loc 1 497 0
 744 0040 1748     		ldr	r0, .L63+8
 745 0042 1849     		ldr	r1, .L63+12
 746 0044 FFF7FEFF 		bl	Write_IO
 498:ProgrammingSteps.c **** 	
 499:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 747              		.loc 1 499 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 23


 748 0048 144B     		ldr	r3, .L63+4
 749 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 750 004c 012B     		cmp	r3, #1
 751 004e 01D0     		beq	.L59
 500:ProgrammingSteps.c ****     {
 501:ProgrammingSteps.c ****         return(FAILURE);
 752              		.loc 1 501 0
 753 0050 0023     		movs	r3, #0
 754 0052 1DE0     		b	.L62
 755              	.L59:
 502:ProgrammingSteps.c ****     }
 503:ProgrammingSteps.c ****     
 504:ProgrammingSteps.c **** 	/* Read status of the operation */
 505:ProgrammingSteps.c **** 	result = PollSromStatus();
 756              		.loc 1 505 0
 757 0054 FFF7FEFF 		bl	PollSromStatus
 758 0058 0346     		mov	r3, r0
 759 005a 1A46     		mov	r2, r3
 760 005c 124B     		ldr	r3, .L63+16
 761 005e 1A70     		strb	r2, [r3]
 506:ProgrammingSteps.c **** 	
 507:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 762              		.loc 1 507 0
 763 0060 114B     		ldr	r3, .L63+16
 764 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 765 0064 012B     		cmp	r3, #1
 766 0066 01D0     		beq	.L60
 508:ProgrammingSteps.c ****     {
 509:ProgrammingSteps.c ****         return(FAILURE);
 767              		.loc 1 509 0
 768 0068 0023     		movs	r3, #0
 769 006a 11E0     		b	.L62
 770              	.L60:
 510:ProgrammingSteps.c ****     }
 511:ProgrammingSteps.c **** 	
 512:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to get the checksum value */
 513:ProgrammingSteps.c **** 	Read_IO( CPUSS_SYSARG, &checksum_chip);
 771              		.loc 1 513 0
 772 006c 07F10803 		add	r3, r7, #8
 773 0070 0948     		ldr	r0, .L63
 774 0072 1946     		mov	r1, r3
 775 0074 FFF7FEFF 		bl	Read_IO
 514:ProgrammingSteps.c **** 	
 515:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 776              		.loc 1 515 0
 777 0078 084B     		ldr	r3, .L63+4
 778 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 779 007c 012B     		cmp	r3, #1
 780 007e 01D0     		beq	.L61
 516:ProgrammingSteps.c ****     {
 517:ProgrammingSteps.c ****         return(FAILURE);
 781              		.loc 1 517 0
 782 0080 0023     		movs	r3, #0
 783 0082 05E0     		b	.L62
 784              	.L61:
 518:ProgrammingSteps.c ****     }
 519:ProgrammingSteps.c **** 	
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 24


 520:ProgrammingSteps.c **** 	/* 28-bit checksum */
 521:ProgrammingSteps.c **** 	*checksum = (checksum_chip & 0x0FFFFFFF);
 785              		.loc 1 521 0
 786 0084 BB68     		ldr	r3, [r7, #8]
 787 0086 23F07042 		bic	r2, r3, #-268435456
 788 008a 3B68     		ldr	r3, [r7]
 789 008c 1A60     		str	r2, [r3]
 522:ProgrammingSteps.c **** 
 523:ProgrammingSteps.c **** 	return (SUCCESS);
 790              		.loc 1 523 0
 791 008e 0123     		movs	r3, #1
 792              	.L62:
 524:ProgrammingSteps.c **** }
 793              		.loc 1 524 0 discriminator 1
 794 0090 1846     		mov	r0, r3
 795 0092 1037     		adds	r7, r7, #16
 796              		.cfi_def_cfa_offset 8
 797 0094 BD46     		mov	sp, r7
 798              		.cfi_def_cfa_register 13
 799              		@ sp needed
 800 0096 80BD     		pop	{r7, pc}
 801              	.L64:
 802              		.align	2
 803              	.L63:
 804 0098 08001040 		.word	1074790408
 805 009c 00000000 		.word	swd_PacketAck
 806 00a0 04001040 		.word	1074790404
 807 00a4 0B000080 		.word	-2147483637
 808 00a8 00000000 		.word	result
 809              		.cfi_endproc
 810              	.LFE69:
 811              		.size	ChecksumAPI, .-ChecksumAPI
 812              		.section	.text.DeviceAcquire,"ax",%progbits
 813              		.align	2
 814              		.global	DeviceAcquire
 815              		.thumb
 816              		.thumb_func
 817              		.type	DeviceAcquire, %function
 818              	DeviceAcquire:
 819              	.LFB70:
 525:ProgrammingSteps.c **** 
 526:ProgrammingSteps.c **** 
 527:ProgrammingSteps.c **** /******************************************************************************
 528:ProgrammingSteps.c **** *Function Name: DeviceAcquire
 529:ProgrammingSteps.c **** *******************************************************************************
 530:ProgrammingSteps.c **** *
 531:ProgrammingSteps.c **** * Summary:
 532:ProgrammingSteps.c **** *  This is Step 1 of the programming sequence. In this Step, target PSoC 4 is 
 533:ProgrammingSteps.c **** *  acquired by the host microcontroller by sending specific Port Acquiring 
 534:ProgrammingSteps.c **** *  Sequence in a 1.5 ms time-window. After acquiring SWD port, debug port is 
 535:ProgrammingSteps.c **** *  configured and bit 31 in TEST_MODE control register is set.
 536:ProgrammingSteps.c **** *
 537:ProgrammingSteps.c **** * Parameters:
 538:ProgrammingSteps.c **** *  None
 539:ProgrammingSteps.c **** *
 540:ProgrammingSteps.c **** * Return:
 541:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the device is successfully acquired.
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 25


 542:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the function fails in any of the intermediate
 543:ProgrammingSteps.c **** *			 step.
 544:ProgrammingSteps.c **** *
 545:ProgrammingSteps.c **** * Note:
 546:ProgrammingSteps.c **** * This function has very strict timing requirements. The device must be
 547:ProgrammingSteps.c **** * acquired as per the timing requirements given in PSoC 4 Device Programming 
 548:ProgrammingSteps.c **** * Specification Document.
 549:ProgrammingSteps.c **** *
 550:ProgrammingSteps.c **** ******************************************************************************/
 551:ProgrammingSteps.c **** unsigned char DeviceAcquire(void)
 552:ProgrammingSteps.c **** {
 820              		.loc 1 552 0
 821              		.cfi_startproc
 822              		@ args = 0, pretend = 0, frame = 16
 823              		@ frame_needed = 1, uses_anonymous_args = 0
 824 0000 80B5     		push	{r7, lr}
 825              		.cfi_def_cfa_offset 8
 826              		.cfi_offset 7, -8
 827              		.cfi_offset 14, -4
 828 0002 84B0     		sub	sp, sp, #16
 829              		.cfi_def_cfa_offset 24
 830 0004 00AF     		add	r7, sp, #0
 831              		.cfi_def_cfa_register 7
 553:ProgrammingSteps.c **** 	unsigned long chip_DAP_Id 			= 0;
 832              		.loc 1 553 0
 833 0006 0023     		movs	r3, #0
 834 0008 BB60     		str	r3, [r7, #8]
 554:ProgrammingSteps.c ****     unsigned short total_packet_count 	= 0;
 835              		.loc 1 554 0
 836 000a 0023     		movs	r3, #0
 837 000c FB81     		strh	r3, [r7, #14]	@ movhi
 555:ProgrammingSteps.c ****     unsigned long status 				= 0;
 838              		.loc 1 555 0
 839 000e 0023     		movs	r3, #0
 840 0010 7B60     		str	r3, [r7, #4]
 556:ProgrammingSteps.c ****     
 557:ProgrammingSteps.c **** 	/* Aquiring Sequence */
 558:ProgrammingSteps.c **** 
 559:ProgrammingSteps.c **** 	SetXresCmosOutput();
 841              		.loc 1 559 0
 842 0012 FFF7FEFF 		bl	SetXresCmosOutput
 560:ProgrammingSteps.c **** 	SetXresHigh();
 843              		.loc 1 560 0
 844 0016 FFF7FEFF 		bl	SetXresHigh
 561:ProgrammingSteps.c **** 
 562:ProgrammingSteps.c **** 	SetSwdckCmosOutput();
 845              		.loc 1 562 0
 846 001a FFF7FEFF 		bl	SetSwdckCmosOutput
 563:ProgrammingSteps.c **** 	SetSwdckLow();
 847              		.loc 1 563 0
 848 001e FFF7FEFF 		bl	SetSwdckLow
 564:ProgrammingSteps.c **** 
 565:ProgrammingSteps.c **** 	SetSwdioCmosOutput();
 849              		.loc 1 565 0
 850 0022 FFF7FEFF 		bl	SetSwdioCmosOutput
 566:ProgrammingSteps.c **** 	SetSwdioLow();
 851              		.loc 1 566 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 26


 852 0026 FFF7FEFF 		bl	SetSwdioLow
 567:ProgrammingSteps.c **** 	
 568:ProgrammingSteps.c **** 	/* Set XRES of PSoC 4 low for 100us with SWDCK and SWDIO low (min delay 
 569:ProgrammingSteps.c **** 	   required is 5us) */
 570:ProgrammingSteps.c **** 	SetXresLow();
 853              		.loc 1 570 0
 854 002a FFF7FEFF 		bl	SetXresLow
 571:ProgrammingSteps.c **** 	DelayHundredUs();
 855              		.loc 1 571 0
 856 002e FFF7FEFF 		bl	DelayHundredUs
 572:ProgrammingSteps.c **** 	SetXresHigh();
 857              		.loc 1 572 0
 858 0032 FFF7FEFF 		bl	SetXresHigh
 859              	.L67:
 573:ProgrammingSteps.c **** 	
 574:ProgrammingSteps.c ****     do
 575:ProgrammingSteps.c ****     {
 576:ProgrammingSteps.c **** 		/* Call Swd_LineReset (Standard ARM command to reset DAP) and read
 577:ProgrammingSteps.c **** 		   DAP_ID from chip */
 578:ProgrammingSteps.c ****     	Swd_LineReset();
 860              		.loc 1 578 0 discriminator 2
 861 0036 FFF7FEFF 		bl	Swd_LineReset
 579:ProgrammingSteps.c **** 		
 580:ProgrammingSteps.c **** 		Read_DAP(DPACC_DP_IDCODE_READ, &chip_DAP_Id);
 862              		.loc 1 580 0 discriminator 2
 863 003a 07F10803 		add	r3, r7, #8
 864 003e A520     		movs	r0, #165
 865 0040 1946     		mov	r1, r3
 866 0042 FFF7FEFF 		bl	Read_DAP
 581:ProgrammingSteps.c ****     	
 582:ProgrammingSteps.c **** 		total_packet_count++;
 867              		.loc 1 582 0 discriminator 2
 868 0046 FB89     		ldrh	r3, [r7, #14]
 869 0048 0133     		adds	r3, r3, #1
 870 004a FB81     		strh	r3, [r7, #14]	@ movhi
 583:ProgrammingSteps.c **** 		
 584:ProgrammingSteps.c ****     }while((swd_PacketAck != SWD_OK_ACK)&& (total_packet_count < DEVICE_ACQUIRE_TIMEOUT));
 871              		.loc 1 584 0 discriminator 2
 872 004c 3C4B     		ldr	r3, .L80
 873 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 874 0050 012B     		cmp	r3, #1
 875 0052 02D0     		beq	.L66
 876              		.loc 1 584 0 is_stmt 0 discriminator 1
 877 0054 FB89     		ldrh	r3, [r7, #14]
 878 0056 132B     		cmp	r3, #19
 879 0058 EDD9     		bls	.L67
 880              	.L66:
 585:ProgrammingSteps.c **** 	
 586:ProgrammingSteps.c **** 	/* Set PORT_ACQUIRE_TIMEOUT_ERROR bit in swd_PacketAck if time
 587:ProgrammingSteps.c **** 	   exceeds 1.5 ms */
 588:ProgrammingSteps.c **** 	if (total_packet_count == DEVICE_ACQUIRE_TIMEOUT)
 881              		.loc 1 588 0 is_stmt 1
 882 005a FB89     		ldrh	r3, [r7, #14]
 883 005c 142B     		cmp	r3, #20
 884 005e 08D1     		bne	.L68
 589:ProgrammingSteps.c **** 	{
 590:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | PORT_ACQUIRE_TIMEOUT_ERROR;
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 27


 885              		.loc 1 590 0
 886 0060 374B     		ldr	r3, .L80
 887 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 888 0064 43F01003 		orr	r3, r3, #16
 889 0068 DAB2     		uxtb	r2, r3
 890 006a 354B     		ldr	r3, .L80
 891 006c 1A70     		strb	r2, [r3]
 591:ProgrammingSteps.c ****         return(FAILURE);
 892              		.loc 1 591 0
 893 006e 0023     		movs	r3, #0
 894 0070 61E0     		b	.L79
 895              	.L68:
 592:ProgrammingSteps.c **** 	}
 593:ProgrammingSteps.c **** 	
 594:ProgrammingSteps.c **** 	/* Set VERIFICATION_ERROR bit in swd_PacketAck if the DAP_ID read
 595:ProgrammingSteps.c **** 	   from chip does not match with the ARM CM0_DAP_ID (MACRO defined in
 596:ProgrammingSteps.c **** 	   ProgrammingSteps.h file - 0x0BB11477) */
 597:ProgrammingSteps.c **** 	if (chip_DAP_Id != CM0_DAP_ID)
 896              		.loc 1 597 0
 897 0072 BB68     		ldr	r3, [r7, #8]
 898 0074 334A     		ldr	r2, .L80+4
 899 0076 9342     		cmp	r3, r2
 900 0078 08D0     		beq	.L70
 598:ProgrammingSteps.c **** 	{
 599:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 901              		.loc 1 599 0
 902 007a 314B     		ldr	r3, .L80
 903 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 904 007e 43F04003 		orr	r3, r3, #64
 905 0082 DAB2     		uxtb	r2, r3
 906 0084 2E4B     		ldr	r3, .L80
 907 0086 1A70     		strb	r2, [r3]
 600:ProgrammingSteps.c **** 		return(FAILURE);
 908              		.loc 1 600 0
 909 0088 0023     		movs	r3, #0
 910 008a 54E0     		b	.L79
 911              	.L70:
 601:ProgrammingSteps.c **** 	}
 602:ProgrammingSteps.c **** 	
 603:ProgrammingSteps.c **** 	/* Initialize Debug Port */
 604:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_CTRLSTAT_WRITE, 0x54000000);
 912              		.loc 1 604 0
 913 008c A920     		movs	r0, #169
 914 008e 4FF0A841 		mov	r1, #1409286144
 915 0092 FFF7FEFF 		bl	Write_DAP
 605:ProgrammingSteps.c ****     
 606:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 916              		.loc 1 606 0
 917 0096 2A4B     		ldr	r3, .L80
 918 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 919 009a 012B     		cmp	r3, #1
 920 009c 01D0     		beq	.L71
 607:ProgrammingSteps.c ****     {
 608:ProgrammingSteps.c ****         return(FAILURE);
 921              		.loc 1 608 0
 922 009e 0023     		movs	r3, #0
 923 00a0 49E0     		b	.L79
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 28


 924              	.L71:
 609:ProgrammingSteps.c ****     }
 610:ProgrammingSteps.c **** 	
 611:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_SELECT_WRITE, 0x00000000);
 925              		.loc 1 611 0
 926 00a2 B120     		movs	r0, #177
 927 00a4 0021     		movs	r1, #0
 928 00a6 FFF7FEFF 		bl	Write_DAP
 612:ProgrammingSteps.c ****     
 613:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 929              		.loc 1 613 0
 930 00aa 254B     		ldr	r3, .L80
 931 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 932 00ae 012B     		cmp	r3, #1
 933 00b0 01D0     		beq	.L72
 614:ProgrammingSteps.c ****     {
 615:ProgrammingSteps.c ****         return(FAILURE);
 934              		.loc 1 615 0
 935 00b2 0023     		movs	r3, #0
 936 00b4 3FE0     		b	.L79
 937              	.L72:
 616:ProgrammingSteps.c ****     }
 617:ProgrammingSteps.c **** 	
 618:ProgrammingSteps.c **** 	Write_DAP (DPACC_AP_CSW_WRITE, 0x00000002);
 938              		.loc 1 618 0
 939 00b6 A320     		movs	r0, #163
 940 00b8 0221     		movs	r1, #2
 941 00ba FFF7FEFF 		bl	Write_DAP
 619:ProgrammingSteps.c ****     
 620:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 942              		.loc 1 620 0
 943 00be 204B     		ldr	r3, .L80
 944 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 945 00c2 012B     		cmp	r3, #1
 946 00c4 01D0     		beq	.L73
 621:ProgrammingSteps.c ****     {
 622:ProgrammingSteps.c ****         return(FAILURE);
 947              		.loc 1 622 0
 948 00c6 0023     		movs	r3, #0
 949 00c8 35E0     		b	.L79
 950              	.L73:
 623:ProgrammingSteps.c ****     }
 624:ProgrammingSteps.c **** 
 625:ProgrammingSteps.c **** 	/* Enter CPU into Test Mode */
 626:ProgrammingSteps.c ****     Write_IO (TEST_MODE, 0x80000000);
 951              		.loc 1 626 0
 952 00ca 1F48     		ldr	r0, .L80+8
 953 00cc 4FF00041 		mov	r1, #-2147483648
 954 00d0 FFF7FEFF 		bl	Write_IO
 627:ProgrammingSteps.c **** 	
 628:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 955              		.loc 1 628 0
 956 00d4 1A4B     		ldr	r3, .L80
 957 00d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 958 00d8 012B     		cmp	r3, #1
 959 00da 01D0     		beq	.L74
 629:ProgrammingSteps.c ****     {
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 29


 630:ProgrammingSteps.c ****         return(FAILURE);
 960              		.loc 1 630 0
 961 00dc 0023     		movs	r3, #0
 962 00de 2AE0     		b	.L79
 963              	.L74:
 631:ProgrammingSteps.c ****     }
 632:ProgrammingSteps.c ****     
 633:ProgrammingSteps.c ****     Read_IO (TEST_MODE, &status);
 964              		.loc 1 633 0
 965 00e0 3B1D     		adds	r3, r7, #4
 966 00e2 1948     		ldr	r0, .L80+8
 967 00e4 1946     		mov	r1, r3
 968 00e6 FFF7FEFF 		bl	Read_IO
 634:ProgrammingSteps.c **** 	
 635:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 969              		.loc 1 635 0
 970 00ea 154B     		ldr	r3, .L80
 971 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 972 00ee 012B     		cmp	r3, #1
 973 00f0 01D0     		beq	.L75
 636:ProgrammingSteps.c ****     {
 637:ProgrammingSteps.c ****         return(FAILURE);
 974              		.loc 1 637 0
 975 00f2 0023     		movs	r3, #0
 976 00f4 1FE0     		b	.L79
 977              	.L75:
 638:ProgrammingSteps.c ****     }
 639:ProgrammingSteps.c **** 	
 640:ProgrammingSteps.c ****     if((status & 0x80000000) != 0x80000000)
 978              		.loc 1 640 0
 979 00f6 7B68     		ldr	r3, [r7, #4]
 980 00f8 002B     		cmp	r3, #0
 981 00fa 01DB     		blt	.L76
 641:ProgrammingSteps.c ****     {
 642:ProgrammingSteps.c ****         return (FAILURE);
 982              		.loc 1 642 0
 983 00fc 0023     		movs	r3, #0
 984 00fe 1AE0     		b	.L79
 985              	.L76:
 643:ProgrammingSteps.c ****     }
 644:ProgrammingSteps.c **** 	
 645:ProgrammingSteps.c **** 	/* Read status of the operation */
 646:ProgrammingSteps.c **** 	result = PollSromStatus();
 986              		.loc 1 646 0
 987 0100 FFF7FEFF 		bl	PollSromStatus
 988 0104 0346     		mov	r3, r0
 989 0106 1A46     		mov	r2, r3
 990 0108 104B     		ldr	r3, .L80+12
 991 010a 1A70     		strb	r2, [r3]
 647:ProgrammingSteps.c **** 	
 648:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 992              		.loc 1 648 0
 993 010c 0F4B     		ldr	r3, .L80+12
 994 010e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 995 0110 012B     		cmp	r3, #1
 996 0112 01D0     		beq	.L77
 649:ProgrammingSteps.c **** 	{
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 30


 650:ProgrammingSteps.c **** 		return(FAILURE);		
 997              		.loc 1 650 0
 998 0114 0023     		movs	r3, #0
 999 0116 0EE0     		b	.L79
 1000              	.L77:
 651:ProgrammingSteps.c **** 	}
 652:ProgrammingSteps.c **** 	
 653:ProgrammingSteps.c **** 	#if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY)
 654:ProgrammingSteps.c **** 	
 655:ProgrammingSteps.c **** 	/* Set IMO to 48 MHz */
 656:ProgrammingSteps.c **** 	SetIMO48MHz();
 1001              		.loc 1 656 0
 1002 0118 FFF7FEFF 		bl	SetIMO48MHz
 657:ProgrammingSteps.c **** 	
 658:ProgrammingSteps.c **** 	/* Read status of the operation */
 659:ProgrammingSteps.c **** 	result = PollSromStatus();
 1003              		.loc 1 659 0
 1004 011c FFF7FEFF 		bl	PollSromStatus
 1005 0120 0346     		mov	r3, r0
 1006 0122 1A46     		mov	r2, r3
 1007 0124 094B     		ldr	r3, .L80+12
 1008 0126 1A70     		strb	r2, [r3]
 660:ProgrammingSteps.c **** 	
 661:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 1009              		.loc 1 661 0
 1010 0128 084B     		ldr	r3, .L80+12
 1011 012a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1012 012c 012B     		cmp	r3, #1
 1013 012e 01D0     		beq	.L78
 662:ProgrammingSteps.c **** 	{
 663:ProgrammingSteps.c **** 		return(FAILURE);		
 1014              		.loc 1 663 0
 1015 0130 0023     		movs	r3, #0
 1016 0132 00E0     		b	.L79
 1017              	.L78:
 664:ProgrammingSteps.c **** 	}
 665:ProgrammingSteps.c **** 	#endif
 666:ProgrammingSteps.c **** 	
 667:ProgrammingSteps.c ****     return (SUCCESS);
 1018              		.loc 1 667 0
 1019 0134 0123     		movs	r3, #1
 1020              	.L79:
 668:ProgrammingSteps.c **** }
 1021              		.loc 1 668 0 discriminator 1
 1022 0136 1846     		mov	r0, r3
 1023 0138 1037     		adds	r7, r7, #16
 1024              		.cfi_def_cfa_offset 8
 1025 013a BD46     		mov	sp, r7
 1026              		.cfi_def_cfa_register 13
 1027              		@ sp needed
 1028 013c 80BD     		pop	{r7, pc}
 1029              	.L81:
 1030 013e 00BF     		.align	2
 1031              	.L80:
 1032 0140 00000000 		.word	swd_PacketAck
 1033 0144 7714B10B 		.word	196154487
 1034 0148 14000340 		.word	1073938452
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 31


 1035 014c 00000000 		.word	result
 1036              		.cfi_endproc
 1037              	.LFE70:
 1038              		.size	DeviceAcquire, .-DeviceAcquire
 1039              		.section	.text.VerifySiliconId,"ax",%progbits
 1040              		.align	2
 1041              		.global	VerifySiliconId
 1042              		.thumb
 1043              		.thumb_func
 1044              		.type	VerifySiliconId, %function
 1045              	VerifySiliconId:
 1046              	.LFB71:
 669:ProgrammingSteps.c **** 
 670:ProgrammingSteps.c **** /******************************************************************************
 671:ProgrammingSteps.c **** * Function Name: VerifySiliconId
 672:ProgrammingSteps.c **** *******************************************************************************
 673:ProgrammingSteps.c **** *
 674:ProgrammingSteps.c **** * Summary:
 675:ProgrammingSteps.c **** *  This is Step 2 of the programming sequence. In this Step, Silicon Id of the
 676:ProgrammingSteps.c **** *  PSoC 4 device is read and matched with the silicon id stored in the Hex File
 677:ProgrammingSteps.c **** *  to verify that the correct device is being programmed.
 678:ProgrammingSteps.c **** *
 679:ProgrammingSteps.c **** * Parameters:
 680:ProgrammingSteps.c **** *  None
 681:ProgrammingSteps.c **** *
 682:ProgrammingSteps.c **** * Return:
 683:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Silicon Id read from chip matches the Id in the
 684:ProgrammingSteps.c **** *			 HEX File.
 685:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 686:ProgrammingSteps.c **** *			 message.
 687:ProgrammingSteps.c **** *
 688:ProgrammingSteps.c **** * Note:
 689:ProgrammingSteps.c **** * 
 690:ProgrammingSteps.c **** ******************************************************************************/
 691:ProgrammingSteps.c **** unsigned char VerifySiliconId(void)
 692:ProgrammingSteps.c **** {
 1047              		.loc 1 692 0
 1048              		.cfi_startproc
 1049              		@ args = 0, pretend = 0, frame = 24
 1050              		@ frame_needed = 1, uses_anonymous_args = 0
 1051 0000 80B5     		push	{r7, lr}
 1052              		.cfi_def_cfa_offset 8
 1053              		.cfi_offset 7, -8
 1054              		.cfi_offset 14, -4
 1055 0002 86B0     		sub	sp, sp, #24
 1056              		.cfi_def_cfa_offset 32
 1057 0004 00AF     		add	r7, sp, #0
 1058              		.cfi_def_cfa_register 7
 693:ProgrammingSteps.c **** 	unsigned char i;
 694:ProgrammingSteps.c **** 	unsigned long deviceSiliconID;
 695:ProgrammingSteps.c **** 	unsigned long hexSiliconId = 0;
 1059              		.loc 1 695 0
 1060 0006 0023     		movs	r3, #0
 1061 0008 BB60     		str	r3, [r7, #8]
 696:ProgrammingSteps.c ****     
 697:ProgrammingSteps.c **** 	unsigned long parameter1 	 = 0;
 1062              		.loc 1 697 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 32


 1063 000a 0023     		movs	r3, #0
 1064 000c 3B61     		str	r3, [r7, #16]
 698:ProgrammingSteps.c **** 	unsigned long siliconIdData1 = 0;
 1065              		.loc 1 698 0
 1066 000e 0023     		movs	r3, #0
 1067 0010 7B60     		str	r3, [r7, #4]
 699:ProgrammingSteps.c **** 	unsigned long siliconIdData2 = 0;
 1068              		.loc 1 699 0
 1069 0012 0023     		movs	r3, #0
 1070 0014 3B60     		str	r3, [r7]
 700:ProgrammingSteps.c **** 	
 701:ProgrammingSteps.c **** 	/* Read and store Silicon ID from HEX file to hexSiliconId array */
 702:ProgrammingSteps.c **** 	HEX_ReadSiliconId(&hexSiliconId);
 1071              		.loc 1 702 0
 1072 0016 07F10803 		add	r3, r7, #8
 1073 001a 1846     		mov	r0, r3
 1074 001c FFF7FEFF 		bl	HEX_ReadSiliconId
 703:ProgrammingSteps.c **** 	
 704:ProgrammingSteps.c **** 	/* Load Parameter1 with the SROM command to read silicon ID from PSoC 4
 705:ProgrammingSteps.c **** 	   chip */
 706:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1075              		.loc 1 706 0
 1076 0020 4DF2B633 		movw	r3, #54198
 1077 0024 3B61     		str	r3, [r7, #16]
 707:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 708:ProgrammingSteps.c **** 	
 709:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 */
 710:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSARG, parameter1);
 1078              		.loc 1 710 0
 1079 0026 3248     		ldr	r0, .L93
 1080 0028 3969     		ldr	r1, [r7, #16]
 1081 002a FFF7FEFF 		bl	Write_IO
 711:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1082              		.loc 1 711 0
 1083 002e 314B     		ldr	r3, .L93+4
 1084 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1085 0032 012B     		cmp	r3, #1
 1086 0034 01D0     		beq	.L83
 712:ProgrammingSteps.c ****     {
 713:ProgrammingSteps.c ****         return(FAILURE);
 1087              		.loc 1 713 0
 1088 0036 0023     		movs	r3, #0
 1089 0038 55E0     		b	.L92
 1090              	.L83:
 714:ProgrammingSteps.c ****     }
 715:ProgrammingSteps.c **** 	
 716:ProgrammingSteps.c **** 	/* Request SROM operation */
 717:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 1091              		.loc 1 717 0
 1092 003a 2F48     		ldr	r0, .L93+8
 1093 003c 4FF00041 		mov	r1, #-2147483648
 1094 0040 FFF7FEFF 		bl	Write_IO
 718:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1095              		.loc 1 718 0
 1096 0044 2B4B     		ldr	r3, .L93+4
 1097 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1098 0048 012B     		cmp	r3, #1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 33


 1099 004a 01D0     		beq	.L85
 719:ProgrammingSteps.c ****     {
 720:ProgrammingSteps.c ****         return(FAILURE);
 1100              		.loc 1 720 0
 1101 004c 0023     		movs	r3, #0
 1102 004e 4AE0     		b	.L92
 1103              	.L85:
 721:ProgrammingSteps.c ****     }
 722:ProgrammingSteps.c **** 	
 723:ProgrammingSteps.c **** 	/* Read status of the operation */
 724:ProgrammingSteps.c ****     result = PollSromStatus();
 1104              		.loc 1 724 0
 1105 0050 FFF7FEFF 		bl	PollSromStatus
 1106 0054 0346     		mov	r3, r0
 1107 0056 1A46     		mov	r2, r3
 1108 0058 284B     		ldr	r3, .L93+12
 1109 005a 1A70     		strb	r2, [r3]
 725:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 1110              		.loc 1 725 0
 1111 005c 274B     		ldr	r3, .L93+12
 1112 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1113 0060 012B     		cmp	r3, #1
 1114 0062 01D0     		beq	.L86
 726:ProgrammingSteps.c ****     {
 727:ProgrammingSteps.c ****         return(FAILURE);
 1115              		.loc 1 727 0
 1116 0064 0023     		movs	r3, #0
 1117 0066 3EE0     		b	.L92
 1118              	.L86:
 728:ProgrammingSteps.c ****     }
 729:ProgrammingSteps.c **** 	
 730:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG and CPUSS_SYSREQ to read 4 bytes of silicon ID */
 731:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSARG, &siliconIdData1);
 1119              		.loc 1 731 0
 1120 0068 3B1D     		adds	r3, r7, #4
 1121 006a 2148     		ldr	r0, .L93
 1122 006c 1946     		mov	r1, r3
 1123 006e FFF7FEFF 		bl	Read_IO
 732:ProgrammingSteps.c ****     if( swd_PacketAck != SWD_OK_ACK )
 1124              		.loc 1 732 0
 1125 0072 204B     		ldr	r3, .L93+4
 1126 0074 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1127 0076 012B     		cmp	r3, #1
 1128 0078 01D0     		beq	.L87
 733:ProgrammingSteps.c ****     {
 734:ProgrammingSteps.c ****         return(FAILURE);
 1129              		.loc 1 734 0
 1130 007a 0023     		movs	r3, #0
 1131 007c 33E0     		b	.L92
 1132              	.L87:
 735:ProgrammingSteps.c ****     }
 736:ProgrammingSteps.c **** 	
 737:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSREQ, &siliconIdData2);
 1133              		.loc 1 737 0
 1134 007e 3B46     		mov	r3, r7
 1135 0080 1D48     		ldr	r0, .L93+8
 1136 0082 1946     		mov	r1, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 34


 1137 0084 FFF7FEFF 		bl	Read_IO
 738:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1138              		.loc 1 738 0
 1139 0088 1A4B     		ldr	r3, .L93+4
 1140 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1141 008c 012B     		cmp	r3, #1
 1142 008e 01D0     		beq	.L88
 739:ProgrammingSteps.c ****     {
 740:ProgrammingSteps.c ****         return(FAILURE);
 1143              		.loc 1 740 0
 1144 0090 0023     		movs	r3, #0
 1145 0092 28E0     		b	.L92
 1146              	.L88:
 741:ProgrammingSteps.c ****     }
 742:ProgrammingSteps.c ****     
 743:ProgrammingSteps.c **** 	/*
 744:ProgrammingSteps.c **** 	SiliconIdData2 (0th byte) = 4th byte of Device Silicon ID (MSB)
 745:ProgrammingSteps.c **** 	SiliconIdData1 (3rd byte) = 3rd byte of Device Silicon ID
 746:ProgrammingSteps.c **** 	SiliconIdData1 (1st byte) = 2nd byte of Device Silicon ID
 747:ProgrammingSteps.c **** 	SiliconIdData1 (2nd byte) = 1st byte of Device Silicon ID (LSB)
 748:ProgrammingSteps.c **** 	*/
 749:ProgrammingSteps.c **** 	deviceSiliconID = (((siliconIdData2 << 24) & 0xFF000000) + (siliconIdData1 & 0x00FF0000) + //
 1147              		.loc 1 749 0
 1148 0094 3B68     		ldr	r3, [r7]
 1149 0096 1A06     		lsls	r2, r3, #24
 1150 0098 7B68     		ldr	r3, [r7, #4]
 1151 009a 03F47F03 		and	r3, r3, #16711680
 1152 009e 1A44     		add	r2, r2, r3
 750:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1153              		.loc 1 750 0
 1154 00a0 7B68     		ldr	r3, [r7, #4]
 1155 00a2 1B02     		lsls	r3, r3, #8
 1156 00a4 9BB2     		uxth	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1157              		.loc 1 749 0
 1158 00a6 1A44     		add	r2, r2, r3
 1159              		.loc 1 750 0
 1160 00a8 7B68     		ldr	r3, [r7, #4]
 1161 00aa 1B0A     		lsrs	r3, r3, #8
 1162 00ac DBB2     		uxtb	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1163              		.loc 1 749 0
 1164 00ae 1344     		add	r3, r3, r2
 1165 00b0 FB60     		str	r3, [r7, #12]
 751:ProgrammingSteps.c **** 	
 752:ProgrammingSteps.c **** 	/* Match the Silicon ID read from HEX file and PSoC 4 chip */
 753:ProgrammingSteps.c **** 	for (i=0; i<SILICON_ID_BYTE_LENGTH; i++)
 1166              		.loc 1 753 0
 1167 00b2 0023     		movs	r3, #0
 1168 00b4 FB75     		strb	r3, [r7, #23]
 1169 00b6 12E0     		b	.L89
 1170              	.L91:
 754:ProgrammingSteps.c **** 	{
 755:ProgrammingSteps.c **** 		if ((deviceSiliconID & 0xFF00FFFF) != (hexSiliconId & 0xFF00FFFF))
 1171              		.loc 1 755 0
 1172 00b8 BA68     		ldr	r2, [r7, #8]
 1173 00ba FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 35


 1174 00bc 5340     		eors	r3, r3, r2
 1175 00be 23F47F03 		bic	r3, r3, #16711680
 1176 00c2 002B     		cmp	r3, #0
 1177 00c4 08D0     		beq	.L90
 756:ProgrammingSteps.c ****         {
 757:ProgrammingSteps.c **** 			/* Set the VERIFICATION_ERROR bit in swd_PacketAck */
 758:ProgrammingSteps.c ****             swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1178              		.loc 1 758 0
 1179 00c6 0B4B     		ldr	r3, .L93+4
 1180 00c8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1181 00ca 43F04003 		orr	r3, r3, #64
 1182 00ce DAB2     		uxtb	r2, r3
 1183 00d0 084B     		ldr	r3, .L93+4
 1184 00d2 1A70     		strb	r2, [r3]
 759:ProgrammingSteps.c **** 			return (FAILURE);
 1185              		.loc 1 759 0
 1186 00d4 0023     		movs	r3, #0
 1187 00d6 06E0     		b	.L92
 1188              	.L90:
 753:ProgrammingSteps.c **** 	{
 1189              		.loc 1 753 0 discriminator 2
 1190 00d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1191 00da 0133     		adds	r3, r3, #1
 1192 00dc FB75     		strb	r3, [r7, #23]
 1193              	.L89:
 753:ProgrammingSteps.c **** 	{
 1194              		.loc 1 753 0 is_stmt 0 discriminator 1
 1195 00de FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1196 00e0 032B     		cmp	r3, #3
 1197 00e2 E9D9     		bls	.L91
 760:ProgrammingSteps.c ****         }
 761:ProgrammingSteps.c **** 	}
 762:ProgrammingSteps.c **** 	return (SUCCESS);
 1198              		.loc 1 762 0 is_stmt 1
 1199 00e4 0123     		movs	r3, #1
 1200              	.L92:
 763:ProgrammingSteps.c **** }
 1201              		.loc 1 763 0 discriminator 1
 1202 00e6 1846     		mov	r0, r3
 1203 00e8 1837     		adds	r7, r7, #24
 1204              		.cfi_def_cfa_offset 8
 1205 00ea BD46     		mov	sp, r7
 1206              		.cfi_def_cfa_register 13
 1207              		@ sp needed
 1208 00ec 80BD     		pop	{r7, pc}
 1209              	.L94:
 1210 00ee 00BF     		.align	2
 1211              	.L93:
 1212 00f0 08001040 		.word	1074790408
 1213 00f4 00000000 		.word	swd_PacketAck
 1214 00f8 04001040 		.word	1074790404
 1215 00fc 00000000 		.word	result
 1216              		.cfi_endproc
 1217              	.LFE71:
 1218              		.size	VerifySiliconId, .-VerifySiliconId
 1219              		.section	.text.EraseAllFlash,"ax",%progbits
 1220              		.align	2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 36


 1221              		.global	EraseAllFlash
 1222              		.thumb
 1223              		.thumb_func
 1224              		.type	EraseAllFlash, %function
 1225              	EraseAllFlash:
 1226              	.LFB72:
 764:ProgrammingSteps.c **** 
 765:ProgrammingSteps.c **** /******************************************************************************
 766:ProgrammingSteps.c **** * Function Name: EraseAllFlash
 767:ProgrammingSteps.c **** *******************************************************************************
 768:ProgrammingSteps.c **** *
 769:ProgrammingSteps.c **** * Summary:
 770:ProgrammingSteps.c **** *  This is Step 3 of the programming sequence. In this Step, the whole user 
 771:ProgrammingSteps.c **** *  flash is erased. This function uses GetChipProtectionVal() and 
 772:ProgrammingSteps.c **** *  GetTransitionMode() API's to take the decision on the method to follow to 
 773:ProgrammingSteps.c **** *  erase the device.
 774:ProgrammingSteps.c **** *
 775:ProgrammingSteps.c **** * Parameters:
 776:ProgrammingSteps.c **** *  None
 777:ProgrammingSteps.c **** *
 778:ProgrammingSteps.c **** * Return:
 779:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully erases complete user 
 780:ProgrammingSteps.c **** *			 flash region.
 781:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 782:ProgrammingSteps.c **** *			 message.
 783:ProgrammingSteps.c **** *
 784:ProgrammingSteps.c **** * Note:
 785:ProgrammingSteps.c **** * 
 786:ProgrammingSteps.c **** ******************************************************************************/
 787:ProgrammingSteps.c **** unsigned char EraseAllFlash(void)
 788:ProgrammingSteps.c **** {
 1227              		.loc 1 788 0
 1228              		.cfi_startproc
 1229              		@ args = 0, pretend = 0, frame = 8
 1230              		@ frame_needed = 1, uses_anonymous_args = 0
 1231 0000 80B5     		push	{r7, lr}
 1232              		.cfi_def_cfa_offset 8
 1233              		.cfi_offset 7, -8
 1234              		.cfi_offset 14, -4
 1235 0002 82B0     		sub	sp, sp, #8
 1236              		.cfi_def_cfa_offset 16
 1237 0004 00AF     		add	r7, sp, #0
 1238              		.cfi_def_cfa_register 7
 789:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1239              		.loc 1 789 0
 1240 0006 0023     		movs	r3, #0
 1241 0008 7B60     		str	r3, [r7, #4]
 790:ProgrammingSteps.c **** 	
 791:ProgrammingSteps.c **** 	/* Get current chip protection setting */
 792:ProgrammingSteps.c **** 	GetChipProtectionVal();
 1242              		.loc 1 792 0
 1243 000a FFF7FEFF 		bl	GetChipProtectionVal
 793:ProgrammingSteps.c **** 	
 794:ProgrammingSteps.c **** 	/* Check if the Chip protection setting transition is valid */
 795:ProgrammingSteps.c **** 	result = GetTransitionMode();
 1244              		.loc 1 795 0
 1245 000e FFF7FEFF 		bl	GetTransitionMode
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 37


 1246 0012 0346     		mov	r3, r0
 1247 0014 1A46     		mov	r2, r3
 1248 0016 3A4B     		ldr	r3, .L108
 1249 0018 1A70     		strb	r2, [r3]
 796:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1250              		.loc 1 796 0
 1251 001a 394B     		ldr	r3, .L108
 1252 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1253 001e 012B     		cmp	r3, #1
 1254 0020 01D0     		beq	.L96
 797:ProgrammingSteps.c **** 	{
 798:ProgrammingSteps.c **** 		return(FAILURE);
 1255              		.loc 1 798 0
 1256 0022 0023     		movs	r3, #0
 1257 0024 68E0     		b	.L97
 1258              	.L96:
 799:ProgrammingSteps.c **** 	}
 800:ProgrammingSteps.c **** 	
 801:ProgrammingSteps.c **** 	/* If the transition is from open to any protection setting or from virgin to
 802:ProgrammingSteps.c **** 	   open, call ERASE_ALL SROM command */
 803:ProgrammingSteps.c **** 	if ((flow == OPEN_XXX) || (flow == VIRGIN_OPEN))
 1259              		.loc 1 803 0
 1260 0026 374B     		ldr	r3, .L108+4
 1261 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1262 002a 002B     		cmp	r3, #0
 1263 002c 03D0     		beq	.L98
 1264              		.loc 1 803 0 is_stmt 0 discriminator 1
 1265 002e 354B     		ldr	r3, .L108+4
 1266 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1267 0032 012B     		cmp	r3, #1
 1268 0034 2DD1     		bne	.L99
 1269              	.L98:
 804:ProgrammingSteps.c ****     {
 805:ProgrammingSteps.c **** 		parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1270              		.loc 1 805 0 is_stmt 1
 1271 0036 4DF6B653 		movw	r3, #56758
 1272 003a 7B60     		str	r3, [r7, #4]
 806:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_ERASE_ALL) << 8));
 807:ProgrammingSteps.c **** 		
 808:ProgrammingSteps.c **** 		/* Load ERASE_ALL SROM command in parameter1 to SRAM */ 
 809:ProgrammingSteps.c ****     	Write_IO (SRAM_PARAMS_BASE + 0x00, parameter1);
 1273              		.loc 1 809 0
 1274 003c 3248     		ldr	r0, .L108+8
 1275 003e 7968     		ldr	r1, [r7, #4]
 1276 0040 FFF7FEFF 		bl	Write_IO
 810:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1277              		.loc 1 810 0
 1278 0044 314B     		ldr	r3, .L108+12
 1279 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1280 0048 012B     		cmp	r3, #1
 1281 004a 01D0     		beq	.L100
 811:ProgrammingSteps.c ****         {
 812:ProgrammingSteps.c ****             return(FAILURE);
 1282              		.loc 1 812 0
 1283 004c 0023     		movs	r3, #0
 1284 004e 53E0     		b	.L97
 1285              	.L100:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 38


 813:ProgrammingSteps.c ****         }
 814:ProgrammingSteps.c **** 		
 815:ProgrammingSteps.c **** 		/* Set location of parameters */
 816:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1286              		.loc 1 816 0
 1287 0050 2F48     		ldr	r0, .L108+16
 1288 0052 2D49     		ldr	r1, .L108+8
 1289 0054 FFF7FEFF 		bl	Write_IO
 817:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1290              		.loc 1 817 0
 1291 0058 2C4B     		ldr	r3, .L108+12
 1292 005a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1293 005c 012B     		cmp	r3, #1
 1294 005e 01D0     		beq	.L101
 818:ProgrammingSteps.c ****         {
 819:ProgrammingSteps.c ****             return(FAILURE);
 1295              		.loc 1 819 0
 1296 0060 0023     		movs	r3, #0
 1297 0062 49E0     		b	.L97
 1298              	.L101:
 820:ProgrammingSteps.c ****         }
 821:ProgrammingSteps.c **** 		
 822:ProgrammingSteps.c **** 		/* Request SROM call */
 823:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_ERASE_ALL);
 1299              		.loc 1 823 0
 1300 0064 2B48     		ldr	r0, .L108+20
 1301 0066 2C49     		ldr	r1, .L108+24
 1302 0068 FFF7FEFF 		bl	Write_IO
 824:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1303              		.loc 1 824 0
 1304 006c 274B     		ldr	r3, .L108+12
 1305 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1306 0070 012B     		cmp	r3, #1
 1307 0072 01D0     		beq	.L102
 825:ProgrammingSteps.c ****         {
 826:ProgrammingSteps.c ****             return(FAILURE);
 1308              		.loc 1 826 0
 1309 0074 0023     		movs	r3, #0
 1310 0076 3FE0     		b	.L97
 1311              	.L102:
 827:ProgrammingSteps.c ****         }
 828:ProgrammingSteps.c **** 		
 829:ProgrammingSteps.c **** 		/* Read status of the operation */
 830:ProgrammingSteps.c ****     	result = PollSromStatus();
 1312              		.loc 1 830 0
 1313 0078 FFF7FEFF 		bl	PollSromStatus
 1314 007c 0346     		mov	r3, r0
 1315 007e 1A46     		mov	r2, r3
 1316 0080 1F4B     		ldr	r3, .L108
 1317 0082 1A70     		strb	r2, [r3]
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1318              		.loc 1 831 0
 1319 0084 1E4B     		ldr	r3, .L108
 1320 0086 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1321 0088 012B     		cmp	r3, #1
 1322 008a 01D0     		beq	.L103
 832:ProgrammingSteps.c **** 		{
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 39


 833:ProgrammingSteps.c ****     		return (FAILURE);
 1323              		.loc 1 833 0
 1324 008c 0023     		movs	r3, #0
 1325 008e 33E0     		b	.L97
 1326              	.L103:
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1327              		.loc 1 831 0
 1328 0090 31E0     		b	.L104
 1329              	.L99:
 834:ProgrammingSteps.c **** 		}
 835:ProgrammingSteps.c ****     }
 836:ProgrammingSteps.c **** 	
 837:ProgrammingSteps.c **** 	/* If the transition is from protected mode to open mode or protected mode to
 838:ProgrammingSteps.c **** 	protected mode only, call ERASE_ALL SROM command */
 839:ProgrammingSteps.c ****     else if (flow == PROT_XXX)
 1330              		.loc 1 839 0
 1331 0092 1C4B     		ldr	r3, .L108+4
 1332 0094 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1333 0096 022B     		cmp	r3, #2
 1334 0098 2DD1     		bne	.L104
 840:ProgrammingSteps.c ****     {
 841:ProgrammingSteps.c **** 		/* Move chip to open state: 0x01 corresponds to open state, 0x00 to
 842:ProgrammingSteps.c **** 		   macro 1 */
 843:ProgrammingSteps.c ****     	parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 1335              		.loc 1 843 0
 1336 009a 204B     		ldr	r3, .L108+28
 1337 009c 7B60     		str	r3, [r7, #4]
 844:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 845:ProgrammingSteps.c **** 					(0x01 << 16) + (0x00 << 24);
 846:ProgrammingSteps.c **** 		
 847:ProgrammingSteps.c **** 		/* Load the write protection command to SRAM */
 848:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, parameter1);
 1338              		.loc 1 848 0
 1339 009e 1C48     		ldr	r0, .L108+16
 1340 00a0 7968     		ldr	r1, [r7, #4]
 1341 00a2 FFF7FEFF 		bl	Write_IO
 849:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1342              		.loc 1 849 0
 1343 00a6 194B     		ldr	r3, .L108+12
 1344 00a8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1345 00aa 012B     		cmp	r3, #1
 1346 00ac 01D0     		beq	.L105
 850:ProgrammingSteps.c ****         {
 851:ProgrammingSteps.c ****             return(FAILURE);
 1347              		.loc 1 851 0
 1348 00ae 0023     		movs	r3, #0
 1349 00b0 22E0     		b	.L97
 1350              	.L105:
 852:ProgrammingSteps.c ****         }
 853:ProgrammingSteps.c ****     	
 854:ProgrammingSteps.c **** 		/* Request SROM call */
 855:ProgrammingSteps.c ****         Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1351              		.loc 1 855 0
 1352 00b2 1848     		ldr	r0, .L108+20
 1353 00b4 1A49     		ldr	r1, .L108+32
 1354 00b6 FFF7FEFF 		bl	Write_IO
 856:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 40


 1355              		.loc 1 856 0
 1356 00ba 144B     		ldr	r3, .L108+12
 1357 00bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1358 00be 012B     		cmp	r3, #1
 1359 00c0 01D0     		beq	.L106
 857:ProgrammingSteps.c ****         {
 858:ProgrammingSteps.c ****             return(FAILURE);
 1360              		.loc 1 858 0
 1361 00c2 0023     		movs	r3, #0
 1362 00c4 18E0     		b	.L97
 1363              	.L106:
 859:ProgrammingSteps.c ****         }
 860:ProgrammingSteps.c ****     	
 861:ProgrammingSteps.c **** 		/* Read status of the operation */
 862:ProgrammingSteps.c ****         result = PollSromStatus();
 1364              		.loc 1 862 0
 1365 00c6 FFF7FEFF 		bl	PollSromStatus
 1366 00ca 0346     		mov	r3, r0
 1367 00cc 1A46     		mov	r2, r3
 1368 00ce 0C4B     		ldr	r3, .L108
 1369 00d0 1A70     		strb	r2, [r3]
 863:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1370              		.loc 1 863 0
 1371 00d2 0B4B     		ldr	r3, .L108
 1372 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1373 00d6 012B     		cmp	r3, #1
 1374 00d8 01D0     		beq	.L107
 864:ProgrammingSteps.c ****         {
 865:ProgrammingSteps.c ****             return(FAILURE);
 1375              		.loc 1 865 0
 1376 00da 0023     		movs	r3, #0
 1377 00dc 0CE0     		b	.L97
 1378              	.L107:
 866:ProgrammingSteps.c ****         }
 867:ProgrammingSteps.c **** 		
 868:ProgrammingSteps.c **** 		/* Re-acquire chip in OPEN mode */
 869:ProgrammingSteps.c ****     	result = DeviceAcquire();
 1379              		.loc 1 869 0
 1380 00de FFF7FEFF 		bl	DeviceAcquire
 1381 00e2 0346     		mov	r3, r0
 1382 00e4 1A46     		mov	r2, r3
 1383 00e6 064B     		ldr	r3, .L108
 1384 00e8 1A70     		strb	r2, [r3]
 870:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1385              		.loc 1 870 0
 1386 00ea 054B     		ldr	r3, .L108
 1387 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1388 00ee 012B     		cmp	r3, #1
 1389 00f0 01D0     		beq	.L104
 871:ProgrammingSteps.c ****         {
 872:ProgrammingSteps.c ****             return(FAILURE);
 1390              		.loc 1 872 0
 1391 00f2 0023     		movs	r3, #0
 1392 00f4 00E0     		b	.L97
 1393              	.L104:
 873:ProgrammingSteps.c ****         }
 874:ProgrammingSteps.c ****     }
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 41


 875:ProgrammingSteps.c ****     
 876:ProgrammingSteps.c ****     return (SUCCESS);
 1394              		.loc 1 876 0
 1395 00f6 0123     		movs	r3, #1
 1396              	.L97:
 877:ProgrammingSteps.c **** }
 1397              		.loc 1 877 0
 1398 00f8 1846     		mov	r0, r3
 1399 00fa 0837     		adds	r7, r7, #8
 1400              		.cfi_def_cfa_offset 8
 1401 00fc BD46     		mov	sp, r7
 1402              		.cfi_def_cfa_register 13
 1403              		@ sp needed
 1404 00fe 80BD     		pop	{r7, pc}
 1405              	.L109:
 1406              		.align	2
 1407              	.L108:
 1408 0100 00000000 		.word	result
 1409 0104 00000000 		.word	flow
 1410 0108 00010020 		.word	536871168
 1411 010c 00000000 		.word	swd_PacketAck
 1412 0110 08001040 		.word	1074790408
 1413 0114 04001040 		.word	1074790404
 1414 0118 0A000080 		.word	-2147483638
 1415 011c B6E00100 		.word	123062
 1416 0120 0D000080 		.word	-2147483635
 1417              		.cfi_endproc
 1418              	.LFE72:
 1419              		.size	EraseAllFlash, .-EraseAllFlash
 1420              		.section	.text.ChecksumPrivileged,"ax",%progbits
 1421              		.align	2
 1422              		.global	ChecksumPrivileged
 1423              		.thumb
 1424              		.thumb_func
 1425              		.type	ChecksumPrivileged, %function
 1426              	ChecksumPrivileged:
 1427              	.LFB73:
 878:ProgrammingSteps.c **** 
 879:ProgrammingSteps.c **** /******************************************************************************
 880:ProgrammingSteps.c **** * Function Name: ChecksumPrivileged
 881:ProgrammingSteps.c **** *******************************************************************************
 882:ProgrammingSteps.c **** *
 883:ProgrammingSteps.c **** * Summary:
 884:ProgrammingSteps.c **** *  This is Step 4 of the programming sequence. In this Step, checksum of the 
 885:ProgrammingSteps.c **** *  privileged rows is calulated using system call to determine checksum. This 
 886:ProgrammingSteps.c **** *  step uses ChecksumAPI() API to store the checksum of privileged rows in a 
 887:ProgrammingSteps.c **** *  Checksum_Privileged global variable. This variable is used in step 9 to
 888:ProgrammingSteps.c **** *  calculate the checksum of user rows.
 889:ProgrammingSteps.c **** *
 890:ProgrammingSteps.c **** * Parameters:
 891:ProgrammingSteps.c **** *  None
 892:ProgrammingSteps.c **** *
 893:ProgrammingSteps.c **** * Return:
 894:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully calculated the checksum 
 895:ProgrammingSteps.c **** *            of privileged rows.
 896:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 897:ProgrammingSteps.c **** *			 message.
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 42


 898:ProgrammingSteps.c **** *
 899:ProgrammingSteps.c **** * Note:
 900:ProgrammingSteps.c **** *
 901:ProgrammingSteps.c **** ******************************************************************************/
 902:ProgrammingSteps.c **** unsigned char ChecksumPrivileged()
 903:ProgrammingSteps.c **** {        
 1428              		.loc 1 903 0
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 0
 1431              		@ frame_needed = 1, uses_anonymous_args = 0
 1432 0000 80B5     		push	{r7, lr}
 1433              		.cfi_def_cfa_offset 8
 1434              		.cfi_offset 7, -8
 1435              		.cfi_offset 14, -4
 1436 0002 00AF     		add	r7, sp, #0
 1437              		.cfi_def_cfa_register 7
 904:ProgrammingSteps.c ****     result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_Privileged);
 1438              		.loc 1 904 0
 1439 0004 4FF40040 		mov	r0, #32768
 1440 0008 0749     		ldr	r1, .L113
 1441 000a FFF7FEFF 		bl	ChecksumAPI
 1442 000e 0346     		mov	r3, r0
 1443 0010 1A46     		mov	r2, r3
 1444 0012 064B     		ldr	r3, .L113+4
 1445 0014 1A70     		strb	r2, [r3]
 905:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1446              		.loc 1 905 0
 1447 0016 054B     		ldr	r3, .L113+4
 1448 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1449 001a 012B     		cmp	r3, #1
 1450 001c 01D0     		beq	.L111
 906:ProgrammingSteps.c **** 	{
 907:ProgrammingSteps.c **** 		return (FAILURE);
 1451              		.loc 1 907 0
 1452 001e 0023     		movs	r3, #0
 1453 0020 00E0     		b	.L112
 1454              	.L111:
 908:ProgrammingSteps.c **** 	}
 909:ProgrammingSteps.c **** 	return(SUCCESS);
 1455              		.loc 1 909 0
 1456 0022 0123     		movs	r3, #1
 1457              	.L112:
 910:ProgrammingSteps.c **** }
 1458              		.loc 1 910 0
 1459 0024 1846     		mov	r0, r3
 1460 0026 80BD     		pop	{r7, pc}
 1461              	.L114:
 1462              		.align	2
 1463              	.L113:
 1464 0028 00000000 		.word	checksum_Privileged
 1465 002c 00000000 		.word	result
 1466              		.cfi_endproc
 1467              	.LFE73:
 1468              		.size	ChecksumPrivileged, .-ChecksumPrivileged
 1469              		.section	.text.ProgramFlash,"ax",%progbits
 1470              		.align	2
 1471              		.global	ProgramFlash
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 43


 1472              		.thumb
 1473              		.thumb_func
 1474              		.type	ProgramFlash, %function
 1475              	ProgramFlash:
 1476              	.LFB74:
 911:ProgrammingSteps.c **** 
 912:ProgrammingSteps.c **** /******************************************************************************
 913:ProgrammingSteps.c **** * Function Name: ProgramFlash
 914:ProgrammingSteps.c **** *******************************************************************************
 915:ProgrammingSteps.c **** *
 916:ProgrammingSteps.c **** * Summary:
 917:ProgrammingSteps.c **** *  This is Step 5 of the programming sequence. In this Step, the whole user 
 918:ProgrammingSteps.c **** *  flash is re-programmed with the programming data in the HEX File. This 
 919:ProgrammingSteps.c **** *  function uses LoadLatch() API to latch the row data in SRAM page latch buffer
 920:ProgrammingSteps.c **** *  which is then programmed to the specific row using system calls to program
 921:ProgrammingSteps.c **** *  row.
 922:ProgrammingSteps.c **** *
 923:ProgrammingSteps.c **** * Parameters:
 924:ProgrammingSteps.c **** *  None
 925:ProgrammingSteps.c **** *
 926:ProgrammingSteps.c **** * Return:
 927:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully programs entire flash
 928:ProgrammingSteps.c **** *			 region.
 929:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 930:ProgrammingSteps.c **** *			 message.
 931:ProgrammingSteps.c **** *
 932:ProgrammingSteps.c **** * Note:
 933:ProgrammingSteps.c **** * 
 934:ProgrammingSteps.c **** ******************************************************************************/
 935:ProgrammingSteps.c **** unsigned char ProgramFlash(void)
 936:ProgrammingSteps.c **** {
 1477              		.loc 1 936 0
 1478              		.cfi_startproc
 1479              		@ args = 0, pretend = 0, frame = 144
 1480              		@ frame_needed = 1, uses_anonymous_args = 0
 1481 0000 80B5     		push	{r7, lr}
 1482              		.cfi_def_cfa_offset 8
 1483              		.cfi_offset 7, -8
 1484              		.cfi_offset 14, -4
 1485 0002 A4B0     		sub	sp, sp, #144
 1486              		.cfi_def_cfa_offset 152
 1487 0004 00AF     		add	r7, sp, #0
 1488              		.cfi_def_cfa_register 7
 937:ProgrammingSteps.c **** 	unsigned char arrayID			= 0;
 1489              		.loc 1 937 0
 1490 0006 0023     		movs	r3, #0
 1491 0008 87F88D30 		strb	r3, [r7, #141]
 938:ProgrammingSteps.c **** 	unsigned char rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
 939:ProgrammingSteps.c **** 	
 940:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1492              		.loc 1 940 0
 1493 000c 0023     		movs	r3, #0
 1494 000e A7F88A30 		strh	r3, [r7, #138]	@ movhi
 941:ProgrammingSteps.c ****     unsigned short rowCount			= 0;
 1495              		.loc 1 941 0
 1496 0012 0023     		movs	r3, #0
 1497 0014 A7F88E30 		strh	r3, [r7, #142]	@ movhi
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 44


 942:ProgrammingSteps.c **** 	
 943:ProgrammingSteps.c **** 	unsigned long parameter1 		= 0;
 1498              		.loc 1 943 0
 1499 0018 0023     		movs	r3, #0
 1500 001a C7F88430 		str	r3, [r7, #132]
 944:ProgrammingSteps.c **** 	
 945:ProgrammingSteps.c ****     /* Get the total number of flash rows in the Target PSoC 4 device */
 946:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1501              		.loc 1 946 0
 1502 001e FFF7FEFF 		bl	GetFlashRowCount
 1503 0022 0346     		mov	r3, r0
 1504 0024 A7F88A30 		strh	r3, [r7, #138]	@ movhi
 947:ProgrammingSteps.c ****            
 948:ProgrammingSteps.c **** 	/* Program all flash rows */
 949:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1505              		.loc 1 949 0
 1506 0028 0023     		movs	r3, #0
 1507 002a A7F88E30 		strh	r3, [r7, #142]	@ movhi
 1508 002e 5DE0     		b	.L116
 1509              	.L123:
 950:ProgrammingSteps.c **** 	{
 951:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1510              		.loc 1 951 0
 1511 0030 B7F88E20 		ldrh	r2, [r7, #142]
 1512 0034 3B1D     		adds	r3, r7, #4
 1513 0036 1046     		mov	r0, r2
 1514 0038 1946     		mov	r1, r3
 1515 003a FFF7FEFF 		bl	HEX_ReadRowData
 952:ProgrammingSteps.c **** 		
 953:ProgrammingSteps.c **** 		arrayID = rowCount/ROWS_PER_ARRAY;
 1516              		.loc 1 953 0
 1517 003e B7F88E30 		ldrh	r3, [r7, #142]
 1518 0042 5B0A     		lsrs	r3, r3, #9
 1519 0044 9BB2     		uxth	r3, r3
 1520 0046 87F88D30 		strb	r3, [r7, #141]
 954:ProgrammingSteps.c **** 		
 955:ProgrammingSteps.c **** 		result = LoadLatch(arrayID, &rowData[0], FLASH_ROW_BYTE_SIZE_HEX_FILE);
 1521              		.loc 1 955 0
 1522 004a 97F88D20 		ldrb	r2, [r7, #141]	@ zero_extendqisi2
 1523 004e 3B1D     		adds	r3, r7, #4
 1524 0050 1046     		mov	r0, r2
 1525 0052 1946     		mov	r1, r3
 1526 0054 8022     		movs	r2, #128
 1527 0056 FFF7FEFF 		bl	LoadLatch
 1528 005a 0346     		mov	r3, r0
 1529 005c 1A46     		mov	r2, r3
 1530 005e 294B     		ldr	r3, .L125
 1531 0060 1A70     		strb	r2, [r3]
 956:ProgrammingSteps.c **** 		if(result != SUCCESS)
 1532              		.loc 1 956 0
 1533 0062 284B     		ldr	r3, .L125
 1534 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1535 0066 012B     		cmp	r3, #1
 1536 0068 01D0     		beq	.L117
 957:ProgrammingSteps.c **** 		{
 958:ProgrammingSteps.c **** 			return(FAILURE);
 1537              		.loc 1 958 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 45


 1538 006a 0023     		movs	r3, #0
 1539 006c 45E0     		b	.L124
 1540              	.L117:
 959:ProgrammingSteps.c **** 		}
 960:ProgrammingSteps.c **** 
 961:ProgrammingSteps.c **** 	    /* Load parameter1 with Program Row - SROM command */
 962:ProgrammingSteps.c **** 	    parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 963:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 964:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x000000FF) <<  16) +	//
 1541              		.loc 1 964 0
 1542 006e B7F88E30 		ldrh	r3, [r7, #142]
 1543 0072 DBB2     		uxtb	r3, r3
 1544 0074 1A04     		lsls	r2, r3, #16
 965:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x0000FF00) << 16));
 1545              		.loc 1 965 0
 1546 0076 B7F88E30 		ldrh	r3, [r7, #142]
 1547 007a 03F47F43 		and	r3, r3, #65280
 1548 007e 1B04     		lsls	r3, r3, #16
 962:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 1549              		.loc 1 962 0
 1550 0080 1344     		add	r3, r3, r2
 1551 0082 03F55943 		add	r3, r3, #55552
 1552 0086 B633     		adds	r3, r3, #182
 1553 0088 C7F88430 		str	r3, [r7, #132]
 966:ProgrammingSteps.c ****         
 967:ProgrammingSteps.c **** 		/* Write parameters in SRAM */
 968:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE+0x00, parameter1);
 1554              		.loc 1 968 0
 1555 008c 1E48     		ldr	r0, .L125+4
 1556 008e D7F88410 		ldr	r1, [r7, #132]
 1557 0092 FFF7FEFF 		bl	Write_IO
 969:ProgrammingSteps.c **** 	   	if( swd_PacketAck != SWD_OK_ACK )
 1558              		.loc 1 969 0
 1559 0096 1D4B     		ldr	r3, .L125+8
 1560 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1561 009a 012B     		cmp	r3, #1
 1562 009c 01D0     		beq	.L119
 970:ProgrammingSteps.c **** 	    {
 971:ProgrammingSteps.c **** 	        return (FAILURE);
 1563              		.loc 1 971 0
 1564 009e 0023     		movs	r3, #0
 1565 00a0 2BE0     		b	.L124
 1566              	.L119:
 972:ProgrammingSteps.c **** 	    }
 973:ProgrammingSteps.c **** 	    
 974:ProgrammingSteps.c **** 		/* Set location of parameters */
 975:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1567              		.loc 1 975 0
 1568 00a2 1B48     		ldr	r0, .L125+12
 1569 00a4 1849     		ldr	r1, .L125+4
 1570 00a6 FFF7FEFF 		bl	Write_IO
 976:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1571              		.loc 1 976 0
 1572 00aa 184B     		ldr	r3, .L125+8
 1573 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1574 00ae 012B     		cmp	r3, #1
 1575 00b0 01D0     		beq	.L120
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 46


 977:ProgrammingSteps.c **** 	    {
 978:ProgrammingSteps.c **** 	        return (FAILURE);
 1576              		.loc 1 978 0
 1577 00b2 0023     		movs	r3, #0
 1578 00b4 21E0     		b	.L124
 1579              	.L120:
 979:ProgrammingSteps.c **** 	    }
 980:ProgrammingSteps.c **** 	    
 981:ProgrammingSteps.c **** 		/* Request SROM operation */
 982:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_PROGRAM_ROW);
 1580              		.loc 1 982 0
 1581 00b6 1748     		ldr	r0, .L125+16
 1582 00b8 1749     		ldr	r1, .L125+20
 1583 00ba FFF7FEFF 		bl	Write_IO
 983:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1584              		.loc 1 983 0
 1585 00be 134B     		ldr	r3, .L125+8
 1586 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1587 00c2 012B     		cmp	r3, #1
 1588 00c4 01D0     		beq	.L121
 984:ProgrammingSteps.c **** 	    {
 985:ProgrammingSteps.c **** 	        return (FAILURE);
 1589              		.loc 1 985 0
 1590 00c6 0023     		movs	r3, #0
 1591 00c8 17E0     		b	.L124
 1592              	.L121:
 986:ProgrammingSteps.c **** 	    }
 987:ProgrammingSteps.c **** 	    
 988:ProgrammingSteps.c **** 		/* Read status of the operation */
 989:ProgrammingSteps.c **** 	    result = PollSromStatus();
 1593              		.loc 1 989 0
 1594 00ca FFF7FEFF 		bl	PollSromStatus
 1595 00ce 0346     		mov	r3, r0
 1596 00d0 1A46     		mov	r2, r3
 1597 00d2 0C4B     		ldr	r3, .L125
 1598 00d4 1A70     		strb	r2, [r3]
 990:ProgrammingSteps.c **** 	    if ( result != SROM_SUCCESS )
 1599              		.loc 1 990 0
 1600 00d6 0B4B     		ldr	r3, .L125
 1601 00d8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1602 00da 012B     		cmp	r3, #1
 1603 00dc 01D0     		beq	.L122
 991:ProgrammingSteps.c ****         {
 992:ProgrammingSteps.c ****             return (FAILURE);
 1604              		.loc 1 992 0
 1605 00de 0023     		movs	r3, #0
 1606 00e0 0BE0     		b	.L124
 1607              	.L122:
 949:ProgrammingSteps.c **** 	{
 1608              		.loc 1 949 0 discriminator 2
 1609 00e2 B7F88E30 		ldrh	r3, [r7, #142]
 1610 00e6 0133     		adds	r3, r3, #1
 1611 00e8 A7F88E30 		strh	r3, [r7, #142]	@ movhi
 1612              	.L116:
 949:ProgrammingSteps.c **** 	{
 1613              		.loc 1 949 0 is_stmt 0 discriminator 1
 1614 00ec B7F88E20 		ldrh	r2, [r7, #142]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 47


 1615 00f0 B7F88A30 		ldrh	r3, [r7, #138]
 1616 00f4 9A42     		cmp	r2, r3
 1617 00f6 9BD3     		bcc	.L123
 993:ProgrammingSteps.c ****         }
 994:ProgrammingSteps.c ****         
 995:ProgrammingSteps.c **** 	}
 996:ProgrammingSteps.c **** 	return ( SUCCESS );
 1618              		.loc 1 996 0 is_stmt 1
 1619 00f8 0123     		movs	r3, #1
 1620              	.L124:
 997:ProgrammingSteps.c **** }
 1621              		.loc 1 997 0 discriminator 1
 1622 00fa 1846     		mov	r0, r3
 1623 00fc 9037     		adds	r7, r7, #144
 1624              		.cfi_def_cfa_offset 8
 1625 00fe BD46     		mov	sp, r7
 1626              		.cfi_def_cfa_register 13
 1627              		@ sp needed
 1628 0100 80BD     		pop	{r7, pc}
 1629              	.L126:
 1630 0102 00BF     		.align	2
 1631              	.L125:
 1632 0104 00000000 		.word	result
 1633 0108 00010020 		.word	536871168
 1634 010c 00000000 		.word	swd_PacketAck
 1635 0110 08001040 		.word	1074790408
 1636 0114 04001040 		.word	1074790404
 1637 0118 06000080 		.word	-2147483642
 1638              		.cfi_endproc
 1639              	.LFE74:
 1640              		.size	ProgramFlash, .-ProgramFlash
 1641              		.section	.text.VerifyFlash,"ax",%progbits
 1642              		.align	2
 1643              		.global	VerifyFlash
 1644              		.thumb
 1645              		.thumb_func
 1646              		.type	VerifyFlash, %function
 1647              	VerifyFlash:
 1648              	.LFB75:
 998:ProgrammingSteps.c **** 
 999:ProgrammingSteps.c **** /******************************************************************************
1000:ProgrammingSteps.c **** * Function Name: VerifyFlash
1001:ProgrammingSteps.c **** *******************************************************************************
1002:ProgrammingSteps.c **** *
1003:ProgrammingSteps.c **** * Summary:
1004:ProgrammingSteps.c **** *  This is Step 6 of the programming sequence. This is an optional step as we
1005:ProgrammingSteps.c **** *  verify the checksum explicitly. In this Step, flash region is directly read
1006:ProgrammingSteps.c **** *  using Read_IO API defined in SWD_UpperPacketLayer.h and compared with the 
1007:ProgrammingSteps.c **** *  HEX File.
1008:ProgrammingSteps.c **** *
1009:ProgrammingSteps.c **** * Parameters:
1010:ProgrammingSteps.c **** *  None
1011:ProgrammingSteps.c **** *
1012:ProgrammingSteps.c **** * Return:
1013:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the entire flash
1014:ProgrammingSteps.c **** *		     with the HEX File.
1015:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 48


1016:ProgrammingSteps.c **** *			 message.
1017:ProgrammingSteps.c **** *
1018:ProgrammingSteps.c **** * Note:
1019:ProgrammingSteps.c **** * 
1020:ProgrammingSteps.c **** *******************************************************************************************/
1021:ProgrammingSteps.c **** unsigned char VerifyFlash(void)
1022:ProgrammingSteps.c **** { 
 1649              		.loc 1 1022 0
 1650              		.cfi_startproc
 1651              		@ args = 0, pretend = 0, frame = 272
 1652              		@ frame_needed = 1, uses_anonymous_args = 0
 1653 0000 80B5     		push	{r7, lr}
 1654              		.cfi_def_cfa_offset 8
 1655              		.cfi_offset 7, -8
 1656              		.cfi_offset 14, -4
 1657 0002 C4B0     		sub	sp, sp, #272
 1658              		.cfi_def_cfa_offset 280
 1659 0004 00AF     		add	r7, sp, #0
 1660              		.cfi_def_cfa_register 7
1023:ProgrammingSteps.c ****     unsigned long  flashData 		= 0;    
 1661              		.loc 1 1023 0
 1662 0006 0023     		movs	r3, #0
 1663 0008 C7F80031 		str	r3, [r7, #256]
1024:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1664              		.loc 1 1024 0
 1665 000c 0023     		movs	r3, #0
 1666 000e A7F80A31 		strh	r3, [r7, #266]	@ movhi
1025:ProgrammingSteps.c **** 	unsigned long rowAddress 		= 0;
 1667              		.loc 1 1025 0
 1668 0012 0023     		movs	r3, #0
 1669 0014 C7F80431 		str	r3, [r7, #260]
1026:ProgrammingSteps.c ****     unsigned short rowCount;
1027:ProgrammingSteps.c ****     unsigned short  i;
1028:ProgrammingSteps.c ****     unsigned char  rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1029:ProgrammingSteps.c **** 	unsigned char  chipData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1030:ProgrammingSteps.c **** 	
1031:ProgrammingSteps.c **** 	/* Get the total number of flash rows in the Target PSoC 4 device */
1032:ProgrammingSteps.c **** 	numOfFlashRows   = GetFlashRowCount();
 1670              		.loc 1 1032 0
 1671 0018 FFF7FEFF 		bl	GetFlashRowCount
 1672 001c 0346     		mov	r3, r0
 1673 001e A7F80A31 		strh	r3, [r7, #266]	@ movhi
1033:ProgrammingSteps.c **** 
1034:ProgrammingSteps.c **** 	/* Read and Verify Flash rows */
1035:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1674              		.loc 1 1035 0
 1675 0022 0023     		movs	r3, #0
 1676 0024 A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1677 0028 74E0     		b	.L128
 1678              	.L136:
1036:ProgrammingSteps.c **** 	{
1037:ProgrammingSteps.c **** 		/* Read row from hex file */
1038:ProgrammingSteps.c **** 		
1039:ProgrammingSteps.c **** 		/* linear address of row in flash */
1040:ProgrammingSteps.c ****     	rowAddress = FLASH_ROW_BYTE_SIZE_HEX_FILE * rowCount;
 1679              		.loc 1 1040 0
 1680 002a B7F80E31 		ldrh	r3, [r7, #270]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 49


 1681 002e DB01     		lsls	r3, r3, #7
 1682 0030 C7F80431 		str	r3, [r7, #260]
1041:ProgrammingSteps.c ****     	
1042:ProgrammingSteps.c **** 		/* Extract 128-byte row from the hex-file from address: rowCount into
1043:ProgrammingSteps.c **** 		   buffer - rowData. */
1044:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1683              		.loc 1 1044 0
 1684 0034 B7F80E21 		ldrh	r2, [r7, #270]
 1685 0038 07F18003 		add	r3, r7, #128
 1686 003c 1046     		mov	r0, r2
 1687 003e 1946     		mov	r1, r3
 1688 0040 FFF7FEFF 		bl	HEX_ReadRowData
1045:ProgrammingSteps.c **** 
1046:ProgrammingSteps.c ****     	/* Read row from chip */
1047:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 1689              		.loc 1 1047 0
 1690 0044 0023     		movs	r3, #0
 1691 0046 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1692 004a 37E0     		b	.L129
 1693              	.L132:
1048:ProgrammingSteps.c ****     	{
1049:ProgrammingSteps.c **** 			/* Read flash via AHB-interface */
1050:ProgrammingSteps.c ****        		Read_IO( rowAddress + i, &flashData);
 1694              		.loc 1 1050 0
 1695 004c B7F80C21 		ldrh	r2, [r7, #268]
 1696 0050 D7F80431 		ldr	r3, [r7, #260]
 1697 0054 1A44     		add	r2, r2, r3
 1698 0056 07F58073 		add	r3, r7, #256
 1699 005a 1046     		mov	r0, r2
 1700 005c 1946     		mov	r1, r3
 1701 005e FFF7FEFF 		bl	Read_IO
1051:ProgrammingSteps.c ****             if( swd_PacketAck != SWD_OK_ACK )
 1702              		.loc 1 1051 0
 1703 0062 324B     		ldr	r3, .L138
 1704 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1705 0066 012B     		cmp	r3, #1
 1706 0068 01D0     		beq	.L130
1052:ProgrammingSteps.c ****     	    {
1053:ProgrammingSteps.c ****     	        return (FAILURE);
 1707              		.loc 1 1053 0
 1708 006a 0023     		movs	r3, #0
 1709 006c 59E0     		b	.L137
 1710              	.L130:
1054:ProgrammingSteps.c ****     	    }
1055:ProgrammingSteps.c ****             
1056:ProgrammingSteps.c ****             chipData[i + 0] = (flashData >> 0) & 0xFF;
 1711              		.loc 1 1056 0 discriminator 2
 1712 006e B7F80C31 		ldrh	r3, [r7, #268]
 1713 0072 D7F80021 		ldr	r2, [r7, #256]
 1714 0076 D1B2     		uxtb	r1, r2
 1715 0078 3A46     		mov	r2, r7
 1716 007a D154     		strb	r1, [r2, r3]
1057:ProgrammingSteps.c ****             chipData[i + 1] = (flashData >> 8) & 0xFF;
 1717              		.loc 1 1057 0 discriminator 2
 1718 007c B7F80C31 		ldrh	r3, [r7, #268]
 1719 0080 0133     		adds	r3, r3, #1
 1720 0082 D7F80021 		ldr	r2, [r7, #256]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 50


 1721 0086 120A     		lsrs	r2, r2, #8
 1722 0088 D1B2     		uxtb	r1, r2
 1723 008a 3A46     		mov	r2, r7
 1724 008c D154     		strb	r1, [r2, r3]
1058:ProgrammingSteps.c ****             chipData[i + 2] = (flashData >> 16) & 0xFF;
 1725              		.loc 1 1058 0 discriminator 2
 1726 008e B7F80C31 		ldrh	r3, [r7, #268]
 1727 0092 0233     		adds	r3, r3, #2
 1728 0094 D7F80021 		ldr	r2, [r7, #256]
 1729 0098 120C     		lsrs	r2, r2, #16
 1730 009a D1B2     		uxtb	r1, r2
 1731 009c 3A46     		mov	r2, r7
 1732 009e D154     		strb	r1, [r2, r3]
1059:ProgrammingSteps.c ****             chipData[i + 3] = (flashData >> 24) & 0xFF;
 1733              		.loc 1 1059 0 discriminator 2
 1734 00a0 B7F80C31 		ldrh	r3, [r7, #268]
 1735 00a4 0333     		adds	r3, r3, #3
 1736 00a6 D7F80021 		ldr	r2, [r7, #256]
 1737 00aa 120E     		lsrs	r2, r2, #24
 1738 00ac D1B2     		uxtb	r1, r2
 1739 00ae 3A46     		mov	r2, r7
 1740 00b0 D154     		strb	r1, [r2, r3]
1047:ProgrammingSteps.c ****     	{
 1741              		.loc 1 1047 0 discriminator 2
 1742 00b2 B7F80C31 		ldrh	r3, [r7, #268]	@ movhi
 1743 00b6 0433     		adds	r3, r3, #4
 1744 00b8 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1745              	.L129:
1047:ProgrammingSteps.c ****     	{
 1746              		.loc 1 1047 0 is_stmt 0 discriminator 1
 1747 00bc B7F80C31 		ldrh	r3, [r7, #268]
 1748 00c0 7F2B     		cmp	r3, #127
 1749 00c2 C3D9     		bls	.L132
1060:ProgrammingSteps.c ****     	}
1061:ProgrammingSteps.c **** 
1062:ProgrammingSteps.c ****     	/* Compare the row data of HEX file with chip data */
1063:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i++)
 1750              		.loc 1 1063 0 is_stmt 1
 1751 00c4 0023     		movs	r3, #0
 1752 00c6 A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1753 00ca 1AE0     		b	.L133
 1754              	.L135:
1064:ProgrammingSteps.c ****     	{
1065:ProgrammingSteps.c ****        		if (chipData[i] != rowData[i])
 1755              		.loc 1 1065 0
 1756 00cc B7F80C31 		ldrh	r3, [r7, #268]
 1757 00d0 3A46     		mov	r2, r7
 1758 00d2 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 1759 00d4 B7F80C31 		ldrh	r3, [r7, #268]
 1760 00d8 07F58871 		add	r1, r7, #272
 1761 00dc 0B44     		add	r3, r3, r1
 1762 00de 13F8903C 		ldrb	r3, [r3, #-144]	@ zero_extendqisi2
 1763 00e2 9A42     		cmp	r2, r3
 1764 00e4 08D0     		beq	.L134
1066:ProgrammingSteps.c **** 			{
1067:ProgrammingSteps.c **** 				swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1765              		.loc 1 1067 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 51


 1766 00e6 114B     		ldr	r3, .L138
 1767 00e8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1768 00ea 43F04003 		orr	r3, r3, #64
 1769 00ee DAB2     		uxtb	r2, r3
 1770 00f0 0E4B     		ldr	r3, .L138
 1771 00f2 1A70     		strb	r2, [r3]
1068:ProgrammingSteps.c **** 				return ( FAILURE );
 1772              		.loc 1 1068 0
 1773 00f4 0023     		movs	r3, #0
 1774 00f6 14E0     		b	.L137
 1775              	.L134:
1063:ProgrammingSteps.c ****     	{
 1776              		.loc 1 1063 0 discriminator 2
 1777 00f8 B7F80C31 		ldrh	r3, [r7, #268]
 1778 00fc 0133     		adds	r3, r3, #1
 1779 00fe A7F80C31 		strh	r3, [r7, #268]	@ movhi
 1780              	.L133:
1063:ProgrammingSteps.c ****     	{
 1781              		.loc 1 1063 0 is_stmt 0 discriminator 1
 1782 0102 B7F80C31 		ldrh	r3, [r7, #268]
 1783 0106 7F2B     		cmp	r3, #127
 1784 0108 E0D9     		bls	.L135
1035:ProgrammingSteps.c **** 	{
 1785              		.loc 1 1035 0 is_stmt 1 discriminator 2
 1786 010a B7F80E31 		ldrh	r3, [r7, #270]
 1787 010e 0133     		adds	r3, r3, #1
 1788 0110 A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1789              	.L128:
1035:ProgrammingSteps.c **** 	{
 1790              		.loc 1 1035 0 is_stmt 0 discriminator 1
 1791 0114 B7F80E21 		ldrh	r2, [r7, #270]
 1792 0118 B7F80A31 		ldrh	r3, [r7, #266]
 1793 011c 9A42     		cmp	r2, r3
 1794 011e 84D3     		bcc	.L136
1069:ProgrammingSteps.c **** 			}
1070:ProgrammingSteps.c ****     	}
1071:ProgrammingSteps.c **** 	}
1072:ProgrammingSteps.c **** 	return ( SUCCESS );
 1795              		.loc 1 1072 0 is_stmt 1
 1796 0120 0123     		movs	r3, #1
 1797              	.L137:
1073:ProgrammingSteps.c **** }
 1798              		.loc 1 1073 0 discriminator 1
 1799 0122 1846     		mov	r0, r3
 1800 0124 07F58877 		add	r7, r7, #272
 1801              		.cfi_def_cfa_offset 8
 1802 0128 BD46     		mov	sp, r7
 1803              		.cfi_def_cfa_register 13
 1804              		@ sp needed
 1805 012a 80BD     		pop	{r7, pc}
 1806              	.L139:
 1807              		.align	2
 1808              	.L138:
 1809 012c 00000000 		.word	swd_PacketAck
 1810              		.cfi_endproc
 1811              	.LFE75:
 1812              		.size	VerifyFlash, .-VerifyFlash
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 52


 1813              		.section	.text.ProgramProtectionSettings,"ax",%progbits
 1814              		.align	2
 1815              		.global	ProgramProtectionSettings
 1816              		.thumb
 1817              		.thumb_func
 1818              		.type	ProgramProtectionSettings, %function
 1819              	ProgramProtectionSettings:
 1820              	.LFB76:
1074:ProgrammingSteps.c **** 
1075:ProgrammingSteps.c **** /******************************************************************************
1076:ProgrammingSteps.c **** * Function Name: ProgramProtectionSettings
1077:ProgrammingSteps.c **** *******************************************************************************
1078:ProgrammingSteps.c **** *
1079:ProgrammingSteps.c **** * Summary:
1080:ProgrammingSteps.c **** *  This is Step 7 of the programming sequence. In this step, Chip protection 
1081:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and 
1082:ProgrammingSteps.c **** *  programmed to the specific loctions in the flash.
1083:ProgrammingSteps.c **** *
1084:ProgrammingSteps.c **** * Parameters:
1085:ProgrammingSteps.c **** *  None
1086:ProgrammingSteps.c **** *
1087:ProgrammingSteps.c **** * Return:
1088:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully writes the protection
1089:ProgrammingSteps.c **** *			 settings.
1090:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1091:ProgrammingSteps.c **** *			 message.
1092:ProgrammingSteps.c **** *
1093:ProgrammingSteps.c **** * Note:
1094:ProgrammingSteps.c **** *
1095:ProgrammingSteps.c **** ******************************************************************************/
1096:ProgrammingSteps.c **** unsigned char ProgramProtectionSettings(void)
1097:ProgrammingSteps.c **** {
 1821              		.loc 1 1097 0
 1822              		.cfi_startproc
 1823              		@ args = 0, pretend = 0, frame = 80
 1824              		@ frame_needed = 1, uses_anonymous_args = 0
 1825 0000 80B5     		push	{r7, lr}
 1826              		.cfi_def_cfa_offset 8
 1827              		.cfi_offset 7, -8
 1828              		.cfi_offset 14, -4
 1829 0002 94B0     		sub	sp, sp, #80
 1830              		.cfi_def_cfa_offset 88
 1831 0004 00AF     		add	r7, sp, #0
 1832              		.cfi_def_cfa_register 7
1098:ProgrammingSteps.c **** 	unsigned char  arrayID = 0;
 1833              		.loc 1 1098 0
 1834 0006 0023     		movs	r3, #0
 1835 0008 87F84F30 		strb	r3, [r7, #79]
1099:ProgrammingSteps.c ****     unsigned char  arrayMax = 0;
 1836              		.loc 1 1099 0
 1837 000c 0023     		movs	r3, #0
 1838 000e 87F84E30 		strb	r3, [r7, #78]
1100:ProgrammingSteps.c ****     unsigned char  rowProtectionByteSize = 0;
 1839              		.loc 1 1100 0
 1840 0012 0023     		movs	r3, #0
 1841 0014 87F84D30 		strb	r3, [r7, #77]
1101:ProgrammingSteps.c **** 	unsigned char  rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 53


1102:ProgrammingSteps.c **** 	unsigned char  chipProtectionData_Hex;
1103:ProgrammingSteps.c **** 	
1104:ProgrammingSteps.c **** 	unsigned short numOfFlashRows = 0;
 1842              		.loc 1 1104 0
 1843 0018 0023     		movs	r3, #0
 1844 001a A7F84A30 		strh	r3, [r7, #74]	@ movhi
1105:ProgrammingSteps.c **** 	
1106:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1845              		.loc 1 1106 0
 1846 001e 0023     		movs	r3, #0
 1847 0020 7B64     		str	r3, [r7, #68]
1107:ProgrammingSteps.c **** 	
1108:ProgrammingSteps.c **** 	/* Get total number of flash rows to determine the size of row protection data
1109:ProgrammingSteps.c **** 	   and arrayID */
1110:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1848              		.loc 1 1110 0
 1849 0022 FFF7FEFF 		bl	GetFlashRowCount
 1850 0026 0346     		mov	r3, r0
 1851 0028 A7F84A30 		strh	r3, [r7, #74]	@ movhi
1111:ProgrammingSteps.c ****     
1112:ProgrammingSteps.c **** 	arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 1852              		.loc 1 1112 0
 1853 002c B7F84A30 		ldrh	r3, [r7, #74]
 1854 0030 5B0A     		lsrs	r3, r3, #9
 1855 0032 9BB2     		uxth	r3, r3
 1856 0034 87F84E30 		strb	r3, [r7, #78]
1113:ProgrammingSteps.c ****     
1114:ProgrammingSteps.c ****     rowProtectionByteSize = numOfFlashRows / (8 * arrayMax);
 1857              		.loc 1 1114 0
 1858 0038 B7F84A20 		ldrh	r2, [r7, #74]
 1859 003c 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 1860 0040 DB00     		lsls	r3, r3, #3
 1861 0042 92FBF3F3 		sdiv	r3, r2, r3
 1862 0046 87F84D30 		strb	r3, [r7, #77]
1115:ProgrammingSteps.c **** 	
1116:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 1863              		.loc 1 1116 0
 1864 004a FB1C     		adds	r3, r7, #3
 1865 004c 1846     		mov	r0, r3
 1866 004e FFF7FEFF 		bl	HEX_ReadChipProtectionData
1117:ProgrammingSteps.c ****  
1118:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++)
 1867              		.loc 1 1118 0
 1868 0052 0023     		movs	r3, #0
 1869 0054 87F84F30 		strb	r3, [r7, #79]
 1870 0058 4DE0     		b	.L141
 1871              	.L147:
1119:ProgrammingSteps.c ****     {
1120:ProgrammingSteps.c ****         
1121:ProgrammingSteps.c ****         HEX_ReadRowProtectionData(rowProtectionByteSize, &rowProtectionData[0], arrayID);
 1872              		.loc 1 1121 0
 1873 005a 97F84D10 		ldrb	r1, [r7, #77]	@ zero_extendqisi2
 1874 005e 3A1D     		adds	r2, r7, #4
 1875 0060 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1876 0064 0846     		mov	r0, r1
 1877 0066 1146     		mov	r1, r2
 1878 0068 1A46     		mov	r2, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 54


 1879 006a FFF7FEFF 		bl	HEX_ReadRowProtectionData
1122:ProgrammingSteps.c **** 
1123:ProgrammingSteps.c ****     	/* Load protection setting of current macro into volatile latch using 
1124:ProgrammingSteps.c ****     	   LoadLatch API */
1125:ProgrammingSteps.c ****     	result = LoadLatch(arrayID, &rowProtectionData[0], rowProtectionByteSize);
 1880              		.loc 1 1125 0
 1881 006e 97F84D30 		ldrb	r3, [r7, #77]	@ zero_extendqisi2
 1882 0072 9BB2     		uxth	r3, r3
 1883 0074 97F84F10 		ldrb	r1, [r7, #79]	@ zero_extendqisi2
 1884 0078 3A1D     		adds	r2, r7, #4
 1885 007a 0846     		mov	r0, r1
 1886 007c 1146     		mov	r1, r2
 1887 007e 1A46     		mov	r2, r3
 1888 0080 FFF7FEFF 		bl	LoadLatch
 1889 0084 0346     		mov	r3, r0
 1890 0086 1A46     		mov	r2, r3
 1891 0088 204B     		ldr	r3, .L149
 1892 008a 1A70     		strb	r2, [r3]
1126:ProgrammingSteps.c ****     	
1127:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1893              		.loc 1 1127 0
 1894 008c 1F4B     		ldr	r3, .L149
 1895 008e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1896 0090 012B     		cmp	r3, #1
 1897 0092 01D0     		beq	.L142
1128:ProgrammingSteps.c ****     	{
1129:ProgrammingSteps.c ****     		return(FAILURE);
 1898              		.loc 1 1129 0
 1899 0094 0023     		movs	r3, #0
 1900 0096 35E0     		b	.L148
 1901              	.L142:
1130:ProgrammingSteps.c ****     	}
1131:ProgrammingSteps.c **** 
1132:ProgrammingSteps.c ****     	/* Program protection setting into supervisory row */
1133:ProgrammingSteps.c ****     	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
1134:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
1135:ProgrammingSteps.c ****     				((unsigned long)chipProtectionData_Hex << 16) + ((unsigned long)arrayID << 24));
 1902              		.loc 1 1135 0
 1903 0098 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1904 009a 1A04     		lsls	r2, r3, #16
 1905 009c 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1906 00a0 1B06     		lsls	r3, r3, #24
1133:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 1907              		.loc 1 1133 0
 1908 00a2 1344     		add	r3, r3, r2
 1909 00a4 03F56043 		add	r3, r3, #57344
 1910 00a8 B633     		adds	r3, r3, #182
 1911 00aa 7B64     		str	r3, [r7, #68]
1136:ProgrammingSteps.c ****     	
1137:ProgrammingSteps.c ****     	/* Load parameter1 in CPUSS_SYSARG register */
1138:ProgrammingSteps.c ****     	Write_IO(CPUSS_SYSARG, parameter1);	    
 1912              		.loc 1 1138 0
 1913 00ac 1848     		ldr	r0, .L149+4
 1914 00ae 796C     		ldr	r1, [r7, #68]
 1915 00b0 FFF7FEFF 		bl	Write_IO
1139:ProgrammingSteps.c ****     	
1140:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 55


 1916              		.loc 1 1140 0
 1917 00b4 174B     		ldr	r3, .L149+8
 1918 00b6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1919 00b8 012B     		cmp	r3, #1
 1920 00ba 01D0     		beq	.L144
1141:ProgrammingSteps.c ****         {
1142:ProgrammingSteps.c ****             return (FAILURE);
 1921              		.loc 1 1142 0
 1922 00bc 0023     		movs	r3, #0
 1923 00be 21E0     		b	.L148
 1924              	.L144:
1143:ProgrammingSteps.c ****         }
1144:ProgrammingSteps.c ****     	
1145:ProgrammingSteps.c ****     	/* Request SROM call */
1146:ProgrammingSteps.c ****         Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1925              		.loc 1 1146 0
 1926 00c0 1548     		ldr	r0, .L149+12
 1927 00c2 1649     		ldr	r1, .L149+16
 1928 00c4 FFF7FEFF 		bl	Write_IO
1147:ProgrammingSteps.c **** 
1148:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1929              		.loc 1 1148 0
 1930 00c8 124B     		ldr	r3, .L149+8
 1931 00ca 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1932 00cc 012B     		cmp	r3, #1
 1933 00ce 01D0     		beq	.L145
1149:ProgrammingSteps.c ****         {
1150:ProgrammingSteps.c ****             return (FAILURE);
 1934              		.loc 1 1150 0
 1935 00d0 0023     		movs	r3, #0
 1936 00d2 17E0     		b	.L148
 1937              	.L145:
1151:ProgrammingSteps.c ****         }
1152:ProgrammingSteps.c **** 
1153:ProgrammingSteps.c ****     	/* Read status of the operation */
1154:ProgrammingSteps.c ****     	result = PollSromStatus();
 1938              		.loc 1 1154 0
 1939 00d4 FFF7FEFF 		bl	PollSromStatus
 1940 00d8 0346     		mov	r3, r0
 1941 00da 1A46     		mov	r2, r3
 1942 00dc 0B4B     		ldr	r3, .L149
 1943 00de 1A70     		strb	r2, [r3]
1155:ProgrammingSteps.c **** 
1156:ProgrammingSteps.c ****     	if( result != SROM_SUCCESS )
 1944              		.loc 1 1156 0
 1945 00e0 0A4B     		ldr	r3, .L149
 1946 00e2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1947 00e4 012B     		cmp	r3, #1
 1948 00e6 01D0     		beq	.L146
1157:ProgrammingSteps.c ****         {
1158:ProgrammingSteps.c ****             return (FAILURE);
 1949              		.loc 1 1158 0
 1950 00e8 0023     		movs	r3, #0
 1951 00ea 0BE0     		b	.L148
 1952              	.L146:
1118:ProgrammingSteps.c ****     {
 1953              		.loc 1 1118 0 discriminator 2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 56


 1954 00ec 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1955 00f0 0133     		adds	r3, r3, #1
 1956 00f2 87F84F30 		strb	r3, [r7, #79]
 1957              	.L141:
1118:ProgrammingSteps.c ****     {
 1958              		.loc 1 1118 0 is_stmt 0 discriminator 1
 1959 00f6 97F84F20 		ldrb	r2, [r7, #79]	@ zero_extendqisi2
 1960 00fa 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 1961 00fe 9A42     		cmp	r2, r3
 1962 0100 ABD3     		bcc	.L147
1159:ProgrammingSteps.c ****         }
1160:ProgrammingSteps.c ****     
1161:ProgrammingSteps.c ****     }
1162:ProgrammingSteps.c **** 
1163:ProgrammingSteps.c **** 	return (SUCCESS);
 1963              		.loc 1 1163 0 is_stmt 1
 1964 0102 0123     		movs	r3, #1
 1965              	.L148:
1164:ProgrammingSteps.c **** }
 1966              		.loc 1 1164 0 discriminator 1
 1967 0104 1846     		mov	r0, r3
 1968 0106 5037     		adds	r7, r7, #80
 1969              		.cfi_def_cfa_offset 8
 1970 0108 BD46     		mov	sp, r7
 1971              		.cfi_def_cfa_register 13
 1972              		@ sp needed
 1973 010a 80BD     		pop	{r7, pc}
 1974              	.L150:
 1975              		.align	2
 1976              	.L149:
 1977 010c 00000000 		.word	result
 1978 0110 08001040 		.word	1074790408
 1979 0114 00000000 		.word	swd_PacketAck
 1980 0118 04001040 		.word	1074790404
 1981 011c 0D000080 		.word	-2147483635
 1982              		.cfi_endproc
 1983              	.LFE76:
 1984              		.size	ProgramProtectionSettings, .-ProgramProtectionSettings
 1985              		.section	.text.VerifyProtectionSettings,"ax",%progbits
 1986              		.align	2
 1987              		.global	VerifyProtectionSettings
 1988              		.thumb
 1989              		.thumb_func
 1990              		.type	VerifyProtectionSettings, %function
 1991              	VerifyProtectionSettings:
 1992              	.LFB77:
1165:ProgrammingSteps.c **** 
1166:ProgrammingSteps.c **** /******************************************************************************
1167:ProgrammingSteps.c **** * Function Name: VerifyProtectionSettings
1168:ProgrammingSteps.c **** *******************************************************************************
1169:ProgrammingSteps.c **** *
1170:ProgrammingSteps.c **** * Summary:
1171:ProgrammingSteps.c **** *  This is Step 8 of the programming sequence. In this step, Chip protection 
1172:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and verified 
1173:ProgrammingSteps.c **** *  with the protection settings programmed in flash.
1174:ProgrammingSteps.c **** *
1175:ProgrammingSteps.c **** * Parameters:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 57


1176:ProgrammingSteps.c **** *  None
1177:ProgrammingSteps.c **** *
1178:ProgrammingSteps.c **** * Return:
1179:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the protection
1180:ProgrammingSteps.c **** *  			 settings.
1181:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1182:ProgrammingSteps.c **** *			 message.
1183:ProgrammingSteps.c **** *
1184:ProgrammingSteps.c **** * Note:
1185:ProgrammingSteps.c **** *
1186:ProgrammingSteps.c **** ******************************************************************************/
1187:ProgrammingSteps.c **** unsigned char VerifyProtectionSettings(void)
1188:ProgrammingSteps.c **** {
 1993              		.loc 1 1188 0
 1994              		.cfi_startproc
 1995              		@ args = 0, pretend = 0, frame = 152
 1996              		@ frame_needed = 1, uses_anonymous_args = 0
 1997 0000 80B5     		push	{r7, lr}
 1998              		.cfi_def_cfa_offset 8
 1999              		.cfi_offset 7, -8
 2000              		.cfi_offset 14, -4
 2001 0002 A6B0     		sub	sp, sp, #152
 2002              		.cfi_def_cfa_offset 160
 2003 0004 00AF     		add	r7, sp, #0
 2004              		.cfi_def_cfa_register 7
1189:ProgrammingSteps.c **** 	unsigned long protectionData 			= 0;
 2005              		.loc 1 1189 0
 2006 0006 0023     		movs	r3, #0
 2007 0008 C7F88830 		str	r3, [r7, #136]
1190:ProgrammingSteps.c **** 	unsigned long flashProtectionAddress 	= 0;
 2008              		.loc 1 1190 0
 2009 000c 0023     		movs	r3, #0
 2010 000e C7F89430 		str	r3, [r7, #148]
1191:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 			= 0;
 2011              		.loc 1 1191 0
 2012 0012 0023     		movs	r3, #0
 2013 0014 A7F89030 		strh	r3, [r7, #144]	@ movhi
1192:ProgrammingSteps.c ****     unsigned char chipProtectionData_Hex 	= 0;
 2014              		.loc 1 1192 0
 2015 0018 0023     		movs	r3, #0
 2016 001a 87F88730 		strb	r3, [r7, #135]
1193:ProgrammingSteps.c **** 	unsigned char rowProtectionByteSize 	= 0;
 2017              		.loc 1 1193 0
 2018 001e 0023     		movs	r3, #0
 2019 0020 87F88F30 		strb	r3, [r7, #143]
1194:ProgrammingSteps.c **** 	unsigned char i;
1195:ProgrammingSteps.c ****     unsigned char rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
1196:ProgrammingSteps.c ****     unsigned char rowProtectionFlashData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];    
1197:ProgrammingSteps.c ****     unsigned char arrayID                   = 0;
 2020              		.loc 1 1197 0
 2021 0024 0023     		movs	r3, #0
 2022 0026 87F89230 		strb	r3, [r7, #146]
1198:ProgrammingSteps.c ****     unsigned char arrayMax                  = 0;
 2023              		.loc 1 1198 0
 2024 002a 0023     		movs	r3, #0
 2025 002c 87F88E30 		strb	r3, [r7, #142]
1199:ProgrammingSteps.c ****         
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 58


1200:ProgrammingSteps.c ****     numOfFlashRows = GetFlashRowCount();
 2026              		.loc 1 1200 0
 2027 0030 FFF7FEFF 		bl	GetFlashRowCount
 2028 0034 0346     		mov	r3, r0
 2029 0036 A7F89030 		strh	r3, [r7, #144]	@ movhi
1201:ProgrammingSteps.c ****     
1202:ProgrammingSteps.c ****     arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 2030              		.loc 1 1202 0
 2031 003a B7F89030 		ldrh	r3, [r7, #144]
 2032 003e 5B0A     		lsrs	r3, r3, #9
 2033 0040 9BB2     		uxth	r3, r3
 2034 0042 87F88E30 		strb	r3, [r7, #142]
1203:ProgrammingSteps.c ****     
1204:ProgrammingSteps.c **** 	rowProtectionByteSize = numOfFlashRows/(8 * arrayMax);   
 2035              		.loc 1 1204 0
 2036 0046 B7F89020 		ldrh	r2, [r7, #144]
 2037 004a 97F88E30 		ldrb	r3, [r7, #142]	@ zero_extendqisi2
 2038 004e DB00     		lsls	r3, r3, #3
 2039 0050 92FBF3F3 		sdiv	r3, r2, r3
 2040 0054 87F88F30 		strb	r3, [r7, #143]
1205:ProgrammingSteps.c **** 
1206:ProgrammingSteps.c **** 	flashProtectionAddress = SFLASH_MACRO;
 2041              		.loc 1 1206 0
 2042 0058 6B4B     		ldr	r3, .L166
 2043 005a C7F89430 		str	r3, [r7, #148]
1207:ProgrammingSteps.c **** 	
1208:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++, flashProtectionAddress += FLASH_PROTECTION_ADD
 2044              		.loc 1 1208 0
 2045 005e 0023     		movs	r3, #0
 2046 0060 87F89230 		strb	r3, [r7, #146]
 2047 0064 8BE0     		b	.L152
 2048              	.L160:
1209:ProgrammingSteps.c ****     {
1210:ProgrammingSteps.c ****         /* Read Protection settings from hex-file */
1211:ProgrammingSteps.c **** 	    HEX_ReadRowProtectionData(rowProtectionByteSize,&rowProtectionData[0], arrayID);
 2049              		.loc 1 1211 0
 2050 0066 97F88F10 		ldrb	r1, [r7, #143]	@ zero_extendqisi2
 2051 006a 07F14402 		add	r2, r7, #68
 2052 006e 97F89230 		ldrb	r3, [r7, #146]	@ zero_extendqisi2
 2053 0072 0846     		mov	r0, r1
 2054 0074 1146     		mov	r1, r2
 2055 0076 1A46     		mov	r2, r3
 2056 0078 FFF7FEFF 		bl	HEX_ReadRowProtectionData
1212:ProgrammingSteps.c **** 	        
1213:ProgrammingSteps.c ****         /* Read Protection settings from silicon */
1214:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize;  i += 4)
 2057              		.loc 1 1214 0
 2058 007c 0023     		movs	r3, #0
 2059 007e 87F89330 		strb	r3, [r7, #147]
 2060 0082 43E0     		b	.L153
 2061              	.L156:
1215:ProgrammingSteps.c ****     	{
1216:ProgrammingSteps.c ****     		Read_IO(flashProtectionAddress + i, &protectionData);
 2062              		.loc 1 1216 0
 2063 0084 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 2064 0088 D7F89430 		ldr	r3, [r7, #148]
 2065 008c 1A44     		add	r2, r2, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 59


 2066 008e 07F18803 		add	r3, r7, #136
 2067 0092 1046     		mov	r0, r2
 2068 0094 1946     		mov	r1, r3
 2069 0096 FFF7FEFF 		bl	Read_IO
1217:ProgrammingSteps.c ****     	    
1218:ProgrammingSteps.c ****     		if( swd_PacketAck != SWD_OK_ACK )
 2070              		.loc 1 1218 0
 2071 009a 5C4B     		ldr	r3, .L166+4
 2072 009c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2073 009e 012B     		cmp	r3, #1
 2074 00a0 01D0     		beq	.L154
1219:ProgrammingSteps.c ****     	    {
1220:ProgrammingSteps.c ****     	        return (FAILURE);
 2075              		.loc 1 1220 0
 2076 00a2 0023     		movs	r3, #0
 2077 00a4 ABE0     		b	.L165
 2078              	.L154:
1221:ProgrammingSteps.c ****     	    }
1222:ProgrammingSteps.c ****     		
1223:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 0] = (protectionData >> 0) & 0xFF;     
 2079              		.loc 1 1223 0 discriminator 2
 2080 00a6 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2081 00aa D7F88820 		ldr	r2, [r7, #136]
 2082 00ae D2B2     		uxtb	r2, r2
 2083 00b0 07F19801 		add	r1, r7, #152
 2084 00b4 0B44     		add	r3, r3, r1
 2085 00b6 03F8942C 		strb	r2, [r3, #-148]
1224:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 1] = (protectionData >> 8) & 0xFF;
 2086              		.loc 1 1224 0 discriminator 2
 2087 00ba 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2088 00be 0133     		adds	r3, r3, #1
 2089 00c0 D7F88820 		ldr	r2, [r7, #136]
 2090 00c4 120A     		lsrs	r2, r2, #8
 2091 00c6 D2B2     		uxtb	r2, r2
 2092 00c8 07F19801 		add	r1, r7, #152
 2093 00cc 0B44     		add	r3, r3, r1
 2094 00ce 03F8942C 		strb	r2, [r3, #-148]
1225:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 2] = (protectionData >> 16) & 0xFF;
 2095              		.loc 1 1225 0 discriminator 2
 2096 00d2 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2097 00d6 0233     		adds	r3, r3, #2
 2098 00d8 D7F88820 		ldr	r2, [r7, #136]
 2099 00dc 120C     		lsrs	r2, r2, #16
 2100 00de D2B2     		uxtb	r2, r2
 2101 00e0 07F19801 		add	r1, r7, #152
 2102 00e4 0B44     		add	r3, r3, r1
 2103 00e6 03F8942C 		strb	r2, [r3, #-148]
1226:ProgrammingSteps.c ****     	    rowProtectionFlashData[i + 3] = (protectionData >> 24) & 0xFF;
 2104              		.loc 1 1226 0 discriminator 2
 2105 00ea 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2106 00ee 0333     		adds	r3, r3, #3
 2107 00f0 D7F88820 		ldr	r2, [r7, #136]
 2108 00f4 120E     		lsrs	r2, r2, #24
 2109 00f6 D2B2     		uxtb	r2, r2
 2110 00f8 07F19801 		add	r1, r7, #152
 2111 00fc 0B44     		add	r3, r3, r1
 2112 00fe 03F8942C 		strb	r2, [r3, #-148]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 60


1214:ProgrammingSteps.c ****     	{
 2113              		.loc 1 1214 0 discriminator 2
 2114 0102 97F89330 		ldrb	r3, [r7, #147]
 2115 0106 0433     		adds	r3, r3, #4
 2116 0108 87F89330 		strb	r3, [r7, #147]
 2117              	.L153:
1214:ProgrammingSteps.c ****     	{
 2118              		.loc 1 1214 0 is_stmt 0 discriminator 1
 2119 010c 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 2120 0110 97F88F30 		ldrb	r3, [r7, #143]	@ zero_extendqisi2
 2121 0114 9A42     		cmp	r2, r3
 2122 0116 B5D3     		bcc	.L156
1227:ProgrammingSteps.c ****     	}
1228:ProgrammingSteps.c **** 
1229:ProgrammingSteps.c ****     	/* Compare hex and silicons data */
1230:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize; i++ )
 2123              		.loc 1 1230 0 is_stmt 1
 2124 0118 0023     		movs	r3, #0
 2125 011a 87F89330 		strb	r3, [r7, #147]
 2126 011e 1DE0     		b	.L157
 2127              	.L159:
1231:ProgrammingSteps.c ****     	{
1232:ProgrammingSteps.c ****     		if (rowProtectionData[i] != rowProtectionFlashData[i])
 2128              		.loc 1 1232 0
 2129 0120 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2130 0124 07F19802 		add	r2, r7, #152
 2131 0128 1344     		add	r3, r3, r2
 2132 012a 13F8542C 		ldrb	r2, [r3, #-84]	@ zero_extendqisi2
 2133 012e 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2134 0132 07F19801 		add	r1, r7, #152
 2135 0136 0B44     		add	r3, r3, r1
 2136 0138 13F8943C 		ldrb	r3, [r3, #-148]	@ zero_extendqisi2
 2137 013c 9A42     		cmp	r2, r3
 2138 013e 08D0     		beq	.L158
1233:ProgrammingSteps.c ****     		{
1234:ProgrammingSteps.c ****                 /* Set the verification error bit for Flash protection data
1235:ProgrammingSteps.c ****     			   mismatch and return failure */
1236:ProgrammingSteps.c ****                 swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2139              		.loc 1 1236 0
 2140 0140 324B     		ldr	r3, .L166+4
 2141 0142 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2142 0144 43F04003 		orr	r3, r3, #64
 2143 0148 DAB2     		uxtb	r2, r3
 2144 014a 304B     		ldr	r3, .L166+4
 2145 014c 1A70     		strb	r2, [r3]
1237:ProgrammingSteps.c ****                 return(FAILURE);
 2146              		.loc 1 1237 0
 2147 014e 0023     		movs	r3, #0
 2148 0150 55E0     		b	.L165
 2149              	.L158:
1230:ProgrammingSteps.c ****     	{
 2150              		.loc 1 1230 0 discriminator 2
 2151 0152 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2152 0156 0133     		adds	r3, r3, #1
 2153 0158 87F89330 		strb	r3, [r7, #147]
 2154              	.L157:
1230:ProgrammingSteps.c ****     	{
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 61


 2155              		.loc 1 1230 0 is_stmt 0 discriminator 1
 2156 015c 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 2157 0160 97F88F30 		ldrb	r3, [r7, #143]	@ zero_extendqisi2
 2158 0164 9A42     		cmp	r2, r3
 2159 0166 DBD3     		bcc	.L159
1208:ProgrammingSteps.c ****     {
 2160              		.loc 1 1208 0 is_stmt 1 discriminator 2
 2161 0168 97F89230 		ldrb	r3, [r7, #146]	@ zero_extendqisi2
 2162 016c 0133     		adds	r3, r3, #1
 2163 016e 87F89230 		strb	r3, [r7, #146]
 2164 0172 D7F89430 		ldr	r3, [r7, #148]
 2165 0176 03F58063 		add	r3, r3, #1024
 2166 017a C7F89430 		str	r3, [r7, #148]
 2167              	.L152:
1208:ProgrammingSteps.c ****     {
 2168              		.loc 1 1208 0 is_stmt 0 discriminator 1
 2169 017e 97F89220 		ldrb	r2, [r7, #146]	@ zero_extendqisi2
 2170 0182 97F88E30 		ldrb	r3, [r7, #142]	@ zero_extendqisi2
 2171 0186 9A42     		cmp	r2, r3
 2172 0188 FFF46DAF 		bcc	.L160
1238:ProgrammingSteps.c ****             }
1239:ProgrammingSteps.c ****     	}
1240:ProgrammingSteps.c ****     }
1241:ProgrammingSteps.c **** 
1242:ProgrammingSteps.c **** 	/* Read Chip Level Protection from hex-file */
1243:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 2173              		.loc 1 1243 0 is_stmt 1
 2174 018c 07F18703 		add	r3, r7, #135
 2175 0190 1846     		mov	r0, r3
 2176 0192 FFF7FEFF 		bl	HEX_ReadChipProtectionData
1244:ProgrammingSteps.c **** 
1245:ProgrammingSteps.c **** 	/* Read Chip Level Protection from the silicon */
1246:ProgrammingSteps.c **** 	Read_IO(SFLASH_CPUSS_PROTECTION, &protectionData);
 2177              		.loc 1 1246 0
 2178 0196 07F18803 		add	r3, r7, #136
 2179 019a 1D48     		ldr	r0, .L166+8
 2180 019c 1946     		mov	r1, r3
 2181 019e FFF7FEFF 		bl	Read_IO
1247:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 2182              		.loc 1 1247 0
 2183 01a2 1A4B     		ldr	r3, .L166+4
 2184 01a4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2185 01a6 012B     		cmp	r3, #1
 2186 01a8 01D0     		beq	.L161
1248:ProgrammingSteps.c ****     {
1249:ProgrammingSteps.c ****         return (FAILURE);
 2187              		.loc 1 1249 0
 2188 01aa 0023     		movs	r3, #0
 2189 01ac 27E0     		b	.L165
 2190              	.L161:
1250:ProgrammingSteps.c ****     }
1251:ProgrammingSteps.c **** 	
1252:ProgrammingSteps.c **** 	chipProtectionData_Chip = (protectionData >> 24) & 0x0F;
 2191              		.loc 1 1252 0
 2192 01ae D7F88830 		ldr	r3, [r7, #136]
 2193 01b2 1B0E     		lsrs	r3, r3, #24
 2194 01b4 DBB2     		uxtb	r3, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 62


 2195 01b6 03F00F03 		and	r3, r3, #15
 2196 01ba DAB2     		uxtb	r2, r3
 2197 01bc 154B     		ldr	r3, .L166+12
 2198 01be 1A70     		strb	r2, [r3]
1253:ProgrammingSteps.c **** 
1254:ProgrammingSteps.c **** 	if (chipProtectionData_Chip == CHIP_PROT_VIRGIN)
 2199              		.loc 1 1254 0
 2200 01c0 144B     		ldr	r3, .L166+12
 2201 01c2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2202 01c4 002B     		cmp	r3, #0
 2203 01c6 03D1     		bne	.L162
1255:ProgrammingSteps.c **** 	{
1256:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_OPEN;
 2204              		.loc 1 1256 0
 2205 01c8 124B     		ldr	r3, .L166+12
 2206 01ca 0122     		movs	r2, #1
 2207 01cc 1A70     		strb	r2, [r3]
 2208 01ce 06E0     		b	.L163
 2209              	.L162:
1257:ProgrammingSteps.c **** 	}	
1258:ProgrammingSteps.c **** 	else if (chipProtectionData_Chip == CHIP_PROT_OPEN)
 2210              		.loc 1 1258 0
 2211 01d0 104B     		ldr	r3, .L166+12
 2212 01d2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2213 01d4 012B     		cmp	r3, #1
 2214 01d6 02D1     		bne	.L163
1259:ProgrammingSteps.c **** 	{
1260:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_VIRGIN;
 2215              		.loc 1 1260 0
 2216 01d8 0E4B     		ldr	r3, .L166+12
 2217 01da 0022     		movs	r2, #0
 2218 01dc 1A70     		strb	r2, [r3]
 2219              	.L163:
1261:ProgrammingSteps.c **** 	}
1262:ProgrammingSteps.c **** 	
1263:ProgrammingSteps.c **** 	/* Compare hexs and silicons chip protection data */
1264:ProgrammingSteps.c **** 	if (chipProtectionData_Chip != chipProtectionData_Hex)
 2220              		.loc 1 1264 0
 2221 01de 0D4B     		ldr	r3, .L166+12
 2222 01e0 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2223 01e2 97F88730 		ldrb	r3, [r7, #135]	@ zero_extendqisi2
 2224 01e6 9A42     		cmp	r2, r3
 2225 01e8 08D0     		beq	.L164
1265:ProgrammingSteps.c **** 	{
1266:ProgrammingSteps.c ****         /* Set the verification error bit for Flash protection data
1267:ProgrammingSteps.c **** 		   mismatch and return failure */
1268:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2226              		.loc 1 1268 0
 2227 01ea 084B     		ldr	r3, .L166+4
 2228 01ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2229 01ee 43F04003 		orr	r3, r3, #64
 2230 01f2 DAB2     		uxtb	r2, r3
 2231 01f4 054B     		ldr	r3, .L166+4
 2232 01f6 1A70     		strb	r2, [r3]
1269:ProgrammingSteps.c ****         return(FAILURE);
 2233              		.loc 1 1269 0
 2234 01f8 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 63


 2235 01fa 00E0     		b	.L165
 2236              	.L164:
1270:ProgrammingSteps.c ****     }
1271:ProgrammingSteps.c **** 
1272:ProgrammingSteps.c **** 	return (SUCCESS);
 2237              		.loc 1 1272 0
 2238 01fc 0123     		movs	r3, #1
 2239              	.L165:
1273:ProgrammingSteps.c **** }
 2240              		.loc 1 1273 0 discriminator 1
 2241 01fe 1846     		mov	r0, r3
 2242 0200 9837     		adds	r7, r7, #152
 2243              		.cfi_def_cfa_offset 8
 2244 0202 BD46     		mov	sp, r7
 2245              		.cfi_def_cfa_register 13
 2246              		@ sp needed
 2247 0204 80BD     		pop	{r7, pc}
 2248              	.L167:
 2249 0206 00BF     		.align	2
 2250              	.L166:
 2251 0208 00F0FF0F 		.word	268431360
 2252 020c 00000000 		.word	swd_PacketAck
 2253 0210 7CF0FF0F 		.word	268431484
 2254 0214 00000000 		.word	chipProtectionData_Chip
 2255              		.cfi_endproc
 2256              	.LFE77:
 2257              		.size	VerifyProtectionSettings, .-VerifyProtectionSettings
 2258              		.section	.text.VerifyChecksum,"ax",%progbits
 2259              		.align	2
 2260              		.global	VerifyChecksum
 2261              		.thumb
 2262              		.thumb_func
 2263              		.type	VerifyChecksum, %function
 2264              	VerifyChecksum:
 2265              	.LFB78:
1274:ProgrammingSteps.c **** 
1275:ProgrammingSteps.c **** /******************************************************************************
1276:ProgrammingSteps.c **** * Function Name: VerifyChecksum
1277:ProgrammingSteps.c **** *******************************************************************************
1278:ProgrammingSteps.c **** *
1279:ProgrammingSteps.c **** * Summary:
1280:ProgrammingSteps.c **** *  This is Step 9 of the programming sequence. In this step, Checksum of user
1281:ProgrammingSteps.c **** *  data in flash is verified with the Checksum stored in the HEX File. This step
1282:ProgrammingSteps.c **** *  uses the Checksum of privileged rows calculated in Step 4 get the checksum
1283:ProgrammingSteps.c **** *  of user data in flash.
1284:ProgrammingSteps.c **** *
1285:ProgrammingSteps.c **** * Parameters:
1286:ProgrammingSteps.c **** *  None
1287:ProgrammingSteps.c **** *
1288:ProgrammingSteps.c **** * Return:
1289:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the checksum.
1290:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1291:ProgrammingSteps.c **** *			 message.
1292:ProgrammingSteps.c **** *
1293:ProgrammingSteps.c **** * Note:
1294:ProgrammingSteps.c **** *
1295:ProgrammingSteps.c **** ******************************************************************************/
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 64


1296:ProgrammingSteps.c **** unsigned char VerifyChecksum(void)
1297:ProgrammingSteps.c **** {
 2266              		.loc 1 1297 0
 2267              		.cfi_startproc
 2268              		@ args = 0, pretend = 0, frame = 16
 2269              		@ frame_needed = 1, uses_anonymous_args = 0
 2270 0000 80B5     		push	{r7, lr}
 2271              		.cfi_def_cfa_offset 8
 2272              		.cfi_offset 7, -8
 2273              		.cfi_offset 14, -4
 2274 0002 84B0     		sub	sp, sp, #16
 2275              		.cfi_def_cfa_offset 24
 2276 0004 00AF     		add	r7, sp, #0
 2277              		.cfi_def_cfa_register 7
1298:ProgrammingSteps.c **** 	unsigned long checksum_All 	 = 0;
 2278              		.loc 1 1298 0
 2279 0006 0023     		movs	r3, #0
 2280 0008 BB60     		str	r3, [r7, #8]
1299:ProgrammingSteps.c **** 	unsigned short chip_Checksum = 0;
 2281              		.loc 1 1299 0
 2282 000a 0023     		movs	r3, #0
 2283 000c FB81     		strh	r3, [r7, #14]	@ movhi
1300:ProgrammingSteps.c **** 	unsigned short checksumData  = 0;
 2284              		.loc 1 1300 0
 2285 000e 0023     		movs	r3, #0
 2286 0010 FB80     		strh	r3, [r7, #6]	@ movhi
1301:ProgrammingSteps.c ****     
1302:ProgrammingSteps.c **** 	/* Read the checksum of entire flash */
1303:ProgrammingSteps.c **** 	result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_All);
 2287              		.loc 1 1303 0
 2288 0012 07F10803 		add	r3, r7, #8
 2289 0016 4FF40040 		mov	r0, #32768
 2290 001a 1946     		mov	r1, r3
 2291 001c FFF7FEFF 		bl	ChecksumAPI
 2292 0020 0346     		mov	r3, r0
 2293 0022 1A46     		mov	r2, r3
 2294 0024 124B     		ldr	r3, .L173
 2295 0026 1A70     		strb	r2, [r3]
1304:ProgrammingSteps.c **** 	
1305:ProgrammingSteps.c **** 	if (result != SUCCESS)
 2296              		.loc 1 1305 0
 2297 0028 114B     		ldr	r3, .L173
 2298 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2299 002c 012B     		cmp	r3, #1
 2300 002e 01D0     		beq	.L169
1306:ProgrammingSteps.c **** 	{
1307:ProgrammingSteps.c **** 		return (FAILURE);
 2301              		.loc 1 1307 0
 2302 0030 0023     		movs	r3, #0
 2303 0032 18E0     		b	.L172
 2304              	.L169:
1308:ProgrammingSteps.c **** 	}
1309:ProgrammingSteps.c **** 	
1310:ProgrammingSteps.c **** 	/* Calculate checksum of user flash */
1311:ProgrammingSteps.c ****     chip_Checksum = (unsigned short)checksum_All - (unsigned short)checksum_Privileged;
 2305              		.loc 1 1311 0
 2306 0034 BB68     		ldr	r3, [r7, #8]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 65


 2307 0036 9AB2     		uxth	r2, r3
 2308 0038 0E4B     		ldr	r3, .L173+4
 2309 003a 1B68     		ldr	r3, [r3]
 2310 003c 9BB2     		uxth	r3, r3
 2311 003e D31A     		subs	r3, r2, r3
 2312 0040 FB81     		strh	r3, [r7, #14]	@ movhi
1312:ProgrammingSteps.c **** 	
1313:ProgrammingSteps.c **** 	/* Read checksum from hex file */
1314:ProgrammingSteps.c **** 	HEX_ReadChecksumData(&checksumData);
 2313              		.loc 1 1314 0
 2314 0042 BB1D     		adds	r3, r7, #6
 2315 0044 1846     		mov	r0, r3
 2316 0046 FFF7FEFF 		bl	HEX_ReadChecksumData
1315:ProgrammingSteps.c **** 	
1316:ProgrammingSteps.c **** 	/* Compare the checksum data of silicon and hex file */
1317:ProgrammingSteps.c **** 	if (chip_Checksum != checksumData)
 2317              		.loc 1 1317 0
 2318 004a FB88     		ldrh	r3, [r7, #6]
 2319 004c FA89     		ldrh	r2, [r7, #14]
 2320 004e 9A42     		cmp	r2, r3
 2321 0050 08D0     		beq	.L171
1318:ProgrammingSteps.c ****     {
1319:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 2322              		.loc 1 1319 0
 2323 0052 094B     		ldr	r3, .L173+8
 2324 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2325 0056 43F04003 		orr	r3, r3, #64
 2326 005a DAB2     		uxtb	r2, r3
 2327 005c 064B     		ldr	r3, .L173+8
 2328 005e 1A70     		strb	r2, [r3]
1320:ProgrammingSteps.c **** 		return (FAILURE);
 2329              		.loc 1 1320 0
 2330 0060 0023     		movs	r3, #0
 2331 0062 00E0     		b	.L172
 2332              	.L171:
1321:ProgrammingSteps.c ****     }
1322:ProgrammingSteps.c **** 	
1323:ProgrammingSteps.c **** 	return (SUCCESS);
 2333              		.loc 1 1323 0
 2334 0064 0123     		movs	r3, #1
 2335              	.L172:
1324:ProgrammingSteps.c **** }
 2336              		.loc 1 1324 0 discriminator 1
 2337 0066 1846     		mov	r0, r3
 2338 0068 1037     		adds	r7, r7, #16
 2339              		.cfi_def_cfa_offset 8
 2340 006a BD46     		mov	sp, r7
 2341              		.cfi_def_cfa_register 13
 2342              		@ sp needed
 2343 006c 80BD     		pop	{r7, pc}
 2344              	.L174:
 2345 006e 00BF     		.align	2
 2346              	.L173:
 2347 0070 00000000 		.word	result
 2348 0074 00000000 		.word	checksum_Privileged
 2349 0078 00000000 		.word	swd_PacketAck
 2350              		.cfi_endproc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 66


 2351              	.LFE78:
 2352              		.size	VerifyChecksum, .-VerifyChecksum
 2353              		.section	.text.ReadHsspErrorStatus,"ax",%progbits
 2354              		.align	2
 2355              		.global	ReadHsspErrorStatus
 2356              		.thumb
 2357              		.thumb_func
 2358              		.type	ReadHsspErrorStatus, %function
 2359              	ReadHsspErrorStatus:
 2360              	.LFB79:
1325:ProgrammingSteps.c **** 
1326:ProgrammingSteps.c **** /******************************************************************************
1327:ProgrammingSteps.c **** * Function Name: ReadHsspErrorStatus
1328:ProgrammingSteps.c **** *******************************************************************************
1329:ProgrammingSteps.c **** *
1330:ProgrammingSteps.c **** * Summary:
1331:ProgrammingSteps.c **** *  Returns the HSSP Error status in case of FAILURE return in any one of the
1332:ProgrammingSteps.c **** *  programming steps.
1333:ProgrammingSteps.c **** *
1334:ProgrammingSteps.c **** * Parameters:
1335:ProgrammingSteps.c **** *  None.
1336:ProgrammingSteps.c **** *
1337:ProgrammingSteps.c **** * Return:
1338:ProgrammingSteps.c **** *  swd_PacketAck - Each bit of this 8-bit return value has a specific meaning.
1339:ProgrammingSteps.c **** *
1340:ProgrammingSteps.c **** * Note:
1341:ProgrammingSteps.c **** *  Refer to the application note pdf for details on the Error status bit
1342:ProgrammingSteps.c **** *  definitions
1343:ProgrammingSteps.c **** ******************************************************************************/
1344:ProgrammingSteps.c **** unsigned char ReadHsspErrorStatus()
1345:ProgrammingSteps.c **** {
 2361              		.loc 1 1345 0
 2362              		.cfi_startproc
 2363              		@ args = 0, pretend = 0, frame = 0
 2364              		@ frame_needed = 1, uses_anonymous_args = 0
 2365              		@ link register save eliminated.
 2366 0000 80B4     		push	{r7}
 2367              		.cfi_def_cfa_offset 4
 2368              		.cfi_offset 7, -4
 2369 0002 00AF     		add	r7, sp, #0
 2370              		.cfi_def_cfa_register 7
1346:ProgrammingSteps.c ****     return(swd_PacketAck);
 2371              		.loc 1 1346 0
 2372 0004 034B     		ldr	r3, .L177
 2373 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
1347:ProgrammingSteps.c **** }
 2374              		.loc 1 1347 0
 2375 0008 1846     		mov	r0, r3
 2376 000a BD46     		mov	sp, r7
 2377              		.cfi_def_cfa_register 13
 2378              		@ sp needed
 2379 000c 5DF8047B 		ldr	r7, [sp], #4
 2380              		.cfi_restore 7
 2381              		.cfi_def_cfa_offset 0
 2382 0010 7047     		bx	lr
 2383              	.L178:
 2384 0012 00BF     		.align	2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 67


 2385              	.L177:
 2386 0014 00000000 		.word	swd_PacketAck
 2387              		.cfi_endproc
 2388              	.LFE79:
 2389              		.size	ReadHsspErrorStatus, .-ReadHsspErrorStatus
 2390              		.section	.text.ExitProgrammingMode,"ax",%progbits
 2391              		.align	2
 2392              		.global	ExitProgrammingMode
 2393              		.thumb
 2394              		.thumb_func
 2395              		.type	ExitProgrammingMode, %function
 2396              	ExitProgrammingMode:
 2397              	.LFB80:
1348:ProgrammingSteps.c **** /******************************************************************************
1349:ProgrammingSteps.c **** * Function Name: ExitProgrammingMode
1350:ProgrammingSteps.c **** *******************************************************************************
1351:ProgrammingSteps.c **** *
1352:ProgrammingSteps.c **** * Summary:
1353:ProgrammingSteps.c **** *  Releases the target PSoC 4 device from Programming mode.
1354:ProgrammingSteps.c **** *
1355:ProgrammingSteps.c **** * Parameters:
1356:ProgrammingSteps.c **** *  None.
1357:ProgrammingSteps.c **** *
1358:ProgrammingSteps.c **** * Return:
1359:ProgrammingSteps.c **** *  None.
1360:ProgrammingSteps.c **** *
1361:ProgrammingSteps.c **** * Note:
1362:ProgrammingSteps.c **** *
1363:ProgrammingSteps.c **** ******************************************************************************/
1364:ProgrammingSteps.c **** void ExitProgrammingMode()
1365:ProgrammingSteps.c **** {
 2398              		.loc 1 1365 0
 2399              		.cfi_startproc
 2400              		@ args = 0, pretend = 0, frame = 0
 2401              		@ frame_needed = 1, uses_anonymous_args = 0
 2402 0000 80B5     		push	{r7, lr}
 2403              		.cfi_def_cfa_offset 8
 2404              		.cfi_offset 7, -8
 2405              		.cfi_offset 14, -4
 2406 0002 00AF     		add	r7, sp, #0
 2407              		.cfi_def_cfa_register 7
1366:ProgrammingSteps.c ****     /* Drive the SWDIO, SWDCK outputs low */
1367:ProgrammingSteps.c ****     SetSwdckLow();
 2408              		.loc 1 1367 0
 2409 0004 FFF7FEFF 		bl	SetSwdckLow
1368:ProgrammingSteps.c ****     SetSwdioLow();
 2410              		.loc 1 1368 0
 2411 0008 FFF7FEFF 		bl	SetSwdioLow
1369:ProgrammingSteps.c ****     
1370:ProgrammingSteps.c ****     /* Make SWDIO, SWDCK High-Z after completing Programming */    
1371:ProgrammingSteps.c ****     SetSwdioHizInput();
 2412              		.loc 1 1371 0
 2413 000c FFF7FEFF 		bl	SetSwdioHizInput
1372:ProgrammingSteps.c ****     SetSwdckHizInput();
 2414              		.loc 1 1372 0
 2415 0010 FFF7FEFF 		bl	SetSwdckHizInput
1373:ProgrammingSteps.c ****     
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 68


1374:ProgrammingSteps.c ****     /* Generate active low rest pulse for 100 uS */
1375:ProgrammingSteps.c ****     SetXresLow();
 2416              		.loc 1 1375 0
 2417 0014 FFF7FEFF 		bl	SetXresLow
1376:ProgrammingSteps.c ****     DelayHundredUs();    
 2418              		.loc 1 1376 0
 2419 0018 FFF7FEFF 		bl	DelayHundredUs
1377:ProgrammingSteps.c ****     SetXresHigh();
 2420              		.loc 1 1377 0
 2421 001c FFF7FEFF 		bl	SetXresHigh
1378:ProgrammingSteps.c **** 
1379:ProgrammingSteps.c ****     /* Make XRES High-Z after generating the reset pulse */  
1380:ProgrammingSteps.c ****     SetXresHizInput();
 2422              		.loc 1 1380 0
 2423 0020 FFF7FEFF 		bl	SetXresHizInput
1381:ProgrammingSteps.c **** }
 2424              		.loc 1 1381 0
 2425 0024 80BD     		pop	{r7, pc}
 2426              		.cfi_endproc
 2427              	.LFE80:
 2428              		.size	ExitProgrammingMode, .-ExitProgrammingMode
 2429 0026 00BF     		.text
 2430              	.Letext0:
 2431              		.file 2 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2432              		.file 3 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2433              		.file 4 "SWD_PacketLayer.h"
 2434              		.file 5 "Generated_Source\\PSoC5/core_cm3.h"
 2435              		.section	.debug_info,"",%progbits
 2436              	.Ldebug_info0:
 2437 0000 74060000 		.4byte	0x674
 2438 0004 0400     		.2byte	0x4
 2439 0006 00000000 		.4byte	.Ldebug_abbrev0
 2440 000a 04       		.byte	0x4
 2441 000b 01       		.uleb128 0x1
 2442 000c B9010000 		.4byte	.LASF74
 2443 0010 01       		.byte	0x1
 2444 0011 DD000000 		.4byte	.LASF75
 2445 0015 9E020000 		.4byte	.LASF76
 2446 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2447 001d 00000000 		.4byte	0
 2448 0021 00000000 		.4byte	.Ldebug_line0
 2449 0025 02       		.uleb128 0x2
 2450 0026 01       		.byte	0x1
 2451 0027 06       		.byte	0x6
 2452 0028 6E010000 		.4byte	.LASF0
 2453 002c 02       		.uleb128 0x2
 2454 002d 01       		.byte	0x1
 2455 002e 08       		.byte	0x8
 2456 002f 21030000 		.4byte	.LASF1
 2457 0033 02       		.uleb128 0x2
 2458 0034 02       		.byte	0x2
 2459 0035 05       		.byte	0x5
 2460 0036 9C000000 		.4byte	.LASF2
 2461 003a 02       		.uleb128 0x2
 2462 003b 02       		.byte	0x2
 2463 003c 07       		.byte	0x7
 2464 003d C4030000 		.4byte	.LASF3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 69


 2465 0041 03       		.uleb128 0x3
 2466 0042 9A040000 		.4byte	.LASF9
 2467 0046 02       		.byte	0x2
 2468 0047 3F       		.byte	0x3f
 2469 0048 4C000000 		.4byte	0x4c
 2470 004c 02       		.uleb128 0x2
 2471 004d 04       		.byte	0x4
 2472 004e 05       		.byte	0x5
 2473 004f 00040000 		.4byte	.LASF4
 2474 0053 02       		.uleb128 0x2
 2475 0054 04       		.byte	0x4
 2476 0055 07       		.byte	0x7
 2477 0056 41040000 		.4byte	.LASF5
 2478 005a 02       		.uleb128 0x2
 2479 005b 08       		.byte	0x8
 2480 005c 05       		.byte	0x5
 2481 005d F0000000 		.4byte	.LASF6
 2482 0061 02       		.uleb128 0x2
 2483 0062 08       		.byte	0x8
 2484 0063 07       		.byte	0x7
 2485 0064 73030000 		.4byte	.LASF7
 2486 0068 04       		.uleb128 0x4
 2487 0069 04       		.byte	0x4
 2488 006a 05       		.byte	0x5
 2489 006b 696E7400 		.ascii	"int\000"
 2490 006f 02       		.uleb128 0x2
 2491 0070 04       		.byte	0x4
 2492 0071 07       		.byte	0x7
 2493 0072 9D030000 		.4byte	.LASF8
 2494 0076 03       		.uleb128 0x3
 2495 0077 13040000 		.4byte	.LASF10
 2496 007b 03       		.byte	0x3
 2497 007c 2C       		.byte	0x2c
 2498 007d 41000000 		.4byte	0x41
 2499 0081 02       		.uleb128 0x2
 2500 0082 04       		.byte	0x4
 2501 0083 04       		.byte	0x4
 2502 0084 7A010000 		.4byte	.LASF11
 2503 0088 02       		.uleb128 0x2
 2504 0089 08       		.byte	0x8
 2505 008a 04       		.byte	0x4
 2506 008b 5F040000 		.4byte	.LASF12
 2507 008f 02       		.uleb128 0x2
 2508 0090 01       		.byte	0x1
 2509 0091 08       		.byte	0x8
 2510 0092 EC030000 		.4byte	.LASF13
 2511 0096 02       		.uleb128 0x2
 2512 0097 04       		.byte	0x4
 2513 0098 07       		.byte	0x7
 2514 0099 B6000000 		.4byte	.LASF14
 2515 009d 05       		.uleb128 0x5
 2516 009e 04       		.byte	0x4
 2517 009f 2C000000 		.4byte	0x2c
 2518 00a3 06       		.uleb128 0x6
 2519 00a4 B0040000 		.4byte	.LASF77
 2520 00a8 01       		.byte	0x1
 2521 00a9 01       		.byte	0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 70


 2522 00aa 48       		.byte	0x48
 2523 00ab C8000000 		.4byte	0xc8
 2524 00af 07       		.uleb128 0x7
 2525 00b0 60020000 		.4byte	.LASF15
 2526 00b4 00       		.sleb128 0
 2527 00b5 07       		.uleb128 0x7
 2528 00b6 A4040000 		.4byte	.LASF16
 2529 00ba 01       		.sleb128 1
 2530 00bb 07       		.uleb128 0x7
 2531 00bc C0040000 		.4byte	.LASF17
 2532 00c0 02       		.sleb128 2
 2533 00c1 07       		.uleb128 0x7
 2534 00c2 00000000 		.4byte	.LASF18
 2535 00c6 03       		.sleb128 3
 2536 00c7 00       		.byte	0
 2537 00c8 08       		.uleb128 0x8
 2538 00c9 AA030000 		.4byte	.LASF21
 2539 00cd 01       		.byte	0x1
 2540 00ce 68       		.byte	0x68
 2541 00cf 2C000000 		.4byte	0x2c
 2542 00d3 00000000 		.4byte	.LFB63
 2543 00d7 9C000000 		.4byte	.LFE63-.LFB63
 2544 00db 01       		.uleb128 0x1
 2545 00dc 9C       		.byte	0x9c
 2546 00dd F0000000 		.4byte	0xf0
 2547 00e1 09       		.uleb128 0x9
 2548 00e2 AC010000 		.4byte	.LASF19
 2549 00e6 01       		.byte	0x1
 2550 00e7 6A       		.byte	0x6a
 2551 00e8 53000000 		.4byte	0x53
 2552 00ec 02       		.uleb128 0x2
 2553 00ed 91       		.byte	0x91
 2554 00ee 74       		.sleb128 -12
 2555 00ef 00       		.byte	0
 2556 00f0 0A       		.uleb128 0xa
 2557 00f1 2D040000 		.4byte	.LASF78
 2558 00f5 01       		.byte	0x1
 2559 00f6 A4       		.byte	0xa4
 2560 00f7 00000000 		.4byte	.LFB64
 2561 00fb 34000000 		.4byte	.LFE64-.LFB64
 2562 00ff 01       		.uleb128 0x1
 2563 0100 9C       		.byte	0x9c
 2564 0101 14010000 		.4byte	0x114
 2565 0105 09       		.uleb128 0x9
 2566 0106 0A010000 		.4byte	.LASF20
 2567 010a 01       		.byte	0x1
 2568 010b A6       		.byte	0xa6
 2569 010c 53000000 		.4byte	0x53
 2570 0110 02       		.uleb128 0x2
 2571 0111 91       		.byte	0x91
 2572 0112 74       		.sleb128 -12
 2573 0113 00       		.byte	0
 2574 0114 0B       		.uleb128 0xb
 2575 0115 2F030000 		.4byte	.LASF45
 2576 0119 01       		.byte	0x1
 2577 011a C5       		.byte	0xc5
 2578 011b 2C000000 		.4byte	0x2c
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 71


 2579 011f 00000000 		.4byte	.LFB65
 2580 0123 18000000 		.4byte	.LFE65-.LFB65
 2581 0127 01       		.uleb128 0x1
 2582 0128 9C       		.byte	0x9c
 2583 0129 08       		.uleb128 0x8
 2584 012a E8040000 		.4byte	.LASF22
 2585 012e 01       		.byte	0x1
 2586 012f DF       		.byte	0xdf
 2587 0130 2C000000 		.4byte	0x2c
 2588 0134 00000000 		.4byte	.LFB66
 2589 0138 94000000 		.4byte	.LFE66-.LFB66
 2590 013c 01       		.uleb128 0x1
 2591 013d 9C       		.byte	0x9c
 2592 013e 5F010000 		.4byte	0x15f
 2593 0142 09       		.uleb128 0x9
 2594 0143 0A010000 		.4byte	.LASF20
 2595 0147 01       		.byte	0x1
 2596 0148 E1       		.byte	0xe1
 2597 0149 53000000 		.4byte	0x53
 2598 014d 02       		.uleb128 0x2
 2599 014e 91       		.byte	0x91
 2600 014f 74       		.sleb128 -12
 2601 0150 09       		.uleb128 0x9
 2602 0151 9F010000 		.4byte	.LASF23
 2603 0155 01       		.byte	0x1
 2604 0156 E2       		.byte	0xe2
 2605 0157 53000000 		.4byte	0x53
 2606 015b 02       		.uleb128 0x2
 2607 015c 91       		.byte	0x91
 2608 015d 70       		.sleb128 -16
 2609 015e 00       		.byte	0
 2610 015f 0C       		.uleb128 0xc
 2611 0160 CB000000 		.4byte	.LASF24
 2612 0164 01       		.byte	0x1
 2613 0165 2601     		.2byte	0x126
 2614 0167 2C000000 		.4byte	0x2c
 2615 016b 00000000 		.4byte	.LFB67
 2616 016f A4000000 		.4byte	.LFE67-.LFB67
 2617 0173 01       		.uleb128 0x1
 2618 0174 9C       		.byte	0x9c
 2619 0175 89010000 		.4byte	0x189
 2620 0179 0D       		.uleb128 0xd
 2621 017a 7A040000 		.4byte	.LASF25
 2622 017e 01       		.byte	0x1
 2623 017f 2801     		.2byte	0x128
 2624 0181 2C000000 		.4byte	0x2c
 2625 0185 02       		.uleb128 0x2
 2626 0186 91       		.byte	0x91
 2627 0187 77       		.sleb128 -9
 2628 0188 00       		.byte	0
 2629 0189 0C       		.uleb128 0xc
 2630 018a 09040000 		.4byte	.LASF26
 2631 018e 01       		.byte	0x1
 2632 018f 7501     		.2byte	0x175
 2633 0191 2C000000 		.4byte	0x2c
 2634 0195 00000000 		.4byte	.LFB68
 2635 0199 24010000 		.4byte	.LFE68-.LFB68
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 72


 2636 019d 01       		.uleb128 0x1
 2637 019e 9C       		.byte	0x9c
 2638 019f FC010000 		.4byte	0x1fc
 2639 01a3 0E       		.uleb128 0xe
 2640 01a4 39040000 		.4byte	.LASF27
 2641 01a8 01       		.byte	0x1
 2642 01a9 7501     		.2byte	0x175
 2643 01ab 2C000000 		.4byte	0x2c
 2644 01af 02       		.uleb128 0x2
 2645 01b0 91       		.byte	0x91
 2646 01b1 67       		.sleb128 -25
 2647 01b2 0E       		.uleb128 0xe
 2648 01b3 87000000 		.4byte	.LASF28
 2649 01b7 01       		.byte	0x1
 2650 01b8 7501     		.2byte	0x175
 2651 01ba 9D000000 		.4byte	0x9d
 2652 01be 02       		.uleb128 0x2
 2653 01bf 91       		.byte	0x91
 2654 01c0 60       		.sleb128 -32
 2655 01c1 0E       		.uleb128 0xe
 2656 01c2 41010000 		.4byte	.LASF29
 2657 01c6 01       		.byte	0x1
 2658 01c7 7501     		.2byte	0x175
 2659 01c9 3A000000 		.4byte	0x3a
 2660 01cd 02       		.uleb128 0x2
 2661 01ce 91       		.byte	0x91
 2662 01cf 64       		.sleb128 -28
 2663 01d0 0D       		.uleb128 0xd
 2664 01d1 0A010000 		.4byte	.LASF20
 2665 01d5 01       		.byte	0x1
 2666 01d6 7701     		.2byte	0x177
 2667 01d8 53000000 		.4byte	0x53
 2668 01dc 02       		.uleb128 0x2
 2669 01dd 91       		.byte	0x91
 2670 01de 70       		.sleb128 -16
 2671 01df 0D       		.uleb128 0xd
 2672 01e0 15010000 		.4byte	.LASF30
 2673 01e4 01       		.byte	0x1
 2674 01e5 7801     		.2byte	0x178
 2675 01e7 53000000 		.4byte	0x53
 2676 01eb 02       		.uleb128 0x2
 2677 01ec 91       		.byte	0x91
 2678 01ed 6C       		.sleb128 -20
 2679 01ee 0F       		.uleb128 0xf
 2680 01ef 6900     		.ascii	"i\000"
 2681 01f1 01       		.byte	0x1
 2682 01f2 7901     		.2byte	0x179
 2683 01f4 3A000000 		.4byte	0x3a
 2684 01f8 02       		.uleb128 0x2
 2685 01f9 91       		.byte	0x91
 2686 01fa 76       		.sleb128 -10
 2687 01fb 00       		.byte	0
 2688 01fc 0C       		.uleb128 0xc
 2689 01fd 53040000 		.4byte	.LASF31
 2690 0201 01       		.byte	0x1
 2691 0202 DD01     		.2byte	0x1dd
 2692 0204 2C000000 		.4byte	0x2c
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 73


 2693 0208 00000000 		.4byte	.LFB69
 2694 020c AC000000 		.4byte	.LFE69-.LFB69
 2695 0210 01       		.uleb128 0x1
 2696 0211 9C       		.byte	0x9c
 2697 0212 53020000 		.4byte	0x253
 2698 0216 0E       		.uleb128 0xe
 2699 0217 FE000000 		.4byte	.LASF32
 2700 021b 01       		.byte	0x1
 2701 021c DD01     		.2byte	0x1dd
 2702 021e 3A000000 		.4byte	0x3a
 2703 0222 02       		.uleb128 0x2
 2704 0223 91       		.byte	0x91
 2705 0224 6E       		.sleb128 -18
 2706 0225 0E       		.uleb128 0xe
 2707 0226 38010000 		.4byte	.LASF33
 2708 022a 01       		.byte	0x1
 2709 022b DD01     		.2byte	0x1dd
 2710 022d 53020000 		.4byte	0x253
 2711 0231 02       		.uleb128 0x2
 2712 0232 91       		.byte	0x91
 2713 0233 68       		.sleb128 -24
 2714 0234 0D       		.uleb128 0xd
 2715 0235 0A010000 		.4byte	.LASF20
 2716 0239 01       		.byte	0x1
 2717 023a DF01     		.2byte	0x1df
 2718 023c 53000000 		.4byte	0x53
 2719 0240 02       		.uleb128 0x2
 2720 0241 91       		.byte	0x91
 2721 0242 74       		.sleb128 -12
 2722 0243 0D       		.uleb128 0xd
 2723 0244 DE030000 		.4byte	.LASF34
 2724 0248 01       		.byte	0x1
 2725 0249 E001     		.2byte	0x1e0
 2726 024b 53000000 		.4byte	0x53
 2727 024f 02       		.uleb128 0x2
 2728 0250 91       		.byte	0x91
 2729 0251 70       		.sleb128 -16
 2730 0252 00       		.byte	0
 2731 0253 05       		.uleb128 0x5
 2732 0254 04       		.byte	0x4
 2733 0255 53000000 		.4byte	0x53
 2734 0259 0C       		.uleb128 0xc
 2735 025a 11000000 		.4byte	.LASF35
 2736 025e 01       		.byte	0x1
 2737 025f 2702     		.2byte	0x227
 2738 0261 2C000000 		.4byte	0x2c
 2739 0265 00000000 		.4byte	.LFB70
 2740 0269 50010000 		.4byte	.LFE70-.LFB70
 2741 026d 01       		.uleb128 0x1
 2742 026e 9C       		.byte	0x9c
 2743 026f A1020000 		.4byte	0x2a1
 2744 0273 0D       		.uleb128 0xd
 2745 0274 BF000000 		.4byte	.LASF36
 2746 0278 01       		.byte	0x1
 2747 0279 2902     		.2byte	0x229
 2748 027b 53000000 		.4byte	0x53
 2749 027f 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 74


 2750 0280 91       		.byte	0x91
 2751 0281 70       		.sleb128 -16
 2752 0282 0D       		.uleb128 0xd
 2753 0283 3E030000 		.4byte	.LASF37
 2754 0287 01       		.byte	0x1
 2755 0288 2A02     		.2byte	0x22a
 2756 028a 3A000000 		.4byte	0x3a
 2757 028e 02       		.uleb128 0x2
 2758 028f 91       		.byte	0x91
 2759 0290 76       		.sleb128 -10
 2760 0291 0D       		.uleb128 0xd
 2761 0292 D7030000 		.4byte	.LASF38
 2762 0296 01       		.byte	0x1
 2763 0297 2B02     		.2byte	0x22b
 2764 0299 53000000 		.4byte	0x53
 2765 029d 02       		.uleb128 0x2
 2766 029e 91       		.byte	0x91
 2767 029f 6C       		.sleb128 -20
 2768 02a0 00       		.byte	0
 2769 02a1 0C       		.uleb128 0xc
 2770 02a2 8F010000 		.4byte	.LASF39
 2771 02a6 01       		.byte	0x1
 2772 02a7 B302     		.2byte	0x2b3
 2773 02a9 2C000000 		.4byte	0x2c
 2774 02ad 00000000 		.4byte	.LFB71
 2775 02b1 00010000 		.4byte	.LFE71-.LFB71
 2776 02b5 01       		.uleb128 0x1
 2777 02b6 9C       		.byte	0x9c
 2778 02b7 14030000 		.4byte	0x314
 2779 02bb 0F       		.uleb128 0xf
 2780 02bc 6900     		.ascii	"i\000"
 2781 02be 01       		.byte	0x1
 2782 02bf B502     		.2byte	0x2b5
 2783 02c1 2C000000 		.4byte	0x2c
 2784 02c5 02       		.uleb128 0x2
 2785 02c6 91       		.byte	0x91
 2786 02c7 77       		.sleb128 -9
 2787 02c8 0D       		.uleb128 0xd
 2788 02c9 A6000000 		.4byte	.LASF40
 2789 02cd 01       		.byte	0x1
 2790 02ce B602     		.2byte	0x2b6
 2791 02d0 53000000 		.4byte	0x53
 2792 02d4 02       		.uleb128 0x2
 2793 02d5 91       		.byte	0x91
 2794 02d6 6C       		.sleb128 -20
 2795 02d7 0D       		.uleb128 0xd
 2796 02d8 DB040000 		.4byte	.LASF41
 2797 02dc 01       		.byte	0x1
 2798 02dd B702     		.2byte	0x2b7
 2799 02df 53000000 		.4byte	0x53
 2800 02e3 02       		.uleb128 0x2
 2801 02e4 91       		.byte	0x91
 2802 02e5 68       		.sleb128 -24
 2803 02e6 0D       		.uleb128 0xd
 2804 02e7 0A010000 		.4byte	.LASF20
 2805 02eb 01       		.byte	0x1
 2806 02ec B902     		.2byte	0x2b9
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 75


 2807 02ee 53000000 		.4byte	0x53
 2808 02f2 02       		.uleb128 0x2
 2809 02f3 91       		.byte	0x91
 2810 02f4 70       		.sleb128 -16
 2811 02f5 0D       		.uleb128 0xd
 2812 02f6 5E000000 		.4byte	.LASF42
 2813 02fa 01       		.byte	0x1
 2814 02fb BA02     		.2byte	0x2ba
 2815 02fd 53000000 		.4byte	0x53
 2816 0301 02       		.uleb128 0x2
 2817 0302 91       		.byte	0x91
 2818 0303 64       		.sleb128 -28
 2819 0304 0D       		.uleb128 0xd
 2820 0305 6D000000 		.4byte	.LASF43
 2821 0309 01       		.byte	0x1
 2822 030a BB02     		.2byte	0x2bb
 2823 030c 53000000 		.4byte	0x53
 2824 0310 02       		.uleb128 0x2
 2825 0311 91       		.byte	0x91
 2826 0312 60       		.sleb128 -32
 2827 0313 00       		.byte	0
 2828 0314 0C       		.uleb128 0xc
 2829 0315 1F000000 		.4byte	.LASF44
 2830 0319 01       		.byte	0x1
 2831 031a 1303     		.2byte	0x313
 2832 031c 2C000000 		.4byte	0x2c
 2833 0320 00000000 		.4byte	.LFB72
 2834 0324 24010000 		.4byte	.LFE72-.LFB72
 2835 0328 01       		.uleb128 0x1
 2836 0329 9C       		.byte	0x9c
 2837 032a 3E030000 		.4byte	0x33e
 2838 032e 0D       		.uleb128 0xd
 2839 032f 0A010000 		.4byte	.LASF20
 2840 0333 01       		.byte	0x1
 2841 0334 1503     		.2byte	0x315
 2842 0336 53000000 		.4byte	0x53
 2843 033a 02       		.uleb128 0x2
 2844 033b 91       		.byte	0x91
 2845 033c 74       		.sleb128 -12
 2846 033d 00       		.byte	0
 2847 033e 10       		.uleb128 0x10
 2848 033f 8A030000 		.4byte	.LASF46
 2849 0343 01       		.byte	0x1
 2850 0344 8603     		.2byte	0x386
 2851 0346 2C000000 		.4byte	0x2c
 2852 034a 00000000 		.4byte	.LFB73
 2853 034e 30000000 		.4byte	.LFE73-.LFB73
 2854 0352 01       		.uleb128 0x1
 2855 0353 9C       		.byte	0x9c
 2856 0354 0C       		.uleb128 0xc
 2857 0355 4D010000 		.4byte	.LASF47
 2858 0359 01       		.byte	0x1
 2859 035a A703     		.2byte	0x3a7
 2860 035c 2C000000 		.4byte	0x2c
 2861 0360 00000000 		.4byte	.LFB74
 2862 0364 1C010000 		.4byte	.LFE74-.LFB74
 2863 0368 01       		.uleb128 0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 76


 2864 0369 9C       		.byte	0x9c
 2865 036a BB030000 		.4byte	0x3bb
 2866 036e 0D       		.uleb128 0xd
 2867 036f 39040000 		.4byte	.LASF27
 2868 0373 01       		.byte	0x1
 2869 0374 A903     		.2byte	0x3a9
 2870 0376 2C000000 		.4byte	0x2c
 2871 037a 02       		.uleb128 0x2
 2872 037b 91       		.byte	0x91
 2873 037c 75       		.sleb128 -11
 2874 037d 0D       		.uleb128 0xd
 2875 037e 87000000 		.4byte	.LASF28
 2876 0382 01       		.byte	0x1
 2877 0383 AA03     		.2byte	0x3aa
 2878 0385 BB030000 		.4byte	0x3bb
 2879 0389 03       		.uleb128 0x3
 2880 038a 91       		.byte	0x91
 2881 038b EC7E     		.sleb128 -148
 2882 038d 0D       		.uleb128 0xd
 2883 038e 35050000 		.4byte	.LASF48
 2884 0392 01       		.byte	0x1
 2885 0393 AC03     		.2byte	0x3ac
 2886 0395 3A000000 		.4byte	0x3a
 2887 0399 02       		.uleb128 0x2
 2888 039a 91       		.byte	0x91
 2889 039b 72       		.sleb128 -14
 2890 039c 0D       		.uleb128 0xd
 2891 039d 91040000 		.4byte	.LASF49
 2892 03a1 01       		.byte	0x1
 2893 03a2 AD03     		.2byte	0x3ad
 2894 03a4 3A000000 		.4byte	0x3a
 2895 03a8 02       		.uleb128 0x2
 2896 03a9 91       		.byte	0x91
 2897 03aa 76       		.sleb128 -10
 2898 03ab 0D       		.uleb128 0xd
 2899 03ac 0A010000 		.4byte	.LASF20
 2900 03b0 01       		.byte	0x1
 2901 03b1 AF03     		.2byte	0x3af
 2902 03b3 53000000 		.4byte	0x53
 2903 03b7 02       		.uleb128 0x2
 2904 03b8 91       		.byte	0x91
 2905 03b9 6C       		.sleb128 -20
 2906 03ba 00       		.byte	0
 2907 03bb 11       		.uleb128 0x11
 2908 03bc 2C000000 		.4byte	0x2c
 2909 03c0 CB030000 		.4byte	0x3cb
 2910 03c4 12       		.uleb128 0x12
 2911 03c5 96000000 		.4byte	0x96
 2912 03c9 7F       		.byte	0x7f
 2913 03ca 00       		.byte	0
 2914 03cb 0C       		.uleb128 0xc
 2915 03cc 67030000 		.4byte	.LASF50
 2916 03d0 01       		.byte	0x1
 2917 03d1 FD03     		.2byte	0x3fd
 2918 03d3 2C000000 		.4byte	0x2c
 2919 03d7 00000000 		.4byte	.LFB75
 2920 03db 30010000 		.4byte	.LFE75-.LFB75
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 77


 2921 03df 01       		.uleb128 0x1
 2922 03e0 9C       		.byte	0x9c
 2923 03e1 4F040000 		.4byte	0x44f
 2924 03e5 0D       		.uleb128 0xd
 2925 03e6 17030000 		.4byte	.LASF51
 2926 03ea 01       		.byte	0x1
 2927 03eb FF03     		.2byte	0x3ff
 2928 03ed 53000000 		.4byte	0x53
 2929 03f1 02       		.uleb128 0x2
 2930 03f2 91       		.byte	0x91
 2931 03f3 68       		.sleb128 -24
 2932 03f4 0D       		.uleb128 0xd
 2933 03f5 35050000 		.4byte	.LASF48
 2934 03f9 01       		.byte	0x1
 2935 03fa 0004     		.2byte	0x400
 2936 03fc 3A000000 		.4byte	0x3a
 2937 0400 02       		.uleb128 0x2
 2938 0401 91       		.byte	0x91
 2939 0402 72       		.sleb128 -14
 2940 0403 0D       		.uleb128 0xd
 2941 0404 7C000000 		.4byte	.LASF52
 2942 0408 01       		.byte	0x1
 2943 0409 0104     		.2byte	0x401
 2944 040b 53000000 		.4byte	0x53
 2945 040f 02       		.uleb128 0x2
 2946 0410 91       		.byte	0x91
 2947 0411 6C       		.sleb128 -20
 2948 0412 0D       		.uleb128 0xd
 2949 0413 91040000 		.4byte	.LASF49
 2950 0417 01       		.byte	0x1
 2951 0418 0204     		.2byte	0x402
 2952 041a 3A000000 		.4byte	0x3a
 2953 041e 02       		.uleb128 0x2
 2954 041f 91       		.byte	0x91
 2955 0420 76       		.sleb128 -10
 2956 0421 0F       		.uleb128 0xf
 2957 0422 6900     		.ascii	"i\000"
 2958 0424 01       		.byte	0x1
 2959 0425 0304     		.2byte	0x403
 2960 0427 3A000000 		.4byte	0x3a
 2961 042b 02       		.uleb128 0x2
 2962 042c 91       		.byte	0x91
 2963 042d 74       		.sleb128 -12
 2964 042e 0D       		.uleb128 0xd
 2965 042f 87000000 		.4byte	.LASF28
 2966 0433 01       		.byte	0x1
 2967 0434 0404     		.2byte	0x404
 2968 0436 BB030000 		.4byte	0x3bb
 2969 043a 03       		.uleb128 0x3
 2970 043b 91       		.byte	0x91
 2971 043c E87E     		.sleb128 -152
 2972 043e 0D       		.uleb128 0xd
 2973 043f 95020000 		.4byte	.LASF53
 2974 0443 01       		.byte	0x1
 2975 0444 0504     		.2byte	0x405
 2976 0446 BB030000 		.4byte	0x3bb
 2977 044a 03       		.uleb128 0x3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 78


 2978 044b 91       		.byte	0x91
 2979 044c E87D     		.sleb128 -280
 2980 044e 00       		.byte	0
 2981 044f 0C       		.uleb128 0xc
 2982 0450 44000000 		.4byte	.LASF54
 2983 0454 01       		.byte	0x1
 2984 0455 4804     		.2byte	0x448
 2985 0457 2C000000 		.4byte	0x2c
 2986 045b 00000000 		.4byte	.LFB76
 2987 045f 20010000 		.4byte	.LFE76-.LFB76
 2988 0463 01       		.uleb128 0x1
 2989 0464 9C       		.byte	0x9c
 2990 0465 D5040000 		.4byte	0x4d5
 2991 0469 0D       		.uleb128 0xd
 2992 046a 39040000 		.4byte	.LASF27
 2993 046e 01       		.byte	0x1
 2994 046f 4A04     		.2byte	0x44a
 2995 0471 2C000000 		.4byte	0x2c
 2996 0475 02       		.uleb128 0x2
 2997 0476 91       		.byte	0x91
 2998 0477 77       		.sleb128 -9
 2999 0478 0D       		.uleb128 0xd
 3000 0479 0B050000 		.4byte	.LASF55
 3001 047d 01       		.byte	0x1
 3002 047e 4B04     		.2byte	0x44b
 3003 0480 2C000000 		.4byte	0x2c
 3004 0484 02       		.uleb128 0x2
 3005 0485 91       		.byte	0x91
 3006 0486 76       		.sleb128 -10
 3007 0487 0D       		.uleb128 0xd
 3008 0488 51030000 		.4byte	.LASF56
 3009 048c 01       		.byte	0x1
 3010 048d 4C04     		.2byte	0x44c
 3011 048f 2C000000 		.4byte	0x2c
 3012 0493 02       		.uleb128 0x2
 3013 0494 91       		.byte	0x91
 3014 0495 75       		.sleb128 -11
 3015 0496 0D       		.uleb128 0xd
 3016 0497 C9040000 		.4byte	.LASF57
 3017 049b 01       		.byte	0x1
 3018 049c 4D04     		.2byte	0x44d
 3019 049e D5040000 		.4byte	0x4d5
 3020 04a2 03       		.uleb128 0x3
 3021 04a3 91       		.byte	0x91
 3022 04a4 AC7F     		.sleb128 -84
 3023 04a6 0D       		.uleb128 0xd
 3024 04a7 7A040000 		.4byte	.LASF25
 3025 04ab 01       		.byte	0x1
 3026 04ac 4E04     		.2byte	0x44e
 3027 04ae 2C000000 		.4byte	0x2c
 3028 04b2 03       		.uleb128 0x3
 3029 04b3 91       		.byte	0x91
 3030 04b4 AB7F     		.sleb128 -85
 3031 04b6 0D       		.uleb128 0xd
 3032 04b7 35050000 		.4byte	.LASF48
 3033 04bb 01       		.byte	0x1
 3034 04bc 5004     		.2byte	0x450
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 79


 3035 04be 3A000000 		.4byte	0x3a
 3036 04c2 02       		.uleb128 0x2
 3037 04c3 91       		.byte	0x91
 3038 04c4 72       		.sleb128 -14
 3039 04c5 0D       		.uleb128 0xd
 3040 04c6 0A010000 		.4byte	.LASF20
 3041 04ca 01       		.byte	0x1
 3042 04cb 5204     		.2byte	0x452
 3043 04cd 53000000 		.4byte	0x53
 3044 04d1 02       		.uleb128 0x2
 3045 04d2 91       		.byte	0x91
 3046 04d3 6C       		.sleb128 -20
 3047 04d4 00       		.byte	0
 3048 04d5 11       		.uleb128 0x11
 3049 04d6 2C000000 		.4byte	0x2c
 3050 04da E5040000 		.4byte	0x4e5
 3051 04de 12       		.uleb128 0x12
 3052 04df 96000000 		.4byte	0x96
 3053 04e3 3F       		.byte	0x3f
 3054 04e4 00       		.byte	0
 3055 04e5 0C       		.uleb128 0xc
 3056 04e6 47020000 		.4byte	.LASF58
 3057 04ea 01       		.byte	0x1
 3058 04eb A304     		.2byte	0x4a3
 3059 04ed 2C000000 		.4byte	0x2c
 3060 04f1 00000000 		.4byte	.LFB77
 3061 04f5 18020000 		.4byte	.LFE77-.LFB77
 3062 04f9 01       		.uleb128 0x1
 3063 04fa 9C       		.byte	0x9c
 3064 04fb 96050000 		.4byte	0x596
 3065 04ff 0D       		.uleb128 0xd
 3066 0500 80010000 		.4byte	.LASF59
 3067 0504 01       		.byte	0x1
 3068 0505 A504     		.2byte	0x4a5
 3069 0507 53000000 		.4byte	0x53
 3070 050b 02       		.uleb128 0x2
 3071 050c 91       		.byte	0x91
 3072 050d 68       		.sleb128 -24
 3073 050e 0D       		.uleb128 0xd
 3074 050f 2D000000 		.4byte	.LASF60
 3075 0513 01       		.byte	0x1
 3076 0514 A604     		.2byte	0x4a6
 3077 0516 53000000 		.4byte	0x53
 3078 051a 02       		.uleb128 0x2
 3079 051b 91       		.byte	0x91
 3080 051c 74       		.sleb128 -12
 3081 051d 0D       		.uleb128 0xd
 3082 051e 35050000 		.4byte	.LASF48
 3083 0522 01       		.byte	0x1
 3084 0523 A704     		.2byte	0x4a7
 3085 0525 3A000000 		.4byte	0x3a
 3086 0529 02       		.uleb128 0x2
 3087 052a 91       		.byte	0x91
 3088 052b 70       		.sleb128 -16
 3089 052c 0D       		.uleb128 0xd
 3090 052d 7A040000 		.4byte	.LASF25
 3091 0531 01       		.byte	0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 80


 3092 0532 A804     		.2byte	0x4a8
 3093 0534 2C000000 		.4byte	0x2c
 3094 0538 02       		.uleb128 0x2
 3095 0539 91       		.byte	0x91
 3096 053a 67       		.sleb128 -25
 3097 053b 0D       		.uleb128 0xd
 3098 053c 51030000 		.4byte	.LASF56
 3099 0540 01       		.byte	0x1
 3100 0541 A904     		.2byte	0x4a9
 3101 0543 2C000000 		.4byte	0x2c
 3102 0547 02       		.uleb128 0x2
 3103 0548 91       		.byte	0x91
 3104 0549 6F       		.sleb128 -17
 3105 054a 0F       		.uleb128 0xf
 3106 054b 6900     		.ascii	"i\000"
 3107 054d 01       		.byte	0x1
 3108 054e AA04     		.2byte	0x4aa
 3109 0550 2C000000 		.4byte	0x2c
 3110 0554 02       		.uleb128 0x2
 3111 0555 91       		.byte	0x91
 3112 0556 73       		.sleb128 -13
 3113 0557 0D       		.uleb128 0xd
 3114 0558 C9040000 		.4byte	.LASF57
 3115 055c 01       		.byte	0x1
 3116 055d AB04     		.2byte	0x4ab
 3117 055f D5040000 		.4byte	0x4d5
 3118 0563 03       		.uleb128 0x3
 3119 0564 91       		.byte	0x91
 3120 0565 A47F     		.sleb128 -92
 3121 0567 0D       		.uleb128 0xd
 3122 0568 70020000 		.4byte	.LASF61
 3123 056c 01       		.byte	0x1
 3124 056d AC04     		.2byte	0x4ac
 3125 056f D5040000 		.4byte	0x4d5
 3126 0573 03       		.uleb128 0x3
 3127 0574 91       		.byte	0x91
 3128 0575 E47E     		.sleb128 -156
 3129 0577 0D       		.uleb128 0xd
 3130 0578 39040000 		.4byte	.LASF27
 3131 057c 01       		.byte	0x1
 3132 057d AD04     		.2byte	0x4ad
 3133 057f 2C000000 		.4byte	0x2c
 3134 0583 02       		.uleb128 0x2
 3135 0584 91       		.byte	0x91
 3136 0585 72       		.sleb128 -14
 3137 0586 0D       		.uleb128 0xd
 3138 0587 0B050000 		.4byte	.LASF55
 3139 058b 01       		.byte	0x1
 3140 058c AE04     		.2byte	0x4ae
 3141 058e 2C000000 		.4byte	0x2c
 3142 0592 02       		.uleb128 0x2
 3143 0593 91       		.byte	0x91
 3144 0594 6E       		.sleb128 -18
 3145 0595 00       		.byte	0
 3146 0596 0C       		.uleb128 0xc
 3147 0597 F1030000 		.4byte	.LASF62
 3148 059b 01       		.byte	0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 81


 3149 059c 1005     		.2byte	0x510
 3150 059e 2C000000 		.4byte	0x2c
 3151 05a2 00000000 		.4byte	.LFB78
 3152 05a6 7C000000 		.4byte	.LFE78-.LFB78
 3153 05aa 01       		.uleb128 0x1
 3154 05ab 9C       		.byte	0x9c
 3155 05ac DE050000 		.4byte	0x5de
 3156 05b0 0D       		.uleb128 0xd
 3157 05b1 1B040000 		.4byte	.LASF63
 3158 05b5 01       		.byte	0x1
 3159 05b6 1205     		.2byte	0x512
 3160 05b8 53000000 		.4byte	0x53
 3161 05bc 02       		.uleb128 0x2
 3162 05bd 91       		.byte	0x91
 3163 05be 70       		.sleb128 -16
 3164 05bf 0D       		.uleb128 0xd
 3165 05c0 87020000 		.4byte	.LASF64
 3166 05c4 01       		.byte	0x1
 3167 05c5 1305     		.2byte	0x513
 3168 05c7 3A000000 		.4byte	0x3a
 3169 05cb 02       		.uleb128 0x2
 3170 05cc 91       		.byte	0x91
 3171 05cd 76       		.sleb128 -10
 3172 05ce 0D       		.uleb128 0xd
 3173 05cf 8F000000 		.4byte	.LASF65
 3174 05d3 01       		.byte	0x1
 3175 05d4 1405     		.2byte	0x514
 3176 05d6 3A000000 		.4byte	0x3a
 3177 05da 02       		.uleb128 0x2
 3178 05db 91       		.byte	0x91
 3179 05dc 6E       		.sleb128 -18
 3180 05dd 00       		.byte	0
 3181 05de 13       		.uleb128 0x13
 3182 05df 14050000 		.4byte	.LASF66
 3183 05e3 01       		.byte	0x1
 3184 05e4 4005     		.2byte	0x540
 3185 05e6 2C000000 		.4byte	0x2c
 3186 05ea 00000000 		.4byte	.LFB79
 3187 05ee 18000000 		.4byte	.LFE79-.LFB79
 3188 05f2 01       		.uleb128 0x1
 3189 05f3 9C       		.byte	0x9c
 3190 05f4 14       		.uleb128 0x14
 3191 05f5 66040000 		.4byte	.LASF79
 3192 05f9 01       		.byte	0x1
 3193 05fa 5405     		.2byte	0x554
 3194 05fc 00000000 		.4byte	.LFB80
 3195 0600 26000000 		.4byte	.LFE80-.LFB80
 3196 0604 01       		.uleb128 0x1
 3197 0605 9C       		.byte	0x9c
 3198 0606 15       		.uleb128 0x15
 3199 0607 FD040000 		.4byte	.LASF67
 3200 060b 04       		.byte	0x4
 3201 060c 55       		.byte	0x55
 3202 060d 2C000000 		.4byte	0x2c
 3203 0611 16       		.uleb128 0x16
 3204 0612 28050000 		.4byte	.LASF68
 3205 0616 05       		.byte	0x5
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 82


 3206 0617 9606     		.2byte	0x696
 3207 0619 1D060000 		.4byte	0x61d
 3208 061d 17       		.uleb128 0x17
 3209 061e 76000000 		.4byte	0x76
 3210 0622 18       		.uleb128 0x18
 3211 0623 5A010000 		.4byte	.LASF69
 3212 0627 01       		.byte	0x1
 3213 0628 42       		.byte	0x42
 3214 0629 53000000 		.4byte	0x53
 3215 062d 05       		.uleb128 0x5
 3216 062e 03       		.byte	0x3
 3217 062f 00000000 		.4byte	checksum_Privileged
 3218 0633 18       		.uleb128 0x18
 3219 0634 B9030000 		.4byte	.LASF70
 3220 0638 01       		.byte	0x1
 3221 0639 43       		.byte	0x43
 3222 063a 53000000 		.4byte	0x53
 3223 063e 05       		.uleb128 0x5
 3224 063f 03       		.byte	0x3
 3225 0640 00000000 		.4byte	statusCode
 3226 0644 18       		.uleb128 0x18
 3227 0645 69020000 		.4byte	.LASF71
 3228 0649 01       		.byte	0x1
 3229 064a 45       		.byte	0x45
 3230 064b 2C000000 		.4byte	0x2c
 3231 064f 05       		.uleb128 0x5
 3232 0650 03       		.byte	0x3
 3233 0651 00000000 		.4byte	result
 3234 0655 18       		.uleb128 0x18
 3235 0656 20010000 		.4byte	.LASF72
 3236 065a 01       		.byte	0x1
 3237 065b 46       		.byte	0x46
 3238 065c 2C000000 		.4byte	0x2c
 3239 0660 05       		.uleb128 0x5
 3240 0661 03       		.byte	0x3
 3241 0662 00000000 		.4byte	chipProtectionData_Chip
 3242 0666 18       		.uleb128 0x18
 3243 0667 28040000 		.4byte	.LASF73
 3244 066b 01       		.byte	0x1
 3245 066c 48       		.byte	0x48
 3246 066d A3000000 		.4byte	0xa3
 3247 0671 05       		.uleb128 0x5
 3248 0672 03       		.byte	0x3
 3249 0673 00000000 		.4byte	flow
 3250 0677 00       		.byte	0
 3251              		.section	.debug_abbrev,"",%progbits
 3252              	.Ldebug_abbrev0:
 3253 0000 01       		.uleb128 0x1
 3254 0001 11       		.uleb128 0x11
 3255 0002 01       		.byte	0x1
 3256 0003 25       		.uleb128 0x25
 3257 0004 0E       		.uleb128 0xe
 3258 0005 13       		.uleb128 0x13
 3259 0006 0B       		.uleb128 0xb
 3260 0007 03       		.uleb128 0x3
 3261 0008 0E       		.uleb128 0xe
 3262 0009 1B       		.uleb128 0x1b
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 83


 3263 000a 0E       		.uleb128 0xe
 3264 000b 55       		.uleb128 0x55
 3265 000c 17       		.uleb128 0x17
 3266 000d 11       		.uleb128 0x11
 3267 000e 01       		.uleb128 0x1
 3268 000f 10       		.uleb128 0x10
 3269 0010 17       		.uleb128 0x17
 3270 0011 00       		.byte	0
 3271 0012 00       		.byte	0
 3272 0013 02       		.uleb128 0x2
 3273 0014 24       		.uleb128 0x24
 3274 0015 00       		.byte	0
 3275 0016 0B       		.uleb128 0xb
 3276 0017 0B       		.uleb128 0xb
 3277 0018 3E       		.uleb128 0x3e
 3278 0019 0B       		.uleb128 0xb
 3279 001a 03       		.uleb128 0x3
 3280 001b 0E       		.uleb128 0xe
 3281 001c 00       		.byte	0
 3282 001d 00       		.byte	0
 3283 001e 03       		.uleb128 0x3
 3284 001f 16       		.uleb128 0x16
 3285 0020 00       		.byte	0
 3286 0021 03       		.uleb128 0x3
 3287 0022 0E       		.uleb128 0xe
 3288 0023 3A       		.uleb128 0x3a
 3289 0024 0B       		.uleb128 0xb
 3290 0025 3B       		.uleb128 0x3b
 3291 0026 0B       		.uleb128 0xb
 3292 0027 49       		.uleb128 0x49
 3293 0028 13       		.uleb128 0x13
 3294 0029 00       		.byte	0
 3295 002a 00       		.byte	0
 3296 002b 04       		.uleb128 0x4
 3297 002c 24       		.uleb128 0x24
 3298 002d 00       		.byte	0
 3299 002e 0B       		.uleb128 0xb
 3300 002f 0B       		.uleb128 0xb
 3301 0030 3E       		.uleb128 0x3e
 3302 0031 0B       		.uleb128 0xb
 3303 0032 03       		.uleb128 0x3
 3304 0033 08       		.uleb128 0x8
 3305 0034 00       		.byte	0
 3306 0035 00       		.byte	0
 3307 0036 05       		.uleb128 0x5
 3308 0037 0F       		.uleb128 0xf
 3309 0038 00       		.byte	0
 3310 0039 0B       		.uleb128 0xb
 3311 003a 0B       		.uleb128 0xb
 3312 003b 49       		.uleb128 0x49
 3313 003c 13       		.uleb128 0x13
 3314 003d 00       		.byte	0
 3315 003e 00       		.byte	0
 3316 003f 06       		.uleb128 0x6
 3317 0040 04       		.uleb128 0x4
 3318 0041 01       		.byte	0x1
 3319 0042 03       		.uleb128 0x3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 84


 3320 0043 0E       		.uleb128 0xe
 3321 0044 0B       		.uleb128 0xb
 3322 0045 0B       		.uleb128 0xb
 3323 0046 3A       		.uleb128 0x3a
 3324 0047 0B       		.uleb128 0xb
 3325 0048 3B       		.uleb128 0x3b
 3326 0049 0B       		.uleb128 0xb
 3327 004a 01       		.uleb128 0x1
 3328 004b 13       		.uleb128 0x13
 3329 004c 00       		.byte	0
 3330 004d 00       		.byte	0
 3331 004e 07       		.uleb128 0x7
 3332 004f 28       		.uleb128 0x28
 3333 0050 00       		.byte	0
 3334 0051 03       		.uleb128 0x3
 3335 0052 0E       		.uleb128 0xe
 3336 0053 1C       		.uleb128 0x1c
 3337 0054 0D       		.uleb128 0xd
 3338 0055 00       		.byte	0
 3339 0056 00       		.byte	0
 3340 0057 08       		.uleb128 0x8
 3341 0058 2E       		.uleb128 0x2e
 3342 0059 01       		.byte	0x1
 3343 005a 3F       		.uleb128 0x3f
 3344 005b 19       		.uleb128 0x19
 3345 005c 03       		.uleb128 0x3
 3346 005d 0E       		.uleb128 0xe
 3347 005e 3A       		.uleb128 0x3a
 3348 005f 0B       		.uleb128 0xb
 3349 0060 3B       		.uleb128 0x3b
 3350 0061 0B       		.uleb128 0xb
 3351 0062 27       		.uleb128 0x27
 3352 0063 19       		.uleb128 0x19
 3353 0064 49       		.uleb128 0x49
 3354 0065 13       		.uleb128 0x13
 3355 0066 11       		.uleb128 0x11
 3356 0067 01       		.uleb128 0x1
 3357 0068 12       		.uleb128 0x12
 3358 0069 06       		.uleb128 0x6
 3359 006a 40       		.uleb128 0x40
 3360 006b 18       		.uleb128 0x18
 3361 006c 9642     		.uleb128 0x2116
 3362 006e 19       		.uleb128 0x19
 3363 006f 01       		.uleb128 0x1
 3364 0070 13       		.uleb128 0x13
 3365 0071 00       		.byte	0
 3366 0072 00       		.byte	0
 3367 0073 09       		.uleb128 0x9
 3368 0074 34       		.uleb128 0x34
 3369 0075 00       		.byte	0
 3370 0076 03       		.uleb128 0x3
 3371 0077 0E       		.uleb128 0xe
 3372 0078 3A       		.uleb128 0x3a
 3373 0079 0B       		.uleb128 0xb
 3374 007a 3B       		.uleb128 0x3b
 3375 007b 0B       		.uleb128 0xb
 3376 007c 49       		.uleb128 0x49
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 85


 3377 007d 13       		.uleb128 0x13
 3378 007e 02       		.uleb128 0x2
 3379 007f 18       		.uleb128 0x18
 3380 0080 00       		.byte	0
 3381 0081 00       		.byte	0
 3382 0082 0A       		.uleb128 0xa
 3383 0083 2E       		.uleb128 0x2e
 3384 0084 01       		.byte	0x1
 3385 0085 3F       		.uleb128 0x3f
 3386 0086 19       		.uleb128 0x19
 3387 0087 03       		.uleb128 0x3
 3388 0088 0E       		.uleb128 0xe
 3389 0089 3A       		.uleb128 0x3a
 3390 008a 0B       		.uleb128 0xb
 3391 008b 3B       		.uleb128 0x3b
 3392 008c 0B       		.uleb128 0xb
 3393 008d 27       		.uleb128 0x27
 3394 008e 19       		.uleb128 0x19
 3395 008f 11       		.uleb128 0x11
 3396 0090 01       		.uleb128 0x1
 3397 0091 12       		.uleb128 0x12
 3398 0092 06       		.uleb128 0x6
 3399 0093 40       		.uleb128 0x40
 3400 0094 18       		.uleb128 0x18
 3401 0095 9642     		.uleb128 0x2116
 3402 0097 19       		.uleb128 0x19
 3403 0098 01       		.uleb128 0x1
 3404 0099 13       		.uleb128 0x13
 3405 009a 00       		.byte	0
 3406 009b 00       		.byte	0
 3407 009c 0B       		.uleb128 0xb
 3408 009d 2E       		.uleb128 0x2e
 3409 009e 00       		.byte	0
 3410 009f 3F       		.uleb128 0x3f
 3411 00a0 19       		.uleb128 0x19
 3412 00a1 03       		.uleb128 0x3
 3413 00a2 0E       		.uleb128 0xe
 3414 00a3 3A       		.uleb128 0x3a
 3415 00a4 0B       		.uleb128 0xb
 3416 00a5 3B       		.uleb128 0x3b
 3417 00a6 0B       		.uleb128 0xb
 3418 00a7 27       		.uleb128 0x27
 3419 00a8 19       		.uleb128 0x19
 3420 00a9 49       		.uleb128 0x49
 3421 00aa 13       		.uleb128 0x13
 3422 00ab 11       		.uleb128 0x11
 3423 00ac 01       		.uleb128 0x1
 3424 00ad 12       		.uleb128 0x12
 3425 00ae 06       		.uleb128 0x6
 3426 00af 40       		.uleb128 0x40
 3427 00b0 18       		.uleb128 0x18
 3428 00b1 9742     		.uleb128 0x2117
 3429 00b3 19       		.uleb128 0x19
 3430 00b4 00       		.byte	0
 3431 00b5 00       		.byte	0
 3432 00b6 0C       		.uleb128 0xc
 3433 00b7 2E       		.uleb128 0x2e
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 86


 3434 00b8 01       		.byte	0x1
 3435 00b9 3F       		.uleb128 0x3f
 3436 00ba 19       		.uleb128 0x19
 3437 00bb 03       		.uleb128 0x3
 3438 00bc 0E       		.uleb128 0xe
 3439 00bd 3A       		.uleb128 0x3a
 3440 00be 0B       		.uleb128 0xb
 3441 00bf 3B       		.uleb128 0x3b
 3442 00c0 05       		.uleb128 0x5
 3443 00c1 27       		.uleb128 0x27
 3444 00c2 19       		.uleb128 0x19
 3445 00c3 49       		.uleb128 0x49
 3446 00c4 13       		.uleb128 0x13
 3447 00c5 11       		.uleb128 0x11
 3448 00c6 01       		.uleb128 0x1
 3449 00c7 12       		.uleb128 0x12
 3450 00c8 06       		.uleb128 0x6
 3451 00c9 40       		.uleb128 0x40
 3452 00ca 18       		.uleb128 0x18
 3453 00cb 9642     		.uleb128 0x2116
 3454 00cd 19       		.uleb128 0x19
 3455 00ce 01       		.uleb128 0x1
 3456 00cf 13       		.uleb128 0x13
 3457 00d0 00       		.byte	0
 3458 00d1 00       		.byte	0
 3459 00d2 0D       		.uleb128 0xd
 3460 00d3 34       		.uleb128 0x34
 3461 00d4 00       		.byte	0
 3462 00d5 03       		.uleb128 0x3
 3463 00d6 0E       		.uleb128 0xe
 3464 00d7 3A       		.uleb128 0x3a
 3465 00d8 0B       		.uleb128 0xb
 3466 00d9 3B       		.uleb128 0x3b
 3467 00da 05       		.uleb128 0x5
 3468 00db 49       		.uleb128 0x49
 3469 00dc 13       		.uleb128 0x13
 3470 00dd 02       		.uleb128 0x2
 3471 00de 18       		.uleb128 0x18
 3472 00df 00       		.byte	0
 3473 00e0 00       		.byte	0
 3474 00e1 0E       		.uleb128 0xe
 3475 00e2 05       		.uleb128 0x5
 3476 00e3 00       		.byte	0
 3477 00e4 03       		.uleb128 0x3
 3478 00e5 0E       		.uleb128 0xe
 3479 00e6 3A       		.uleb128 0x3a
 3480 00e7 0B       		.uleb128 0xb
 3481 00e8 3B       		.uleb128 0x3b
 3482 00e9 05       		.uleb128 0x5
 3483 00ea 49       		.uleb128 0x49
 3484 00eb 13       		.uleb128 0x13
 3485 00ec 02       		.uleb128 0x2
 3486 00ed 18       		.uleb128 0x18
 3487 00ee 00       		.byte	0
 3488 00ef 00       		.byte	0
 3489 00f0 0F       		.uleb128 0xf
 3490 00f1 34       		.uleb128 0x34
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 87


 3491 00f2 00       		.byte	0
 3492 00f3 03       		.uleb128 0x3
 3493 00f4 08       		.uleb128 0x8
 3494 00f5 3A       		.uleb128 0x3a
 3495 00f6 0B       		.uleb128 0xb
 3496 00f7 3B       		.uleb128 0x3b
 3497 00f8 05       		.uleb128 0x5
 3498 00f9 49       		.uleb128 0x49
 3499 00fa 13       		.uleb128 0x13
 3500 00fb 02       		.uleb128 0x2
 3501 00fc 18       		.uleb128 0x18
 3502 00fd 00       		.byte	0
 3503 00fe 00       		.byte	0
 3504 00ff 10       		.uleb128 0x10
 3505 0100 2E       		.uleb128 0x2e
 3506 0101 00       		.byte	0
 3507 0102 3F       		.uleb128 0x3f
 3508 0103 19       		.uleb128 0x19
 3509 0104 03       		.uleb128 0x3
 3510 0105 0E       		.uleb128 0xe
 3511 0106 3A       		.uleb128 0x3a
 3512 0107 0B       		.uleb128 0xb
 3513 0108 3B       		.uleb128 0x3b
 3514 0109 05       		.uleb128 0x5
 3515 010a 27       		.uleb128 0x27
 3516 010b 19       		.uleb128 0x19
 3517 010c 49       		.uleb128 0x49
 3518 010d 13       		.uleb128 0x13
 3519 010e 11       		.uleb128 0x11
 3520 010f 01       		.uleb128 0x1
 3521 0110 12       		.uleb128 0x12
 3522 0111 06       		.uleb128 0x6
 3523 0112 40       		.uleb128 0x40
 3524 0113 18       		.uleb128 0x18
 3525 0114 9642     		.uleb128 0x2116
 3526 0116 19       		.uleb128 0x19
 3527 0117 00       		.byte	0
 3528 0118 00       		.byte	0
 3529 0119 11       		.uleb128 0x11
 3530 011a 01       		.uleb128 0x1
 3531 011b 01       		.byte	0x1
 3532 011c 49       		.uleb128 0x49
 3533 011d 13       		.uleb128 0x13
 3534 011e 01       		.uleb128 0x1
 3535 011f 13       		.uleb128 0x13
 3536 0120 00       		.byte	0
 3537 0121 00       		.byte	0
 3538 0122 12       		.uleb128 0x12
 3539 0123 21       		.uleb128 0x21
 3540 0124 00       		.byte	0
 3541 0125 49       		.uleb128 0x49
 3542 0126 13       		.uleb128 0x13
 3543 0127 2F       		.uleb128 0x2f
 3544 0128 0B       		.uleb128 0xb
 3545 0129 00       		.byte	0
 3546 012a 00       		.byte	0
 3547 012b 13       		.uleb128 0x13
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 88


 3548 012c 2E       		.uleb128 0x2e
 3549 012d 00       		.byte	0
 3550 012e 3F       		.uleb128 0x3f
 3551 012f 19       		.uleb128 0x19
 3552 0130 03       		.uleb128 0x3
 3553 0131 0E       		.uleb128 0xe
 3554 0132 3A       		.uleb128 0x3a
 3555 0133 0B       		.uleb128 0xb
 3556 0134 3B       		.uleb128 0x3b
 3557 0135 05       		.uleb128 0x5
 3558 0136 27       		.uleb128 0x27
 3559 0137 19       		.uleb128 0x19
 3560 0138 49       		.uleb128 0x49
 3561 0139 13       		.uleb128 0x13
 3562 013a 11       		.uleb128 0x11
 3563 013b 01       		.uleb128 0x1
 3564 013c 12       		.uleb128 0x12
 3565 013d 06       		.uleb128 0x6
 3566 013e 40       		.uleb128 0x40
 3567 013f 18       		.uleb128 0x18
 3568 0140 9742     		.uleb128 0x2117
 3569 0142 19       		.uleb128 0x19
 3570 0143 00       		.byte	0
 3571 0144 00       		.byte	0
 3572 0145 14       		.uleb128 0x14
 3573 0146 2E       		.uleb128 0x2e
 3574 0147 00       		.byte	0
 3575 0148 3F       		.uleb128 0x3f
 3576 0149 19       		.uleb128 0x19
 3577 014a 03       		.uleb128 0x3
 3578 014b 0E       		.uleb128 0xe
 3579 014c 3A       		.uleb128 0x3a
 3580 014d 0B       		.uleb128 0xb
 3581 014e 3B       		.uleb128 0x3b
 3582 014f 05       		.uleb128 0x5
 3583 0150 27       		.uleb128 0x27
 3584 0151 19       		.uleb128 0x19
 3585 0152 11       		.uleb128 0x11
 3586 0153 01       		.uleb128 0x1
 3587 0154 12       		.uleb128 0x12
 3588 0155 06       		.uleb128 0x6
 3589 0156 40       		.uleb128 0x40
 3590 0157 18       		.uleb128 0x18
 3591 0158 9642     		.uleb128 0x2116
 3592 015a 19       		.uleb128 0x19
 3593 015b 00       		.byte	0
 3594 015c 00       		.byte	0
 3595 015d 15       		.uleb128 0x15
 3596 015e 34       		.uleb128 0x34
 3597 015f 00       		.byte	0
 3598 0160 03       		.uleb128 0x3
 3599 0161 0E       		.uleb128 0xe
 3600 0162 3A       		.uleb128 0x3a
 3601 0163 0B       		.uleb128 0xb
 3602 0164 3B       		.uleb128 0x3b
 3603 0165 0B       		.uleb128 0xb
 3604 0166 49       		.uleb128 0x49
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 89


 3605 0167 13       		.uleb128 0x13
 3606 0168 3F       		.uleb128 0x3f
 3607 0169 19       		.uleb128 0x19
 3608 016a 3C       		.uleb128 0x3c
 3609 016b 19       		.uleb128 0x19
 3610 016c 00       		.byte	0
 3611 016d 00       		.byte	0
 3612 016e 16       		.uleb128 0x16
 3613 016f 34       		.uleb128 0x34
 3614 0170 00       		.byte	0
 3615 0171 03       		.uleb128 0x3
 3616 0172 0E       		.uleb128 0xe
 3617 0173 3A       		.uleb128 0x3a
 3618 0174 0B       		.uleb128 0xb
 3619 0175 3B       		.uleb128 0x3b
 3620 0176 05       		.uleb128 0x5
 3621 0177 49       		.uleb128 0x49
 3622 0178 13       		.uleb128 0x13
 3623 0179 3F       		.uleb128 0x3f
 3624 017a 19       		.uleb128 0x19
 3625 017b 3C       		.uleb128 0x3c
 3626 017c 19       		.uleb128 0x19
 3627 017d 00       		.byte	0
 3628 017e 00       		.byte	0
 3629 017f 17       		.uleb128 0x17
 3630 0180 35       		.uleb128 0x35
 3631 0181 00       		.byte	0
 3632 0182 49       		.uleb128 0x49
 3633 0183 13       		.uleb128 0x13
 3634 0184 00       		.byte	0
 3635 0185 00       		.byte	0
 3636 0186 18       		.uleb128 0x18
 3637 0187 34       		.uleb128 0x34
 3638 0188 00       		.byte	0
 3639 0189 03       		.uleb128 0x3
 3640 018a 0E       		.uleb128 0xe
 3641 018b 3A       		.uleb128 0x3a
 3642 018c 0B       		.uleb128 0xb
 3643 018d 3B       		.uleb128 0x3b
 3644 018e 0B       		.uleb128 0xb
 3645 018f 49       		.uleb128 0x49
 3646 0190 13       		.uleb128 0x13
 3647 0191 3F       		.uleb128 0x3f
 3648 0192 19       		.uleb128 0x19
 3649 0193 02       		.uleb128 0x2
 3650 0194 18       		.uleb128 0x18
 3651 0195 00       		.byte	0
 3652 0196 00       		.byte	0
 3653 0197 00       		.byte	0
 3654              		.section	.debug_aranges,"",%progbits
 3655 0000 A4000000 		.4byte	0xa4
 3656 0004 0200     		.2byte	0x2
 3657 0006 00000000 		.4byte	.Ldebug_info0
 3658 000a 04       		.byte	0x4
 3659 000b 00       		.byte	0
 3660 000c 0000     		.2byte	0
 3661 000e 0000     		.2byte	0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 90


 3662 0010 00000000 		.4byte	.LFB63
 3663 0014 9C000000 		.4byte	.LFE63-.LFB63
 3664 0018 00000000 		.4byte	.LFB64
 3665 001c 34000000 		.4byte	.LFE64-.LFB64
 3666 0020 00000000 		.4byte	.LFB65
 3667 0024 18000000 		.4byte	.LFE65-.LFB65
 3668 0028 00000000 		.4byte	.LFB66
 3669 002c 94000000 		.4byte	.LFE66-.LFB66
 3670 0030 00000000 		.4byte	.LFB67
 3671 0034 A4000000 		.4byte	.LFE67-.LFB67
 3672 0038 00000000 		.4byte	.LFB68
 3673 003c 24010000 		.4byte	.LFE68-.LFB68
 3674 0040 00000000 		.4byte	.LFB69
 3675 0044 AC000000 		.4byte	.LFE69-.LFB69
 3676 0048 00000000 		.4byte	.LFB70
 3677 004c 50010000 		.4byte	.LFE70-.LFB70
 3678 0050 00000000 		.4byte	.LFB71
 3679 0054 00010000 		.4byte	.LFE71-.LFB71
 3680 0058 00000000 		.4byte	.LFB72
 3681 005c 24010000 		.4byte	.LFE72-.LFB72
 3682 0060 00000000 		.4byte	.LFB73
 3683 0064 30000000 		.4byte	.LFE73-.LFB73
 3684 0068 00000000 		.4byte	.LFB74
 3685 006c 1C010000 		.4byte	.LFE74-.LFB74
 3686 0070 00000000 		.4byte	.LFB75
 3687 0074 30010000 		.4byte	.LFE75-.LFB75
 3688 0078 00000000 		.4byte	.LFB76
 3689 007c 20010000 		.4byte	.LFE76-.LFB76
 3690 0080 00000000 		.4byte	.LFB77
 3691 0084 18020000 		.4byte	.LFE77-.LFB77
 3692 0088 00000000 		.4byte	.LFB78
 3693 008c 7C000000 		.4byte	.LFE78-.LFB78
 3694 0090 00000000 		.4byte	.LFB79
 3695 0094 18000000 		.4byte	.LFE79-.LFB79
 3696 0098 00000000 		.4byte	.LFB80
 3697 009c 26000000 		.4byte	.LFE80-.LFB80
 3698 00a0 00000000 		.4byte	0
 3699 00a4 00000000 		.4byte	0
 3700              		.section	.debug_ranges,"",%progbits
 3701              	.Ldebug_ranges0:
 3702 0000 00000000 		.4byte	.LFB63
 3703 0004 9C000000 		.4byte	.LFE63
 3704 0008 00000000 		.4byte	.LFB64
 3705 000c 34000000 		.4byte	.LFE64
 3706 0010 00000000 		.4byte	.LFB65
 3707 0014 18000000 		.4byte	.LFE65
 3708 0018 00000000 		.4byte	.LFB66
 3709 001c 94000000 		.4byte	.LFE66
 3710 0020 00000000 		.4byte	.LFB67
 3711 0024 A4000000 		.4byte	.LFE67
 3712 0028 00000000 		.4byte	.LFB68
 3713 002c 24010000 		.4byte	.LFE68
 3714 0030 00000000 		.4byte	.LFB69
 3715 0034 AC000000 		.4byte	.LFE69
 3716 0038 00000000 		.4byte	.LFB70
 3717 003c 50010000 		.4byte	.LFE70
 3718 0040 00000000 		.4byte	.LFB71
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 91


 3719 0044 00010000 		.4byte	.LFE71
 3720 0048 00000000 		.4byte	.LFB72
 3721 004c 24010000 		.4byte	.LFE72
 3722 0050 00000000 		.4byte	.LFB73
 3723 0054 30000000 		.4byte	.LFE73
 3724 0058 00000000 		.4byte	.LFB74
 3725 005c 1C010000 		.4byte	.LFE74
 3726 0060 00000000 		.4byte	.LFB75
 3727 0064 30010000 		.4byte	.LFE75
 3728 0068 00000000 		.4byte	.LFB76
 3729 006c 20010000 		.4byte	.LFE76
 3730 0070 00000000 		.4byte	.LFB77
 3731 0074 18020000 		.4byte	.LFE77
 3732 0078 00000000 		.4byte	.LFB78
 3733 007c 7C000000 		.4byte	.LFE78
 3734 0080 00000000 		.4byte	.LFB79
 3735 0084 18000000 		.4byte	.LFE79
 3736 0088 00000000 		.4byte	.LFB80
 3737 008c 26000000 		.4byte	.LFE80
 3738 0090 00000000 		.4byte	0
 3739 0094 00000000 		.4byte	0
 3740              		.section	.debug_line,"",%progbits
 3741              	.Ldebug_line0:
 3742 0000 0B050000 		.section	.debug_str,"MS",%progbits,1
 3742      02004F01 
 3742      00000201 
 3742      FB0E0D00 
 3742      01010101 
 3743              	.LASF18:
 3744 0000 57524F4E 		.ascii	"WRONG_TRANSITION\000"
 3744      475F5452 
 3744      414E5349 
 3744      54494F4E 
 3744      00
 3745              	.LASF35:
 3746 0011 44657669 		.ascii	"DeviceAcquire\000"
 3746      63654163 
 3746      71756972 
 3746      6500
 3747              	.LASF44:
 3748 001f 45726173 		.ascii	"EraseAllFlash\000"
 3748      65416C6C 
 3748      466C6173 
 3748      6800
 3749              	.LASF60:
 3750 002d 666C6173 		.ascii	"flashProtectionAddress\000"
 3750      6850726F 
 3750      74656374 
 3750      696F6E41 
 3750      64647265 
 3751              	.LASF54:
 3752 0044 50726F67 		.ascii	"ProgramProtectionSettings\000"
 3752      72616D50 
 3752      726F7465 
 3752      6374696F 
 3752      6E536574 
 3753              	.LASF42:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 92


 3754 005e 73696C69 		.ascii	"siliconIdData1\000"
 3754      636F6E49 
 3754      64446174 
 3754      613100
 3755              	.LASF43:
 3756 006d 73696C69 		.ascii	"siliconIdData2\000"
 3756      636F6E49 
 3756      64446174 
 3756      613200
 3757              	.LASF52:
 3758 007c 726F7741 		.ascii	"rowAddress\000"
 3758      64647265 
 3758      737300
 3759              	.LASF28:
 3760 0087 726F7744 		.ascii	"rowData\000"
 3760      61746100 
 3761              	.LASF65:
 3762 008f 63686563 		.ascii	"checksumData\000"
 3762      6B73756D 
 3762      44617461 
 3762      00
 3763              	.LASF2:
 3764 009c 73686F72 		.ascii	"short int\000"
 3764      7420696E 
 3764      7400
 3765              	.LASF40:
 3766 00a6 64657669 		.ascii	"deviceSiliconID\000"
 3766      63655369 
 3766      6C69636F 
 3766      6E494400 
 3767              	.LASF14:
 3768 00b6 73697A65 		.ascii	"sizetype\000"
 3768      74797065 
 3768      00
 3769              	.LASF36:
 3770 00bf 63686970 		.ascii	"chip_DAP_Id\000"
 3770      5F444150 
 3770      5F496400 
 3771              	.LASF24:
 3772 00cb 47657454 		.ascii	"GetTransitionMode\000"
 3772      72616E73 
 3772      6974696F 
 3772      6E4D6F64 
 3772      6500
 3773              	.LASF75:
 3774 00dd 50726F67 		.ascii	"ProgrammingSteps.c\000"
 3774      72616D6D 
 3774      696E6753 
 3774      74657073 
 3774      2E6300
 3775              	.LASF6:
 3776 00f0 6C6F6E67 		.ascii	"long long int\000"
 3776      206C6F6E 
 3776      6720696E 
 3776      7400
 3777              	.LASF32:
 3778 00fe 63686563 		.ascii	"checksumRow\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 93


 3778      6B73756D 
 3778      526F7700 
 3779              	.LASF20:
 3780 010a 70617261 		.ascii	"parameter1\000"
 3780      6D657465 
 3780      723100
 3781              	.LASF30:
 3782 0115 70617261 		.ascii	"parameter2\000"
 3782      6D657465 
 3782      723200
 3783              	.LASF72:
 3784 0120 63686970 		.ascii	"chipProtectionData_Chip\000"
 3784      50726F74 
 3784      65637469 
 3784      6F6E4461 
 3784      74615F43 
 3785              	.LASF33:
 3786 0138 63686563 		.ascii	"checksum\000"
 3786      6B73756D 
 3786      00
 3787              	.LASF29:
 3788 0141 726F7742 		.ascii	"rowByteSize\000"
 3788      79746553 
 3788      697A6500 
 3789              	.LASF47:
 3790 014d 50726F67 		.ascii	"ProgramFlash\000"
 3790      72616D46 
 3790      6C617368 
 3790      00
 3791              	.LASF69:
 3792 015a 63686563 		.ascii	"checksum_Privileged\000"
 3792      6B73756D 
 3792      5F507269 
 3792      76696C65 
 3792      67656400 
 3793              	.LASF0:
 3794 016e 7369676E 		.ascii	"signed char\000"
 3794      65642063 
 3794      68617200 
 3795              	.LASF11:
 3796 017a 666C6F61 		.ascii	"float\000"
 3796      7400
 3797              	.LASF59:
 3798 0180 70726F74 		.ascii	"protectionData\000"
 3798      65637469 
 3798      6F6E4461 
 3798      746100
 3799              	.LASF39:
 3800 018f 56657269 		.ascii	"VerifySiliconId\000"
 3800      66795369 
 3800      6C69636F 
 3800      6E496400 
 3801              	.LASF23:
 3802 019f 63686970 		.ascii	"chipProtData\000"
 3802      50726F74 
 3802      44617461 
 3802      00
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 94


 3803              	.LASF19:
 3804 01ac 74696D65 		.ascii	"time_elapsed\000"
 3804      5F656C61 
 3804      70736564 
 3804      00
 3805              	.LASF74:
 3806 01b9 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 3806      4320342E 
 3806      392E3320 
 3806      32303135 
 3806      30333033 
 3807 01ec 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 3807      20726576 
 3807      6973696F 
 3807      6E203232 
 3807      31323230 
 3808 021f 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 3808      66756E63 
 3808      74696F6E 
 3808      2D736563 
 3808      74696F6E 
 3809              	.LASF58:
 3810 0247 56657269 		.ascii	"VerifyProtectionSettings\000"
 3810      66795072 
 3810      6F746563 
 3810      74696F6E 
 3810      53657474 
 3811              	.LASF15:
 3812 0260 4F50454E 		.ascii	"OPEN_XXX\000"
 3812      5F585858 
 3812      00
 3813              	.LASF71:
 3814 0269 72657375 		.ascii	"result\000"
 3814      6C7400
 3815              	.LASF61:
 3816 0270 726F7750 		.ascii	"rowProtectionFlashData\000"
 3816      726F7465 
 3816      6374696F 
 3816      6E466C61 
 3816      73684461 
 3817              	.LASF64:
 3818 0287 63686970 		.ascii	"chip_Checksum\000"
 3818      5F436865 
 3818      636B7375 
 3818      6D00
 3819              	.LASF53:
 3820 0295 63686970 		.ascii	"chipData\000"
 3820      44617461 
 3820      00
 3821              	.LASF76:
 3822 029e 5C5C4745 		.ascii	"\\\\GEORGE-OFFICE2\\Users\\George\\Box Sync\\Backbo"
 3822      4F524745 
 3822      2D4F4646 
 3822      49434532 
 3822      5C557365 
 3823 02cb 6E655C44 		.ascii	"ne\\Design\\Testing\\TestStation\\Software\\HSSP\\A"
 3823      65736967 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 95


 3823      6E5C5465 
 3823      7374696E 
 3823      675C5465 
 3824 02f8 4E383438 		.ascii	"N84858\\A_Hssp_Programmer.cydsn\000"
 3824      35385C41 
 3824      5F487373 
 3824      705F5072 
 3824      6F677261 
 3825              	.LASF51:
 3826 0317 666C6173 		.ascii	"flashData\000"
 3826      68446174 
 3826      6100
 3827              	.LASF1:
 3828 0321 756E7369 		.ascii	"unsigned char\000"
 3828      676E6564 
 3828      20636861 
 3828      7200
 3829              	.LASF45:
 3830 032f 52656164 		.ascii	"ReadSromStatus\000"
 3830      53726F6D 
 3830      53746174 
 3830      757300
 3831              	.LASF37:
 3832 033e 746F7461 		.ascii	"total_packet_count\000"
 3832      6C5F7061 
 3832      636B6574 
 3832      5F636F75 
 3832      6E7400
 3833              	.LASF56:
 3834 0351 726F7750 		.ascii	"rowProtectionByteSize\000"
 3834      726F7465 
 3834      6374696F 
 3834      6E427974 
 3834      6553697A 
 3835              	.LASF50:
 3836 0367 56657269 		.ascii	"VerifyFlash\000"
 3836      6679466C 
 3836      61736800 
 3837              	.LASF7:
 3838 0373 6C6F6E67 		.ascii	"long long unsigned int\000"
 3838      206C6F6E 
 3838      6720756E 
 3838      7369676E 
 3838      65642069 
 3839              	.LASF46:
 3840 038a 43686563 		.ascii	"ChecksumPrivileged\000"
 3840      6B73756D 
 3840      50726976 
 3840      696C6567 
 3840      656400
 3841              	.LASF8:
 3842 039d 756E7369 		.ascii	"unsigned int\000"
 3842      676E6564 
 3842      20696E74 
 3842      00
 3843              	.LASF21:
 3844 03aa 506F6C6C 		.ascii	"PollSromStatus\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 96


 3844      53726F6D 
 3844      53746174 
 3844      757300
 3845              	.LASF70:
 3846 03b9 73746174 		.ascii	"statusCode\000"
 3846      7573436F 
 3846      646500
 3847              	.LASF3:
 3848 03c4 73686F72 		.ascii	"short unsigned int\000"
 3848      7420756E 
 3848      7369676E 
 3848      65642069 
 3848      6E7400
 3849              	.LASF38:
 3850 03d7 73746174 		.ascii	"status\000"
 3850      757300
 3851              	.LASF34:
 3852 03de 63686563 		.ascii	"checksum_chip\000"
 3852      6B73756D 
 3852      5F636869 
 3852      7000
 3853              	.LASF13:
 3854 03ec 63686172 		.ascii	"char\000"
 3854      00
 3855              	.LASF62:
 3856 03f1 56657269 		.ascii	"VerifyChecksum\000"
 3856      66794368 
 3856      65636B73 
 3856      756D00
 3857              	.LASF4:
 3858 0400 6C6F6E67 		.ascii	"long int\000"
 3858      20696E74 
 3858      00
 3859              	.LASF26:
 3860 0409 4C6F6164 		.ascii	"LoadLatch\000"
 3860      4C617463 
 3860      6800
 3861              	.LASF10:
 3862 0413 696E7433 		.ascii	"int32_t\000"
 3862      325F7400 
 3863              	.LASF63:
 3864 041b 63686563 		.ascii	"checksum_All\000"
 3864      6B73756D 
 3864      5F416C6C 
 3864      00
 3865              	.LASF73:
 3866 0428 666C6F77 		.ascii	"flow\000"
 3866      00
 3867              	.LASF78:
 3868 042d 53657449 		.ascii	"SetIMO48MHz\000"
 3868      4D4F3438 
 3868      4D487A00 
 3869              	.LASF27:
 3870 0439 61727261 		.ascii	"arrayID\000"
 3870      79494400 
 3871              	.LASF5:
 3872 0441 6C6F6E67 		.ascii	"long unsigned int\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 97


 3872      20756E73 
 3872      69676E65 
 3872      6420696E 
 3872      7400
 3873              	.LASF31:
 3874 0453 43686563 		.ascii	"ChecksumAPI\000"
 3874      6B73756D 
 3874      41504900 
 3875              	.LASF12:
 3876 045f 646F7562 		.ascii	"double\000"
 3876      6C6500
 3877              	.LASF79:
 3878 0466 45786974 		.ascii	"ExitProgrammingMode\000"
 3878      50726F67 
 3878      72616D6D 
 3878      696E674D 
 3878      6F646500 
 3879              	.LASF25:
 3880 047a 63686970 		.ascii	"chipProtectionData_Hex\000"
 3880      50726F74 
 3880      65637469 
 3880      6F6E4461 
 3880      74615F48 
 3881              	.LASF49:
 3882 0491 726F7743 		.ascii	"rowCount\000"
 3882      6F756E74 
 3882      00
 3883              	.LASF9:
 3884 049a 5F5F696E 		.ascii	"__int32_t\000"
 3884      7433325F 
 3884      7400
 3885              	.LASF16:
 3886 04a4 56495247 		.ascii	"VIRGIN_OPEN\000"
 3886      494E5F4F 
 3886      50454E00 
 3887              	.LASF77:
 3888 04b0 5472616E 		.ascii	"Transition_mode\000"
 3888      73697469 
 3888      6F6E5F6D 
 3888      6F646500 
 3889              	.LASF17:
 3890 04c0 50524F54 		.ascii	"PROT_XXX\000"
 3890      5F585858 
 3890      00
 3891              	.LASF57:
 3892 04c9 726F7750 		.ascii	"rowProtectionData\000"
 3892      726F7465 
 3892      6374696F 
 3892      6E446174 
 3892      6100
 3893              	.LASF41:
 3894 04db 68657853 		.ascii	"hexSiliconId\000"
 3894      696C6963 
 3894      6F6E4964 
 3894      00
 3895              	.LASF22:
 3896 04e8 47657443 		.ascii	"GetChipProtectionVal\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\ccZxxnsR.s 			page 98


 3896      68697050 
 3896      726F7465 
 3896      6374696F 
 3896      6E56616C 
 3897              	.LASF67:
 3898 04fd 7377645F 		.ascii	"swd_PacketAck\000"
 3898      5061636B 
 3898      65744163 
 3898      6B00
 3899              	.LASF55:
 3900 050b 61727261 		.ascii	"arrayMax\000"
 3900      794D6178 
 3900      00
 3901              	.LASF66:
 3902 0514 52656164 		.ascii	"ReadHsspErrorStatus\000"
 3902      48737370 
 3902      4572726F 
 3902      72537461 
 3902      74757300 
 3903              	.LASF68:
 3904 0528 49544D5F 		.ascii	"ITM_RxBuffer\000"
 3904      52784275 
 3904      66666572 
 3904      00
 3905              	.LASF48:
 3906 0535 6E756D4F 		.ascii	"numOfFlashRows\000"
 3906      66466C61 
 3906      7368526F 
 3906      777300
 3907              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
