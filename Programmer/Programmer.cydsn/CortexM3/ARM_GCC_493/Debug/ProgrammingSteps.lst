ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ProgrammingSteps.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	checksum_Privileged
  19              		.bss
  20              		.align	2
  21              		.type	checksum_Privileged, %object
  22              		.size	checksum_Privileged, 4
  23              	checksum_Privileged:
  24 0000 00000000 		.space	4
  25              		.global	statusCode
  26              		.align	2
  27              		.type	statusCode, %object
  28              		.size	statusCode, 4
  29              	statusCode:
  30 0004 00000000 		.space	4
  31              		.global	result
  32              		.type	result, %object
  33              		.size	result, 1
  34              	result:
  35 0008 00       		.space	1
  36              		.global	chipProtectionData_Chip
  37              		.type	chipProtectionData_Chip, %object
  38              		.size	chipProtectionData_Chip, 1
  39              	chipProtectionData_Chip:
  40 0009 00       		.space	1
  41              		.comm	flow,1,1
  42 000a 0000     		.section	.text.PollSromStatus,"ax",%progbits
  43              		.align	2
  44              		.global	PollSromStatus
  45              		.thumb
  46              		.thumb_func
  47              		.type	PollSromStatus, %function
  48              	PollSromStatus:
  49              	.LFB63:
  50              		.file 1 "ProgrammingSteps.c"
   1:ProgrammingSteps.c **** /******************************************************************************
   2:ProgrammingSteps.c **** * File Name: ProgrammingSteps.c
   3:ProgrammingSteps.c **** * Version 1.0
   4:ProgrammingSteps.c **** *
   5:ProgrammingSteps.c **** * Description:
   6:ProgrammingSteps.c **** *  This file provides the source code for the high level Programming functions 
   7:ProgrammingSteps.c **** *  used by the main code to program target PSoC 4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 2


   8:ProgrammingSteps.c **** *
   9:ProgrammingSteps.c **** * Owner:
  10:ProgrammingSteps.c **** *	Tushar Rastogi, Application Engineer (tusr@cypress.com)
  11:ProgrammingSteps.c **** *
  12:ProgrammingSteps.c **** * Related Document:
  13:ProgrammingSteps.c **** *	AN84858 - PSoC 4 Programming using an External Microcontroller (HSSP)
  14:ProgrammingSteps.c **** *
  15:ProgrammingSteps.c **** * Hardware Dependency:
  16:ProgrammingSteps.c **** *   PSoC 5LP Development Kit - CY8CKIT-050
  17:ProgrammingSteps.c **** *
  18:ProgrammingSteps.c **** * Code Tested With:
  19:ProgrammingSteps.c **** *	PSoC Creator 3.2
  20:ProgrammingSteps.c **** *	ARM GCC 4.8.4
  21:ProgrammingSteps.c **** *	CY8CKIT-050
  22:ProgrammingSteps.c **** *
  23:ProgrammingSteps.c **** *******************************************************************************
  24:ProgrammingSteps.c **** * Copyright (2015), Cypress Semiconductor Corporation.
  25:ProgrammingSteps.c **** *******************************************************************************
  26:ProgrammingSteps.c **** * This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  27:ProgrammingSteps.c **** * protected by and subject to worldwide patent protection (United States and
  28:ProgrammingSteps.c **** * foreign), United States copyright laws and international treaty provisions.
  29:ProgrammingSteps.c **** * Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
  30:ProgrammingSteps.c **** * license to copy, use, modify, create derivative works of, and compile the
  31:ProgrammingSteps.c **** * Cypress Source Code and derivative works for the sole purpose of creating
  32:ProgrammingSteps.c **** * custom software in support of licensee product to be used only in conjunction
  33:ProgrammingSteps.c **** * with a Cypress integrated circuit as specified in the applicable agreement.
  34:ProgrammingSteps.c **** * Any reproduction, modification, translation, compilation, or representation
  35:ProgrammingSteps.c **** * of this software except as specified above is prohibited without the express
  36:ProgrammingSteps.c **** * written permission of Cypress.
  37:ProgrammingSteps.c **** *
  38:ProgrammingSteps.c **** * Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
  39:ProgrammingSteps.c **** * REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  40:ProgrammingSteps.c **** * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  41:ProgrammingSteps.c **** * Cypress reserves the right to make changes without further notice to the
  42:ProgrammingSteps.c **** * materials described herein. Cypress does not assume any liability arising out
  43:ProgrammingSteps.c **** * of the application or use of any product or circuit described herein. Cypress
  44:ProgrammingSteps.c **** * does not authorize its products for use as critical components in life-support
  45:ProgrammingSteps.c **** * systems where a malfunction or failure may reasonably be expected to result in
  46:ProgrammingSteps.c **** * significant injury to the user. The inclusion of Cypress' product in a life-
  47:ProgrammingSteps.c **** * support systems application implies that the manufacturer assumes all risk of
  48:ProgrammingSteps.c **** * such use and in doing so indemnifies Cypress against all charges. Use may be
  49:ProgrammingSteps.c **** * limited by and subject to the applicable Cypress software license agreement.
  50:ProgrammingSteps.c **** ******************************************************************************/
  51:ProgrammingSteps.c **** 
  52:ProgrammingSteps.c **** /******************************************************************************
  53:ProgrammingSteps.c **** *   Header file Inclusion
  54:ProgrammingSteps.c **** ******************************************************************************/
  55:ProgrammingSteps.c **** #include "ProgrammingSteps.h"
  56:ProgrammingSteps.c **** #include "SWD_PhysicalLayer.h"
  57:ProgrammingSteps.c **** #include "SWD_UpperPacketLayer.h"
  58:ProgrammingSteps.c **** #include "SWD_PacketLayer.h"
  59:ProgrammingSteps.c **** #include "DataFetch.h"
  60:ProgrammingSteps.c **** #include "Timeout.h"
  61:ProgrammingSteps.c **** #include "project.h"
  62:ProgrammingSteps.c **** 
  63:ProgrammingSteps.c **** /******************************************************************************
  64:ProgrammingSteps.c **** *   Global Variable definitions
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 3


  65:ProgrammingSteps.c **** ******************************************************************************/
  66:ProgrammingSteps.c **** unsigned long checksum_Privileged 		= 0;
  67:ProgrammingSteps.c **** unsigned long statusCode 				= 0;
  68:ProgrammingSteps.c **** 
  69:ProgrammingSteps.c **** unsigned char result 					= 0;
  70:ProgrammingSteps.c **** unsigned char chipProtectionData_Chip	= 0;
  71:ProgrammingSteps.c **** 
  72:ProgrammingSteps.c **** enum Transition_mode {OPEN_XXX, VIRGIN_OPEN, PROT_XXX, WRONG_TRANSITION } flow;
  73:ProgrammingSteps.c **** 
  74:ProgrammingSteps.c **** /******************************************************************************
  75:ProgrammingSteps.c **** *   Function Definitions
  76:ProgrammingSteps.c **** ******************************************************************************/
  77:ProgrammingSteps.c **** 
  78:ProgrammingSteps.c **** 
  79:ProgrammingSteps.c **** /******************************************************************************
  80:ProgrammingSteps.c **** * Function Name: PollSromStatus
  81:ProgrammingSteps.c **** *******************************************************************************
  82:ProgrammingSteps.c **** * Summary:
  83:ProgrammingSteps.c **** *  Polls the SROM_SYSREQ_BIT and SROM_PRIVILEGED_BIT in the CPUSS_SYSREQ 
  84:ProgrammingSteps.c **** *  register till it is reset or a timeout condition occurred, whichever is 
  85:ProgrammingSteps.c **** *  earlier. For a SROM polling timeout error, the timeout error status bit is 
  86:ProgrammingSteps.c **** *  set in swd_PacketAck variable and CPUSS_SYSARG register is read to get the 
  87:ProgrammingSteps.c **** *  error status code. If timeout does not happen, the CPUSS_SYSARG register is 
  88:ProgrammingSteps.c **** *  read to determine if the task executed successfully.
  89:ProgrammingSteps.c **** *
  90:ProgrammingSteps.c **** * Parameters:
  91:ProgrammingSteps.c **** *  None.
  92:ProgrammingSteps.c **** *
  93:ProgrammingSteps.c **** * Return:
  94:ProgrammingSteps.c **** *  SUCCESS - SROM executed the task successfully
  95:ProgrammingSteps.c **** *  FAILURE - SROM task is not executed successfully and a timeout error occured.
  96:ProgrammingSteps.c **** *            The failure code is stored in the statusCode global variable.
  97:ProgrammingSteps.c **** *
  98:ProgrammingSteps.c **** * Note:
  99:ProgrammingSteps.c **** *  This function is called after non volatile memory operations like Read,  
 100:ProgrammingSteps.c **** *  Write of Flash, to check if SROM task has been executed which is indicated
 101:ProgrammingSteps.c **** *  by SUCCESS. The status is read from the CPUSS_SYSARG register.
 102:ProgrammingSteps.c **** *
 103:ProgrammingSteps.c **** ******************************************************************************/
 104:ProgrammingSteps.c **** unsigned char PollSromStatus(void)
 105:ProgrammingSteps.c **** {
  51              		.loc 1 105 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 8
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55 0000 80B5     		push	{r7, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 82B0     		sub	sp, sp, #8
  60              		.cfi_def_cfa_offset 16
  61 0004 00AF     		add	r7, sp, #0
  62              		.cfi_def_cfa_register 7
 106:ProgrammingSteps.c ****     unsigned long time_elapsed = 0;
  63              		.loc 1 106 0
  64 0006 0023     		movs	r3, #0
  65 0008 7B60     		str	r3, [r7, #4]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 4


  66              	.L3:
 107:ProgrammingSteps.c ****     
 108:ProgrammingSteps.c ****     do
 109:ProgrammingSteps.c ****     {
 110:ProgrammingSteps.c **** 	    /* Read CPUSS_SYSREQ register and check if SROM_SYSREQ_BIT and 
 111:ProgrammingSteps.c **** 		SROM_PRIVILEGED_BIT are reset to 0 */
 112:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSREQ, &statusCode);
  67              		.loc 1 112 0 discriminator 2
  68 000a 2048     		ldr	r0, .L7
  69 000c 2049     		ldr	r1, .L7+4
  70 000e FFF7FEFF 		bl	Read_IO
 113:ProgrammingSteps.c **** 		
 114:ProgrammingSteps.c **** 		statusCode &= (SROM_SYSREQ_BIT | SROM_PRIVILEGED_BIT);
  71              		.loc 1 114 0 discriminator 2
  72 0012 1F4B     		ldr	r3, .L7+4
  73 0014 1B68     		ldr	r3, [r3]
  74 0016 03F01043 		and	r3, r3, #-1879048192
  75 001a 1D4A     		ldr	r2, .L7+4
  76 001c 1360     		str	r3, [r2]
 115:ProgrammingSteps.c **** 	    
 116:ProgrammingSteps.c **** 		time_elapsed++;
  77              		.loc 1 116 0 discriminator 2
  78 001e 7B68     		ldr	r3, [r7, #4]
  79 0020 0133     		adds	r3, r3, #1
  80 0022 7B60     		str	r3, [r7, #4]
 117:ProgrammingSteps.c **** 		
 118:ProgrammingSteps.c ****     }while ((statusCode != 0) && (time_elapsed <= SROM_POLLING_TIMEOUT));
  81              		.loc 1 118 0 discriminator 2
  82 0024 1A4B     		ldr	r3, .L7+4
  83 0026 1B68     		ldr	r3, [r3]
  84 0028 002B     		cmp	r3, #0
  85 002a 04D0     		beq	.L2
  86              		.loc 1 118 0 is_stmt 0 discriminator 1
  87 002c 7B68     		ldr	r3, [r7, #4]
  88 002e 42F6B002 		movw	r2, #10416
  89 0032 9342     		cmp	r3, r2
  90 0034 E9D9     		bls	.L3
  91              	.L2:
 119:ProgrammingSteps.c **** 	
 120:ProgrammingSteps.c **** 	/* If time exceeds the timeout value, set the SROM_TIMEOUT_ERROR bit in 
 121:ProgrammingSteps.c **** 	   swd_PacketAck */
 122:ProgrammingSteps.c ****     if (time_elapsed > SROM_POLLING_TIMEOUT )
  92              		.loc 1 122 0 is_stmt 1
  93 0036 7B68     		ldr	r3, [r7, #4]
  94 0038 42F6B002 		movw	r2, #10416
  95 003c 9342     		cmp	r3, r2
  96 003e 0CD9     		bls	.L4
 123:ProgrammingSteps.c ****     {
 124:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
  97              		.loc 1 124 0
  98 0040 144B     		ldr	r3, .L7+8
  99 0042 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 100 0044 43F02003 		orr	r3, r3, #32
 101 0048 DAB2     		uxtb	r2, r3
 102 004a 124B     		ldr	r3, .L7+8
 103 004c 1A70     		strb	r2, [r3]
 125:ProgrammingSteps.c **** 		
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 5


 126:ProgrammingSteps.c **** 		Read_IO (CPUSS_SYSARG, &statusCode);
 104              		.loc 1 126 0
 105 004e 1248     		ldr	r0, .L7+12
 106 0050 0F49     		ldr	r1, .L7+4
 107 0052 FFF7FEFF 		bl	Read_IO
 127:ProgrammingSteps.c **** 	    
 128:ProgrammingSteps.c **** 		return (FAILURE);
 108              		.loc 1 128 0
 109 0056 0023     		movs	r3, #0
 110 0058 14E0     		b	.L5
 111              	.L4:
 129:ProgrammingSteps.c ****     }
 130:ProgrammingSteps.c **** 	
 131:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to check if the SROM command executed 
 132:ProgrammingSteps.c **** 	successfully else set SROM_TIMEOUT_ERROR in swd_PacketAck */
 133:ProgrammingSteps.c **** 	Read_IO (CPUSS_SYSARG, &statusCode);
 112              		.loc 1 133 0
 113 005a 0F48     		ldr	r0, .L7+12
 114 005c 0C49     		ldr	r1, .L7+4
 115 005e FFF7FEFF 		bl	Read_IO
 134:ProgrammingSteps.c **** 	
 135:ProgrammingSteps.c **** 	if ((statusCode & SROM_STATUS_SUCCESS_MASK) != SROM_STATUS_SUCCEEDED)
 116              		.loc 1 135 0
 117 0062 0B4B     		ldr	r3, .L7+4
 118 0064 1B68     		ldr	r3, [r3]
 119 0066 03F07043 		and	r3, r3, #-268435456
 120 006a B3F1204F 		cmp	r3, #-1610612736
 121 006e 08D0     		beq	.L6
 136:ProgrammingSteps.c **** 	{
 137:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | SROM_TIMEOUT_ERROR;
 122              		.loc 1 137 0
 123 0070 084B     		ldr	r3, .L7+8
 124 0072 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 125 0074 43F02003 		orr	r3, r3, #32
 126 0078 DAB2     		uxtb	r2, r3
 127 007a 064B     		ldr	r3, .L7+8
 128 007c 1A70     		strb	r2, [r3]
 138:ProgrammingSteps.c **** 		
 139:ProgrammingSteps.c **** 		return (FAILURE);
 129              		.loc 1 139 0
 130 007e 0023     		movs	r3, #0
 131 0080 00E0     		b	.L5
 132              	.L6:
 140:ProgrammingSteps.c ****     }
 141:ProgrammingSteps.c **** 	else
 142:ProgrammingSteps.c **** 	    return (SUCCESS);
 133              		.loc 1 142 0
 134 0082 0123     		movs	r3, #1
 135              	.L5:
 143:ProgrammingSteps.c **** 
 144:ProgrammingSteps.c **** }
 136              		.loc 1 144 0
 137 0084 1846     		mov	r0, r3
 138 0086 0837     		adds	r7, r7, #8
 139              		.cfi_def_cfa_offset 8
 140 0088 BD46     		mov	sp, r7
 141              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 6


 142              		@ sp needed
 143 008a 80BD     		pop	{r7, pc}
 144              	.L8:
 145              		.align	2
 146              	.L7:
 147 008c 04001040 		.word	1074790404
 148 0090 00000000 		.word	statusCode
 149 0094 00000000 		.word	swd_PacketAck
 150 0098 08001040 		.word	1074790408
 151              		.cfi_endproc
 152              	.LFE63:
 153              		.size	PollSromStatus, .-PollSromStatus
 154              		.section	.text.ReadSromStatus,"ax",%progbits
 155              		.align	2
 156              		.global	ReadSromStatus
 157              		.thumb
 158              		.thumb_func
 159              		.type	ReadSromStatus, %function
 160              	ReadSromStatus:
 161              	.LFB64:
 145:ProgrammingSteps.c **** #if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY)
 146:ProgrammingSteps.c **** /******************************************************************************
 147:ProgrammingSteps.c **** * Function Name: SetIMO48MHz
 148:ProgrammingSteps.c **** *******************************************************************************
 149:ProgrammingSteps.c **** * Summary:
 150:ProgrammingSteps.c **** * Set IMO to 48 MHz 
 151:ProgrammingSteps.c **** *
 152:ProgrammingSteps.c **** * Parameters:
 153:ProgrammingSteps.c **** *  None.
 154:ProgrammingSteps.c **** *
 155:ProgrammingSteps.c **** * Return:
 156:ProgrammingSteps.c **** *  None
 157:ProgrammingSteps.c **** *
 158:ProgrammingSteps.c **** * Note:
 159:ProgrammingSteps.c **** *  This function is required to be called before any flash operation.
 160:ProgrammingSteps.c **** *  This function sets the IMO to 48 MHz before flash write/erase operations
 161:ProgrammingSteps.c **** *  and is part of the device acquire routine.
 162:ProgrammingSteps.c **** *
 163:ProgrammingSteps.c **** ******************************************************************************/
 164:ProgrammingSteps.c **** void SetIMO48MHz(void)
 165:ProgrammingSteps.c **** {    
 166:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 167:ProgrammingSteps.c **** 	
 168:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 169:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 170:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_SET_IMO_48MHZ) << 8));
 171:ProgrammingSteps.c **** 	
 172:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 173:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 174:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_SET_IMO_48MHZ);
 175:ProgrammingSteps.c **** }
 176:ProgrammingSteps.c **** #endif
 177:ProgrammingSteps.c **** /******************************************************************************
 178:ProgrammingSteps.c **** * Function Name: ReadSromStatus
 179:ProgrammingSteps.c **** *******************************************************************************
 180:ProgrammingSteps.c **** *
 181:ProgrammingSteps.c **** * Summary:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 7


 182:ProgrammingSteps.c **** *  It reads the StatusCode global variable and returns LSB of this long variable
 183:ProgrammingSteps.c **** *  to main.c.
 184:ProgrammingSteps.c **** *
 185:ProgrammingSteps.c **** * Parameters:
 186:ProgrammingSteps.c **** *  None.
 187:ProgrammingSteps.c **** *
 188:ProgrammingSteps.c **** * Return:
 189:ProgrammingSteps.c **** * LSB of statusCode - LSB of statusCode global variable contains the error code
 190:ProgrammingSteps.c **** *
 191:ProgrammingSteps.c **** * Note:
 192:ProgrammingSteps.c **** * This function is called from main.c when SROM_TIMEOUT_ERROR bit is set in the
 193:ProgrammingSteps.c **** * swd_PacketAck. 
 194:ProgrammingSteps.c **** *
 195:ProgrammingSteps.c **** ******************************************************************************/
 196:ProgrammingSteps.c **** 
 197:ProgrammingSteps.c **** unsigned char ReadSromStatus(void)
 198:ProgrammingSteps.c **** {
 162              		.loc 1 198 0
 163              		.cfi_startproc
 164              		@ args = 0, pretend = 0, frame = 0
 165              		@ frame_needed = 1, uses_anonymous_args = 0
 166              		@ link register save eliminated.
 167 0000 80B4     		push	{r7}
 168              		.cfi_def_cfa_offset 4
 169              		.cfi_offset 7, -4
 170 0002 00AF     		add	r7, sp, #0
 171              		.cfi_def_cfa_register 7
 199:ProgrammingSteps.c **** 	return((unsigned char)statusCode);
 172              		.loc 1 199 0
 173 0004 034B     		ldr	r3, .L11
 174 0006 1B68     		ldr	r3, [r3]
 175 0008 DBB2     		uxtb	r3, r3
 200:ProgrammingSteps.c **** }
 176              		.loc 1 200 0
 177 000a 1846     		mov	r0, r3
 178 000c BD46     		mov	sp, r7
 179              		.cfi_def_cfa_register 13
 180              		@ sp needed
 181 000e 5DF8047B 		ldr	r7, [sp], #4
 182              		.cfi_restore 7
 183              		.cfi_def_cfa_offset 0
 184 0012 7047     		bx	lr
 185              	.L12:
 186              		.align	2
 187              	.L11:
 188 0014 00000000 		.word	statusCode
 189              		.cfi_endproc
 190              	.LFE64:
 191              		.size	ReadSromStatus, .-ReadSromStatus
 192              		.section	.text.GetChipProtectionVal,"ax",%progbits
 193              		.align	2
 194              		.global	GetChipProtectionVal
 195              		.thumb
 196              		.thumb_func
 197              		.type	GetChipProtectionVal, %function
 198              	GetChipProtectionVal:
 199              	.LFB65:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 8


 201:ProgrammingSteps.c **** 
 202:ProgrammingSteps.c **** /******************************************************************************
 203:ProgrammingSteps.c **** * Function Name: GetChipProtectionVal
 204:ProgrammingSteps.c **** *******************************************************************************
 205:ProgrammingSteps.c **** * Summary:
 206:ProgrammingSteps.c **** *  This sub-routine is used to read the Chip Protection Setting by using SROM 
 207:ProgrammingSteps.c **** *  System Calls. System call to read Silicon Id returns Chip protection settings
 208:ProgrammingSteps.c **** *  in the CPUSS_SYSREQ register. The location of the data is bit [15:12] in the
 209:ProgrammingSteps.c **** *  32-bit register.
 210:ProgrammingSteps.c **** *
 211:ProgrammingSteps.c **** * Parameters:
 212:ProgrammingSteps.c **** *  None.
 213:ProgrammingSteps.c **** *
 214:ProgrammingSteps.c **** * Return:
 215:ProgrammingSteps.c **** *  chipProtectionData_Chip - 1 byte chip protection setting read from the chip
 216:ProgrammingSteps.c **** *
 217:ProgrammingSteps.c **** * Note:
 218:ProgrammingSteps.c **** * This function is called in the "Step 3. Erase All Flash" to read the chip
 219:ProgrammingSteps.c **** * protection settings to take decision whether to move the protection state
 220:ProgrammingSteps.c **** *  to open and then erase the flash or directly erase the flash.
 221:ProgrammingSteps.c **** *
 222:ProgrammingSteps.c **** ******************************************************************************/
 223:ProgrammingSteps.c **** unsigned char GetChipProtectionVal(void)
 224:ProgrammingSteps.c **** {
 200              		.loc 1 224 0
 201              		.cfi_startproc
 202              		@ args = 0, pretend = 0, frame = 8
 203              		@ frame_needed = 1, uses_anonymous_args = 0
 204 0000 80B5     		push	{r7, lr}
 205              		.cfi_def_cfa_offset 8
 206              		.cfi_offset 7, -8
 207              		.cfi_offset 14, -4
 208 0002 82B0     		sub	sp, sp, #8
 209              		.cfi_def_cfa_offset 16
 210 0004 00AF     		add	r7, sp, #0
 211              		.cfi_def_cfa_register 7
 225:ProgrammingSteps.c **** 	unsigned long parameter1		= 0;
 212              		.loc 1 225 0
 213 0006 0023     		movs	r3, #0
 214 0008 7B60     		str	r3, [r7, #4]
 226:ProgrammingSteps.c **** 	unsigned long chipProtData 		= 0;
 215              		.loc 1 226 0
 216 000a 0023     		movs	r3, #0
 217 000c 3B60     		str	r3, [r7]
 227:ProgrammingSteps.c **** 	
 228:ProgrammingSteps.c **** 	/* Load the Parameter1 with the SROM command to read silicon ID */
 229:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
 218              		.loc 1 229 0
 219 000e 4DF2B633 		movw	r3, #54198
 220 0012 7B60     		str	r3, [r7, #4]
 230:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 231:ProgrammingSteps.c **** 	
 232:ProgrammingSteps.c **** 	/* Write the command to CPUSS_SYSARG register */
 233:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 221              		.loc 1 233 0
 222 0014 1A48     		ldr	r0, .L20
 223 0016 7968     		ldr	r1, [r7, #4]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 9


 224 0018 FFF7FEFF 		bl	Write_IO
 234:ProgrammingSteps.c ****     
 235:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 225              		.loc 1 235 0
 226 001c 194B     		ldr	r3, .L20+4
 227 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 228 0020 012B     		cmp	r3, #1
 229 0022 01D0     		beq	.L14
 236:ProgrammingSteps.c ****     {
 237:ProgrammingSteps.c ****         return(FAILURE);
 230              		.loc 1 237 0
 231 0024 0023     		movs	r3, #0
 232 0026 27E0     		b	.L19
 233              	.L14:
 238:ProgrammingSteps.c ****     }
 239:ProgrammingSteps.c **** 	
 240:ProgrammingSteps.c **** 	/* Request system call by writing to CPUSS_SYSREQ register */
 241:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 234              		.loc 1 241 0
 235 0028 1748     		ldr	r0, .L20+8
 236 002a 4FF00041 		mov	r1, #-2147483648
 237 002e FFF7FEFF 		bl	Write_IO
 242:ProgrammingSteps.c ****     
 243:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 238              		.loc 1 243 0
 239 0032 144B     		ldr	r3, .L20+4
 240 0034 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 241 0036 012B     		cmp	r3, #1
 242 0038 01D0     		beq	.L16
 244:ProgrammingSteps.c ****     {
 245:ProgrammingSteps.c ****         return(FAILURE);
 243              		.loc 1 245 0
 244 003a 0023     		movs	r3, #0
 245 003c 1CE0     		b	.L19
 246              	.L16:
 246:ProgrammingSteps.c ****     }
 247:ProgrammingSteps.c **** 	
 248:ProgrammingSteps.c **** 	/* Read status of the operation */
 249:ProgrammingSteps.c ****     result = PollSromStatus();
 247              		.loc 1 249 0
 248 003e FFF7FEFF 		bl	PollSromStatus
 249 0042 0346     		mov	r3, r0
 250 0044 1A46     		mov	r2, r3
 251 0046 114B     		ldr	r3, .L20+12
 252 0048 1A70     		strb	r2, [r3]
 250:ProgrammingSteps.c ****     
 251:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 253              		.loc 1 251 0
 254 004a 104B     		ldr	r3, .L20+12
 255 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 256 004e 012B     		cmp	r3, #1
 257 0050 01D0     		beq	.L17
 252:ProgrammingSteps.c ****     {
 253:ProgrammingSteps.c ****         return(FAILURE);
 258              		.loc 1 253 0
 259 0052 0023     		movs	r3, #0
 260 0054 10E0     		b	.L19
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 10


 261              	.L17:
 254:ProgrammingSteps.c ****     }
 255:ProgrammingSteps.c **** 	
 256:ProgrammingSteps.c **** 	/* Read CPUSS_SYSREQ register to get the current protection setting of the
 257:ProgrammingSteps.c **** 	   chip */
 258:ProgrammingSteps.c ****     Read_IO( CPUSS_SYSREQ, &chipProtData);
 262              		.loc 1 258 0
 263 0056 3B46     		mov	r3, r7
 264 0058 0B48     		ldr	r0, .L20+8
 265 005a 1946     		mov	r1, r3
 266 005c FFF7FEFF 		bl	Read_IO
 259:ProgrammingSteps.c ****     
 260:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 267              		.loc 1 260 0
 268 0060 084B     		ldr	r3, .L20+4
 269 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 270 0064 012B     		cmp	r3, #1
 271 0066 01D0     		beq	.L18
 261:ProgrammingSteps.c ****     {
 262:ProgrammingSteps.c ****         return(FAILURE);
 272              		.loc 1 262 0
 273 0068 0023     		movs	r3, #0
 274 006a 05E0     		b	.L19
 275              	.L18:
 263:ProgrammingSteps.c ****     }
 264:ProgrammingSteps.c **** 
 265:ProgrammingSteps.c ****     chipProtectionData_Chip = (unsigned char)(chipProtData >> 12);
 276              		.loc 1 265 0
 277 006c 3B68     		ldr	r3, [r7]
 278 006e 1B0B     		lsrs	r3, r3, #12
 279 0070 DAB2     		uxtb	r2, r3
 280 0072 074B     		ldr	r3, .L20+16
 281 0074 1A70     		strb	r2, [r3]
 266:ProgrammingSteps.c **** 	
 267:ProgrammingSteps.c **** 	return(SUCCESS);
 282              		.loc 1 267 0
 283 0076 0123     		movs	r3, #1
 284              	.L19:
 268:ProgrammingSteps.c **** }
 285              		.loc 1 268 0 discriminator 1
 286 0078 1846     		mov	r0, r3
 287 007a 0837     		adds	r7, r7, #8
 288              		.cfi_def_cfa_offset 8
 289 007c BD46     		mov	sp, r7
 290              		.cfi_def_cfa_register 13
 291              		@ sp needed
 292 007e 80BD     		pop	{r7, pc}
 293              	.L21:
 294              		.align	2
 295              	.L20:
 296 0080 08001040 		.word	1074790408
 297 0084 00000000 		.word	swd_PacketAck
 298 0088 04001040 		.word	1074790404
 299 008c 00000000 		.word	result
 300 0090 00000000 		.word	chipProtectionData_Chip
 301              		.cfi_endproc
 302              	.LFE65:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 11


 303              		.size	GetChipProtectionVal, .-GetChipProtectionVal
 304              		.section	.text.GetTransitionMode,"ax",%progbits
 305              		.align	2
 306              		.global	GetTransitionMode
 307              		.thumb
 308              		.thumb_func
 309              		.type	GetTransitionMode, %function
 310              	GetTransitionMode:
 311              	.LFB66:
 269:ProgrammingSteps.c **** 
 270:ProgrammingSteps.c **** /******************************************************************************
 271:ProgrammingSteps.c **** * Function Name: GetTransitionMode
 272:ProgrammingSteps.c **** *******************************************************************************
 273:ProgrammingSteps.c **** *
 274:ProgrammingSteps.c **** * Summary:
 275:ProgrammingSteps.c **** *  It reads the chipProtectionData_Chip global variable which contains the Chip
 276:ProgrammingSteps.c **** *  protection setting stored in the Chip and chipProtectionData_Hex from the 
 277:ProgrammingSteps.c **** *  hex file which contains the Chip protection setting stored in the HEX file. 
 278:ProgrammingSteps.c **** *  The function then validates if the two settings correspond to a valid
 279:ProgrammingSteps.c **** *  transition.
 280:ProgrammingSteps.c **** *
 281:ProgrammingSteps.c **** * Parameters:
 282:ProgrammingSteps.c **** *  None.
 283:ProgrammingSteps.c **** *
 284:ProgrammingSteps.c **** * Return:
 285:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the transition is valid.
 286:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the transition is invalid.
 287:ProgrammingSteps.c **** *  Stores the transition in the global enum flow.
 288:ProgrammingSteps.c **** *
 289:ProgrammingSteps.c **** * Note:
 290:ProgrammingSteps.c **** * This function is called in "Step 3. Erase All Flash" to take decision on
 291:ProgrammingSteps.c **** * basis of the global enum flow.
 292:ProgrammingSteps.c **** *
 293:ProgrammingSteps.c **** ******************************************************************************/
 294:ProgrammingSteps.c **** unsigned char GetTransitionMode(void)
 295:ProgrammingSteps.c **** {
 312              		.loc 1 295 0
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 8
 315              		@ frame_needed = 1, uses_anonymous_args = 0
 316 0000 80B5     		push	{r7, lr}
 317              		.cfi_def_cfa_offset 8
 318              		.cfi_offset 7, -8
 319              		.cfi_offset 14, -4
 320 0002 82B0     		sub	sp, sp, #8
 321              		.cfi_def_cfa_offset 16
 322 0004 00AF     		add	r7, sp, #0
 323              		.cfi_def_cfa_register 7
 296:ProgrammingSteps.c **** 	unsigned char chipProtectionData_Hex;
 297:ProgrammingSteps.c **** 	
 298:ProgrammingSteps.c **** 	/* Get the chip protection setting in the HEX file */
 299:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 324              		.loc 1 299 0
 325 0006 FB1D     		adds	r3, r7, #7
 326 0008 1846     		mov	r0, r3
 327 000a FFF7FEFF 		bl	HEX_ReadChipProtectionData
 300:ProgrammingSteps.c **** 	
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 12


 301:ProgrammingSteps.c **** 	/* enum variable flow stores the transition (current protection setting to 
 302:ProgrammingSteps.c **** 	   setting in hex file) of the chip */
 303:ProgrammingSteps.c **** 	flow = WRONG_TRANSITION;
 328              		.loc 1 303 0
 329 000e 224B     		ldr	r3, .L39
 330 0010 0322     		movs	r2, #3
 331 0012 1A70     		strb	r2, [r3]
 304:ProgrammingSteps.c **** 	
 305:ProgrammingSteps.c **** 	switch (chipProtectionData_Chip)
 332              		.loc 1 305 0
 333 0014 214B     		ldr	r3, .L39+4
 334 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 335 0018 012B     		cmp	r3, #1
 336 001a 0ED0     		beq	.L24
 337 001c 022B     		cmp	r3, #2
 338 001e 17D0     		beq	.L25
 339 0020 002B     		cmp	r3, #0
 340 0022 23D1     		bne	.L38
 306:ProgrammingSteps.c **** 	{
 307:ProgrammingSteps.c **** 		/* virgin to open protection setting is the only allowed transition */
 308:ProgrammingSteps.c **** 		case CHIP_PROT_VIRGIN:
 309:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_OPEN)
 341              		.loc 1 309 0
 342 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 343 0026 012B     		cmp	r3, #1
 344 0028 03D1     		bne	.L27
 310:ProgrammingSteps.c ****                 flow = VIRGIN_OPEN;
 345              		.loc 1 310 0
 346 002a 1B4B     		ldr	r3, .L39
 347 002c 0122     		movs	r2, #1
 348 002e 1A70     		strb	r2, [r3]
 311:ProgrammingSteps.c ****             else
 312:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 313:ProgrammingSteps.c ****             break;
 349              		.loc 1 313 0
 350 0030 20E0     		b	.L29
 351              	.L27:
 312:ProgrammingSteps.c ****             break;
 352              		.loc 1 312 0
 353 0032 194B     		ldr	r3, .L39
 354 0034 0322     		movs	r2, #3
 355 0036 1A70     		strb	r2, [r3]
 356              		.loc 1 313 0
 357 0038 1CE0     		b	.L29
 358              	.L24:
 314:ProgrammingSteps.c **** 		
 315:ProgrammingSteps.c **** 		/* All transitions from Open are allowed other than transition to virgin
 316:ProgrammingSteps.c **** 		   mode */
 317:ProgrammingSteps.c **** 		case CHIP_PROT_OPEN:
 318:ProgrammingSteps.c ****             if (chipProtectionData_Hex == CHIP_PROT_VIRGIN)
 359              		.loc 1 318 0
 360 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 361 003c 002B     		cmp	r3, #0
 362 003e 03D1     		bne	.L30
 319:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 363              		.loc 1 319 0
 364 0040 154B     		ldr	r3, .L39
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 13


 365 0042 0322     		movs	r2, #3
 366 0044 1A70     		strb	r2, [r3]
 320:ProgrammingSteps.c ****             else
 321:ProgrammingSteps.c ****                 flow = OPEN_XXX;
 322:ProgrammingSteps.c ****             break;
 367              		.loc 1 322 0
 368 0046 15E0     		b	.L29
 369              	.L30:
 321:ProgrammingSteps.c ****             break;
 370              		.loc 1 321 0
 371 0048 134B     		ldr	r3, .L39
 372 004a 0022     		movs	r2, #0
 373 004c 1A70     		strb	r2, [r3]
 374              		.loc 1 322 0
 375 004e 11E0     		b	.L29
 376              	.L25:
 323:ProgrammingSteps.c ****         
 324:ProgrammingSteps.c **** 		/* Protected to Protected and Protected to Open are the allowed
 325:ProgrammingSteps.c **** 		   transitions */
 326:ProgrammingSteps.c **** 		case CHIP_PROT_PROTECTED:
 327:ProgrammingSteps.c ****             if ((chipProtectionData_Hex == CHIP_PROT_OPEN) || (chipProtectionData_Hex == CHIP_PROT_
 377              		.loc 1 327 0
 378 0050 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 379 0052 012B     		cmp	r3, #1
 380 0054 02D0     		beq	.L32
 381              		.loc 1 327 0 is_stmt 0 discriminator 1
 382 0056 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 383 0058 022B     		cmp	r3, #2
 384 005a 03D1     		bne	.L33
 385              	.L32:
 328:ProgrammingSteps.c ****                 flow = PROT_XXX;
 386              		.loc 1 328 0 is_stmt 1
 387 005c 0E4B     		ldr	r3, .L39
 388 005e 0222     		movs	r2, #2
 389 0060 1A70     		strb	r2, [r3]
 329:ProgrammingSteps.c ****             else
 330:ProgrammingSteps.c ****                 flow = WRONG_TRANSITION;
 331:ProgrammingSteps.c ****             break;
 390              		.loc 1 331 0
 391 0062 07E0     		b	.L29
 392              	.L33:
 330:ProgrammingSteps.c ****             break;
 393              		.loc 1 330 0
 394 0064 0C4B     		ldr	r3, .L39
 395 0066 0322     		movs	r2, #3
 396 0068 1A70     		strb	r2, [r3]
 397              		.loc 1 331 0
 398 006a 03E0     		b	.L29
 399              	.L38:
 332:ProgrammingSteps.c ****         
 333:ProgrammingSteps.c **** 		default:
 334:ProgrammingSteps.c ****             flow = WRONG_TRANSITION;
 400              		.loc 1 334 0
 401 006c 0A4B     		ldr	r3, .L39
 402 006e 0322     		movs	r2, #3
 403 0070 1A70     		strb	r2, [r3]
 335:ProgrammingSteps.c ****             break;
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 14


 404              		.loc 1 335 0
 405 0072 00BF     		nop
 406              	.L29:
 336:ProgrammingSteps.c **** 	}
 337:ProgrammingSteps.c **** 	
 338:ProgrammingSteps.c **** 	/* Set TRANSITION_ERROR bit high in Swd_PacketAck to show wrong transition
 339:ProgrammingSteps.c **** 	   error */
 340:ProgrammingSteps.c **** 	if (flow == WRONG_TRANSITION)
 407              		.loc 1 340 0
 408 0074 084B     		ldr	r3, .L39
 409 0076 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 410 0078 032B     		cmp	r3, #3
 411 007a 08D1     		bne	.L35
 341:ProgrammingSteps.c **** 	{
 342:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | TRANSITION_ERROR;
 412              		.loc 1 342 0
 413 007c 084B     		ldr	r3, .L39+8
 414 007e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 415 0080 63F07F03 		orn	r3, r3, #127
 416 0084 DAB2     		uxtb	r2, r3
 417 0086 064B     		ldr	r3, .L39+8
 418 0088 1A70     		strb	r2, [r3]
 343:ProgrammingSteps.c **** 		return(FAILURE);
 419              		.loc 1 343 0
 420 008a 0023     		movs	r3, #0
 421 008c 00E0     		b	.L37
 422              	.L35:
 344:ProgrammingSteps.c **** 	}
 345:ProgrammingSteps.c **** 	return(SUCCESS);
 423              		.loc 1 345 0
 424 008e 0123     		movs	r3, #1
 425              	.L37:
 346:ProgrammingSteps.c **** }
 426              		.loc 1 346 0 discriminator 1
 427 0090 1846     		mov	r0, r3
 428 0092 0837     		adds	r7, r7, #8
 429              		.cfi_def_cfa_offset 8
 430 0094 BD46     		mov	sp, r7
 431              		.cfi_def_cfa_register 13
 432              		@ sp needed
 433 0096 80BD     		pop	{r7, pc}
 434              	.L40:
 435              		.align	2
 436              	.L39:
 437 0098 00000000 		.word	flow
 438 009c 00000000 		.word	chipProtectionData_Chip
 439 00a0 00000000 		.word	swd_PacketAck
 440              		.cfi_endproc
 441              	.LFE66:
 442              		.size	GetTransitionMode, .-GetTransitionMode
 443              		.section	.text.LoadLatch,"ax",%progbits
 444              		.align	2
 445              		.global	LoadLatch
 446              		.thumb
 447              		.thumb_func
 448              		.type	LoadLatch, %function
 449              	LoadLatch:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 15


 450              	.LFB67:
 347:ProgrammingSteps.c **** 
 348:ProgrammingSteps.c **** /******************************************************************************
 349:ProgrammingSteps.c **** * Function Name: LoadLatch
 350:ProgrammingSteps.c **** *******************************************************************************
 351:ProgrammingSteps.c **** *
 352:ProgrammingSteps.c **** * Summary:
 353:ProgrammingSteps.c **** *  This function loads the page latch buffer with data to be programmed in to a
 354:ProgrammingSteps.c **** *  row of flash (or flash protection area). Data is loaded into the page latch 
 355:ProgrammingSteps.c **** *  buffer starting at the location specified by the SRAM_PARAMS_BASE input parameter. 
 356:ProgrammingSteps.c **** *  Data loaded into the page latch buffer will remain until a program operation is 
 357:ProgrammingSteps.c **** *  performed, which clears the page latch contents.
 358:ProgrammingSteps.c **** *
 359:ProgrammingSteps.c **** * Parameters:
 360:ProgrammingSteps.c **** *  arrayID - Array Number of the flash
 361:ProgrammingSteps.c **** *  rowData - Array containing 128 bytes of programming data
 362:ProgrammingSteps.c **** *  rowByteSize - Number of bytes in the current row to be loaded using parameter2
 363:ProgrammingSteps.c **** *
 364:ProgrammingSteps.c **** * Return:
 365:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Data is successfully latched
 366:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Data is not latched successfully
 367:ProgrammingSteps.c **** *
 368:ProgrammingSteps.c **** * Note:
 369:ProgrammingSteps.c **** * This function is called in "Step 5. Program Flash" and 
 370:ProgrammingSteps.c **** * "Step 7. Program Protection Settings" to latch the programming data in SRAM.
 371:ProgrammingSteps.c **** *
 372:ProgrammingSteps.c **** ******************************************************************************/
 373:ProgrammingSteps.c **** unsigned char LoadLatch(unsigned char arrayID, unsigned char * rowData, unsigned short rowByteSize)
 374:ProgrammingSteps.c **** {
 451              		.loc 1 374 0
 452              		.cfi_startproc
 453              		@ args = 0, pretend = 0, frame = 24
 454              		@ frame_needed = 1, uses_anonymous_args = 0
 455 0000 80B5     		push	{r7, lr}
 456              		.cfi_def_cfa_offset 8
 457              		.cfi_offset 7, -8
 458              		.cfi_offset 14, -4
 459 0002 86B0     		sub	sp, sp, #24
 460              		.cfi_def_cfa_offset 32
 461 0004 00AF     		add	r7, sp, #0
 462              		.cfi_def_cfa_register 7
 463 0006 0346     		mov	r3, r0
 464 0008 3960     		str	r1, [r7]
 465 000a FB71     		strb	r3, [r7, #7]
 466 000c 1346     		mov	r3, r2	@ movhi
 467 000e BB80     		strh	r3, [r7, #4]	@ movhi
 375:ProgrammingSteps.c **** 		unsigned long parameter1 = 0;
 468              		.loc 1 375 0
 469 0010 0023     		movs	r3, #0
 470 0012 3B61     		str	r3, [r7, #16]
 376:ProgrammingSteps.c **** 		unsigned long parameter2 = 0;
 471              		.loc 1 376 0
 472 0014 0023     		movs	r3, #0
 473 0016 FB60     		str	r3, [r7, #12]
 377:ProgrammingSteps.c **** 		unsigned short i = 0;
 474              		.loc 1 377 0
 475 0018 0023     		movs	r3, #0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 16


 476 001a FB82     		strh	r3, [r7, #22]	@ movhi
 378:ProgrammingSteps.c **** 		
 379:ProgrammingSteps.c **** 		/* Load parameter1 with the SROM command to load the page latch buffer
 380:ProgrammingSteps.c **** 		   with programming data */
 381:ProgrammingSteps.c **** 		parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 382:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 383:ProgrammingSteps.c **** 					(0x00 << 16) + ((unsigned long)arrayID << 24);
 477              		.loc 1 383 0
 478 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 479 001e 1B06     		lsls	r3, r3, #24
 381:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_LOAD_LATCH) << 8) + //
 480              		.loc 1 381 0
 481 0020 03F55743 		add	r3, r3, #55040
 482 0024 B633     		adds	r3, r3, #182
 483 0026 3B61     		str	r3, [r7, #16]
 384:ProgrammingSteps.c **** 		
 385:ProgrammingSteps.c **** 		/* Number of Bytes to load minus 1 */
 386:ProgrammingSteps.c **** 		parameter2 = (rowByteSize - 1);
 484              		.loc 1 386 0
 485 0028 BB88     		ldrh	r3, [r7, #4]
 486 002a 013B     		subs	r3, r3, #1
 487 002c FB60     		str	r3, [r7, #12]
 387:ProgrammingSteps.c **** 		
 388:ProgrammingSteps.c **** 		/* Write parameter1 in SRAM */
 389:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE + 0x00, parameter1);
 488              		.loc 1 389 0
 489 002e 3648     		ldr	r0, .L51
 490 0030 3969     		ldr	r1, [r7, #16]
 491 0032 FFF7FEFF 		bl	Write_IO
 390:ProgrammingSteps.c **** 		
 391:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 492              		.loc 1 391 0
 493 0036 354B     		ldr	r3, .L51+4
 494 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 495 003a 012B     		cmp	r3, #1
 496 003c 01D0     		beq	.L42
 392:ProgrammingSteps.c **** 	    {
 393:ProgrammingSteps.c **** 	        return (FAILURE);
 497              		.loc 1 393 0
 498 003e 0023     		movs	r3, #0
 499 0040 5DE0     		b	.L43
 500              	.L42:
 394:ProgrammingSteps.c **** 	    }
 395:ProgrammingSteps.c **** 	    
 396:ProgrammingSteps.c **** 		/* Write parameter2 in SRAM */
 397:ProgrammingSteps.c **** 		Write_IO(SRAM_PARAMS_BASE + 0x04, parameter2);
 501              		.loc 1 397 0
 502 0042 3348     		ldr	r0, .L51+8
 503 0044 F968     		ldr	r1, [r7, #12]
 504 0046 FFF7FEFF 		bl	Write_IO
 398:ProgrammingSteps.c **** 		
 399:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 505              		.loc 1 399 0
 506 004a 304B     		ldr	r3, .L51+4
 507 004c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 508 004e 012B     		cmp	r3, #1
 509 0050 01D0     		beq	.L44
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 17


 400:ProgrammingSteps.c **** 	    {
 401:ProgrammingSteps.c **** 	        return (FAILURE);
 510              		.loc 1 401 0
 511 0052 0023     		movs	r3, #0
 512 0054 53E0     		b	.L43
 513              	.L44:
 402:ProgrammingSteps.c **** 	    }
 403:ProgrammingSteps.c **** 		
 404:ProgrammingSteps.c **** 		/* Put row data into SRAM buffer */
 405:ProgrammingSteps.c **** 	    for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 514              		.loc 1 405 0
 515 0056 0023     		movs	r3, #0
 516 0058 FB82     		strh	r3, [r7, #22]	@ movhi
 517 005a 2CE0     		b	.L45
 518              	.L47:
 406:ProgrammingSteps.c **** 	    {
 407:ProgrammingSteps.c **** 	     	parameter1 = (rowData[i] << 0) + (rowData[i + 1] << 8) + (rowData[i + 2] << 16) + (rowData[i
 519              		.loc 1 407 0
 520 005c FB8A     		ldrh	r3, [r7, #22]
 521 005e 3A68     		ldr	r2, [r7]
 522 0060 1344     		add	r3, r3, r2
 523 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 524 0064 1946     		mov	r1, r3
 525 0066 FB8A     		ldrh	r3, [r7, #22]
 526 0068 0133     		adds	r3, r3, #1
 527 006a 3A68     		ldr	r2, [r7]
 528 006c 1344     		add	r3, r3, r2
 529 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 530 0070 1B02     		lsls	r3, r3, #8
 531 0072 CA18     		adds	r2, r1, r3
 532 0074 FB8A     		ldrh	r3, [r7, #22]
 533 0076 0233     		adds	r3, r3, #2
 534 0078 3968     		ldr	r1, [r7]
 535 007a 0B44     		add	r3, r3, r1
 536 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 537 007e 1B04     		lsls	r3, r3, #16
 538 0080 1A44     		add	r2, r2, r3
 539 0082 FB8A     		ldrh	r3, [r7, #22]
 540 0084 0333     		adds	r3, r3, #3
 541 0086 3968     		ldr	r1, [r7]
 542 0088 0B44     		add	r3, r3, r1
 543 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 544 008c 1B06     		lsls	r3, r3, #24
 545 008e 1344     		add	r3, r3, r2
 546 0090 3B61     		str	r3, [r7, #16]
 408:ProgrammingSteps.c **** 	        
 409:ProgrammingSteps.c **** 			/* Write parameter1 in SRAM */
 410:ProgrammingSteps.c **** 			Write_IO(SRAM_PARAMS_BASE + 0x08 + i, parameter1);
 547              		.loc 1 410 0
 548 0092 FB8A     		ldrh	r3, [r7, #22]
 549 0094 03F10053 		add	r3, r3, #536870912
 550 0098 03F58473 		add	r3, r3, #264
 551 009c 1846     		mov	r0, r3
 552 009e 3969     		ldr	r1, [r7, #16]
 553 00a0 FFF7FEFF 		bl	Write_IO
 411:ProgrammingSteps.c **** 			
 412:ProgrammingSteps.c **** 			if( swd_PacketAck != SWD_OK_ACK )
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 18


 554              		.loc 1 412 0
 555 00a4 194B     		ldr	r3, .L51+4
 556 00a6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 557 00a8 012B     		cmp	r3, #1
 558 00aa 01D0     		beq	.L46
 413:ProgrammingSteps.c ****     	    {
 414:ProgrammingSteps.c ****     	        return (FAILURE);
 559              		.loc 1 414 0
 560 00ac 0023     		movs	r3, #0
 561 00ae 26E0     		b	.L43
 562              	.L46:
 405:ProgrammingSteps.c **** 	    {
 563              		.loc 1 405 0 discriminator 2
 564 00b0 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 565 00b2 0433     		adds	r3, r3, #4
 566 00b4 FB82     		strh	r3, [r7, #22]	@ movhi
 567              	.L45:
 405:ProgrammingSteps.c **** 	    {
 568              		.loc 1 405 0 is_stmt 0 discriminator 1
 569 00b6 FB8A     		ldrh	r3, [r7, #22]
 570 00b8 FF2B     		cmp	r3, #255
 571 00ba CFD9     		bls	.L47
 415:ProgrammingSteps.c ****     	    }
 416:ProgrammingSteps.c **** 		}
 417:ProgrammingSteps.c **** 
 418:ProgrammingSteps.c **** 	    /*  Call "Load Latch" SROM API */
 419:ProgrammingSteps.c **** 		
 420:ProgrammingSteps.c **** 		/* Set location of parameters */
 421:ProgrammingSteps.c **** 	    Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 572              		.loc 1 421 0 is_stmt 1
 573 00bc 1548     		ldr	r0, .L51+12
 574 00be 1249     		ldr	r1, .L51
 575 00c0 FFF7FEFF 		bl	Write_IO
 422:ProgrammingSteps.c **** 		
 423:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 576              		.loc 1 423 0
 577 00c4 114B     		ldr	r3, .L51+4
 578 00c6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 579 00c8 012B     		cmp	r3, #1
 580 00ca 01D0     		beq	.L48
 424:ProgrammingSteps.c **** 	    {
 425:ProgrammingSteps.c **** 	        return (FAILURE);
 581              		.loc 1 425 0
 582 00cc 0023     		movs	r3, #0
 583 00ce 16E0     		b	.L43
 584              	.L48:
 426:ProgrammingSteps.c **** 	    }
 427:ProgrammingSteps.c **** 	    
 428:ProgrammingSteps.c **** 		/* Request SROM operation */
 429:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_LOAD_LATCH);
 585              		.loc 1 429 0
 586 00d0 1148     		ldr	r0, .L51+16
 587 00d2 1249     		ldr	r1, .L51+20
 588 00d4 FFF7FEFF 		bl	Write_IO
 430:ProgrammingSteps.c **** 		
 431:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 589              		.loc 1 431 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 19


 590 00d8 0C4B     		ldr	r3, .L51+4
 591 00da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 592 00dc 012B     		cmp	r3, #1
 593 00de 01D0     		beq	.L49
 432:ProgrammingSteps.c **** 	    {
 433:ProgrammingSteps.c **** 	        return (FAILURE);
 594              		.loc 1 433 0
 595 00e0 0023     		movs	r3, #0
 596 00e2 0CE0     		b	.L43
 597              	.L49:
 434:ProgrammingSteps.c **** 	    }
 435:ProgrammingSteps.c **** 	    
 436:ProgrammingSteps.c **** 		/* Read status of the operation */
 437:ProgrammingSteps.c **** 		result = PollSromStatus();
 598              		.loc 1 437 0
 599 00e4 FFF7FEFF 		bl	PollSromStatus
 600 00e8 0346     		mov	r3, r0
 601 00ea 1A46     		mov	r2, r3
 602 00ec 0C4B     		ldr	r3, .L51+24
 603 00ee 1A70     		strb	r2, [r3]
 438:ProgrammingSteps.c **** 	    
 439:ProgrammingSteps.c **** 		if ( result != SROM_SUCCESS )
 604              		.loc 1 439 0
 605 00f0 0B4B     		ldr	r3, .L51+24
 606 00f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 607 00f4 012B     		cmp	r3, #1
 608 00f6 01D0     		beq	.L50
 440:ProgrammingSteps.c ****         {
 441:ProgrammingSteps.c ****             return (FAILURE);
 609              		.loc 1 441 0
 610 00f8 0023     		movs	r3, #0
 611 00fa 00E0     		b	.L43
 612              	.L50:
 442:ProgrammingSteps.c ****         }
 443:ProgrammingSteps.c **** 	
 444:ProgrammingSteps.c **** 	return (SUCCESS);
 613              		.loc 1 444 0
 614 00fc 0123     		movs	r3, #1
 615              	.L43:
 445:ProgrammingSteps.c **** }
 616              		.loc 1 445 0
 617 00fe 1846     		mov	r0, r3
 618 0100 1837     		adds	r7, r7, #24
 619              		.cfi_def_cfa_offset 8
 620 0102 BD46     		mov	sp, r7
 621              		.cfi_def_cfa_register 13
 622              		@ sp needed
 623 0104 80BD     		pop	{r7, pc}
 624              	.L52:
 625 0106 00BF     		.align	2
 626              	.L51:
 627 0108 00010020 		.word	536871168
 628 010c 00000000 		.word	swd_PacketAck
 629 0110 04010020 		.word	536871172
 630 0114 08001040 		.word	1074790408
 631 0118 04001040 		.word	1074790404
 632 011c 04000080 		.word	-2147483644
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 20


 633 0120 00000000 		.word	result
 634              		.cfi_endproc
 635              	.LFE67:
 636              		.size	LoadLatch, .-LoadLatch
 637              		.section	.text.ChecksumAPI,"ax",%progbits
 638              		.align	2
 639              		.global	ChecksumAPI
 640              		.thumb
 641              		.thumb_func
 642              		.type	ChecksumAPI, %function
 643              	ChecksumAPI:
 644              	.LFB68:
 446:ProgrammingSteps.c **** 
 447:ProgrammingSteps.c **** /******************************************************************************
 448:ProgrammingSteps.c **** * Function Name: ChecksumAPI
 449:ProgrammingSteps.c **** *******************************************************************************
 450:ProgrammingSteps.c **** *
 451:ProgrammingSteps.c **** * Summary:
 452:ProgrammingSteps.c **** *  This function reads either the whole flash memory or a row of flash. When 
 453:ProgrammingSteps.c **** *  performing a checksum on the whole flash, the user code and the supervisory 
 454:ProgrammingSteps.c **** *  flash regions are included. When performing a checksum only on one row of 
 455:ProgrammingSteps.c **** *  flash, the flash row number is passed as a parameter. For computing Checksum
 456:ProgrammingSteps.c **** *  of entire flash, ChecksumRow input parameter is loaded as macro
 457:ProgrammingSteps.c **** *  CHECKSUM_ENTIRE_FLASH (0x8000).
 458:ProgrammingSteps.c **** *
 459:ProgrammingSteps.c **** * Parameters:
 460:ProgrammingSteps.c **** *  checksumRow: Row number of flash for which checksum has to be calculated. 
 461:ProgrammingSteps.c **** *  				To compute checksum of entire flash, this variable is set to 
 462:ProgrammingSteps.c **** *  				CHECKSUM_ENTIRE_FLASH (0x8000).
 463:ProgrammingSteps.c **** *  
 464:ProgrammingSteps.c **** *  checksum: This variable is loaded with the checksum after the execution of
 465:ProgrammingSteps.c **** *			 the function.
 466:ProgrammingSteps.c **** *
 467:ProgrammingSteps.c **** * Return:
 468:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Checksum System call is successfully executed.
 469:ProgrammingSteps.c **** *  FAILURE - Returns Failure if Checksum system call fails to execute.
 470:ProgrammingSteps.c **** *
 471:ProgrammingSteps.c **** * Note:
 472:ProgrammingSteps.c **** * This function is called in "Step 4. Checksum Privileged Calculation" and 
 473:ProgrammingSteps.c **** * "Step 9. Verify Checksum" to calculate the checksum of flash privileged rows
 474:ProgrammingSteps.c **** * and entire flash, respectively.
 475:ProgrammingSteps.c **** *
 476:ProgrammingSteps.c **** ******************************************************************************/
 477:ProgrammingSteps.c **** unsigned char ChecksumAPI(unsigned short checksumRow, unsigned long *checksum)
 478:ProgrammingSteps.c **** {
 645              		.loc 1 478 0
 646              		.cfi_startproc
 647              		@ args = 0, pretend = 0, frame = 16
 648              		@ frame_needed = 1, uses_anonymous_args = 0
 649 0000 80B5     		push	{r7, lr}
 650              		.cfi_def_cfa_offset 8
 651              		.cfi_offset 7, -8
 652              		.cfi_offset 14, -4
 653 0002 84B0     		sub	sp, sp, #16
 654              		.cfi_def_cfa_offset 24
 655 0004 00AF     		add	r7, sp, #0
 656              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 21


 657 0006 0346     		mov	r3, r0
 658 0008 3960     		str	r1, [r7]
 659 000a FB80     		strh	r3, [r7, #6]	@ movhi
 479:ProgrammingSteps.c **** 	unsigned long parameter1 	= 0;
 660              		.loc 1 479 0
 661 000c 0023     		movs	r3, #0
 662 000e FB60     		str	r3, [r7, #12]
 480:ProgrammingSteps.c **** 	unsigned long checksum_chip = 0 ;
 663              		.loc 1 480 0
 664 0010 0023     		movs	r3, #0
 665 0012 BB60     		str	r3, [r7, #8]
 481:ProgrammingSteps.c **** 	
 482:ProgrammingSteps.c **** 	/* Load parameter1 with the SROM command to compute checksum of whole
 483:ProgrammingSteps.c **** 	   flash */
 484:ProgrammingSteps.c **** 	parameter1 = ((unsigned long)SROM_KEY1 << 00) + (((unsigned long)SROM_KEY2 + //
 485:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 666              		.loc 1 485 0
 667 0014 FB88     		ldrh	r3, [r7, #6]
 668 0016 DBB2     		uxtb	r3, r3
 669 0018 1A04     		lsls	r2, r3, #16
 486:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 670              		.loc 1 486 0
 671 001a FB88     		ldrh	r3, [r7, #6]
 672 001c 03F47F43 		and	r3, r3, #65280
 673 0020 1B04     		lsls	r3, r3, #16
 485:ProgrammingSteps.c **** 				(((unsigned long)checksumRow & 0x0000FF00) << 16);
 674              		.loc 1 485 0
 675 0022 1344     		add	r3, r3, r2
 484:ProgrammingSteps.c **** 				(unsigned long)SROM_CMD_CHECKSUM) << 8) + (((unsigned long)checksumRow & 0x000000FF) << 16) + /
 676              		.loc 1 484 0
 677 0024 03F55E43 		add	r3, r3, #56832
 678 0028 B633     		adds	r3, r3, #182
 679 002a FB60     		str	r3, [r7, #12]
 487:ProgrammingSteps.c **** 	
 488:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 command */
 489:ProgrammingSteps.c ****     Write_IO (CPUSS_SYSARG, parameter1);
 680              		.loc 1 489 0
 681 002c 1A48     		ldr	r0, .L60
 682 002e F968     		ldr	r1, [r7, #12]
 683 0030 FFF7FEFF 		bl	Write_IO
 490:ProgrammingSteps.c **** 	
 491:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 684              		.loc 1 491 0
 685 0034 194B     		ldr	r3, .L60+4
 686 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 687 0038 012B     		cmp	r3, #1
 688 003a 01D0     		beq	.L54
 492:ProgrammingSteps.c ****     {
 493:ProgrammingSteps.c ****         return(FAILURE);
 689              		.loc 1 493 0
 690 003c 0023     		movs	r3, #0
 691 003e 27E0     		b	.L59
 692              	.L54:
 494:ProgrammingSteps.c ****     }
 495:ProgrammingSteps.c **** 	
 496:ProgrammingSteps.c **** 	/* Request SROM operation */
 497:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_CHECKSUM);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 22


 693              		.loc 1 497 0
 694 0040 1748     		ldr	r0, .L60+8
 695 0042 1849     		ldr	r1, .L60+12
 696 0044 FFF7FEFF 		bl	Write_IO
 498:ProgrammingSteps.c **** 	
 499:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 697              		.loc 1 499 0
 698 0048 144B     		ldr	r3, .L60+4
 699 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 700 004c 012B     		cmp	r3, #1
 701 004e 01D0     		beq	.L56
 500:ProgrammingSteps.c ****     {
 501:ProgrammingSteps.c ****         return(FAILURE);
 702              		.loc 1 501 0
 703 0050 0023     		movs	r3, #0
 704 0052 1DE0     		b	.L59
 705              	.L56:
 502:ProgrammingSteps.c ****     }
 503:ProgrammingSteps.c ****     
 504:ProgrammingSteps.c **** 	/* Read status of the operation */
 505:ProgrammingSteps.c **** 	result = PollSromStatus();
 706              		.loc 1 505 0
 707 0054 FFF7FEFF 		bl	PollSromStatus
 708 0058 0346     		mov	r3, r0
 709 005a 1A46     		mov	r2, r3
 710 005c 124B     		ldr	r3, .L60+16
 711 005e 1A70     		strb	r2, [r3]
 506:ProgrammingSteps.c **** 	
 507:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 712              		.loc 1 507 0
 713 0060 114B     		ldr	r3, .L60+16
 714 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 715 0064 012B     		cmp	r3, #1
 716 0066 01D0     		beq	.L57
 508:ProgrammingSteps.c ****     {
 509:ProgrammingSteps.c ****         return(FAILURE);
 717              		.loc 1 509 0
 718 0068 0023     		movs	r3, #0
 719 006a 11E0     		b	.L59
 720              	.L57:
 510:ProgrammingSteps.c ****     }
 511:ProgrammingSteps.c **** 	
 512:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG register to get the checksum value */
 513:ProgrammingSteps.c **** 	Read_IO( CPUSS_SYSARG, &checksum_chip);
 721              		.loc 1 513 0
 722 006c 07F10803 		add	r3, r7, #8
 723 0070 0948     		ldr	r0, .L60
 724 0072 1946     		mov	r1, r3
 725 0074 FFF7FEFF 		bl	Read_IO
 514:ProgrammingSteps.c **** 	
 515:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 726              		.loc 1 515 0
 727 0078 084B     		ldr	r3, .L60+4
 728 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 729 007c 012B     		cmp	r3, #1
 730 007e 01D0     		beq	.L58
 516:ProgrammingSteps.c ****     {
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 23


 517:ProgrammingSteps.c ****         return(FAILURE);
 731              		.loc 1 517 0
 732 0080 0023     		movs	r3, #0
 733 0082 05E0     		b	.L59
 734              	.L58:
 518:ProgrammingSteps.c ****     }
 519:ProgrammingSteps.c **** 	
 520:ProgrammingSteps.c **** 	/* 28-bit checksum */
 521:ProgrammingSteps.c **** 	*checksum = (checksum_chip & 0x0FFFFFFF);
 735              		.loc 1 521 0
 736 0084 BB68     		ldr	r3, [r7, #8]
 737 0086 23F07042 		bic	r2, r3, #-268435456
 738 008a 3B68     		ldr	r3, [r7]
 739 008c 1A60     		str	r2, [r3]
 522:ProgrammingSteps.c **** 
 523:ProgrammingSteps.c **** 	return (SUCCESS);
 740              		.loc 1 523 0
 741 008e 0123     		movs	r3, #1
 742              	.L59:
 524:ProgrammingSteps.c **** }
 743              		.loc 1 524 0 discriminator 1
 744 0090 1846     		mov	r0, r3
 745 0092 1037     		adds	r7, r7, #16
 746              		.cfi_def_cfa_offset 8
 747 0094 BD46     		mov	sp, r7
 748              		.cfi_def_cfa_register 13
 749              		@ sp needed
 750 0096 80BD     		pop	{r7, pc}
 751              	.L61:
 752              		.align	2
 753              	.L60:
 754 0098 08001040 		.word	1074790408
 755 009c 00000000 		.word	swd_PacketAck
 756 00a0 04001040 		.word	1074790404
 757 00a4 0B000080 		.word	-2147483637
 758 00a8 00000000 		.word	result
 759              		.cfi_endproc
 760              	.LFE68:
 761              		.size	ChecksumAPI, .-ChecksumAPI
 762              		.section	.text.DeviceAcquire,"ax",%progbits
 763              		.align	2
 764              		.global	DeviceAcquire
 765              		.thumb
 766              		.thumb_func
 767              		.type	DeviceAcquire, %function
 768              	DeviceAcquire:
 769              	.LFB69:
 525:ProgrammingSteps.c **** 
 526:ProgrammingSteps.c **** 
 527:ProgrammingSteps.c **** /******************************************************************************
 528:ProgrammingSteps.c **** *Function Name: DeviceAcquire
 529:ProgrammingSteps.c **** *******************************************************************************
 530:ProgrammingSteps.c **** *
 531:ProgrammingSteps.c **** * Summary:
 532:ProgrammingSteps.c **** *  This is Step 1 of the programming sequence. In this Step, target PSoC 4 is 
 533:ProgrammingSteps.c **** *  acquired by the host microcontroller by sending specific Port Acquiring 
 534:ProgrammingSteps.c **** *  Sequence in a 1.5 ms time-window. After acquiring SWD port, debug port is 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 24


 535:ProgrammingSteps.c **** *  configured and bit 31 in TEST_MODE control register is set.
 536:ProgrammingSteps.c **** *
 537:ProgrammingSteps.c **** * Parameters:
 538:ProgrammingSteps.c **** *  None
 539:ProgrammingSteps.c **** *
 540:ProgrammingSteps.c **** * Return:
 541:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if the device is successfully acquired.
 542:ProgrammingSteps.c **** *  FAILURE - Returns Failure if the function fails in any of the intermediate
 543:ProgrammingSteps.c **** *			 step.
 544:ProgrammingSteps.c **** *
 545:ProgrammingSteps.c **** * Note:
 546:ProgrammingSteps.c **** * This function has very strict timing requirements. The device must be
 547:ProgrammingSteps.c **** * acquired as per the timing requirements given in PSoC 4 Device Programming 
 548:ProgrammingSteps.c **** * Specification Document.
 549:ProgrammingSteps.c **** *
 550:ProgrammingSteps.c **** ******************************************************************************/
 551:ProgrammingSteps.c **** unsigned char DeviceAcquire(void)
 552:ProgrammingSteps.c **** {
 770              		.loc 1 552 0
 771              		.cfi_startproc
 772              		@ args = 0, pretend = 0, frame = 16
 773              		@ frame_needed = 1, uses_anonymous_args = 0
 774 0000 80B5     		push	{r7, lr}
 775              		.cfi_def_cfa_offset 8
 776              		.cfi_offset 7, -8
 777              		.cfi_offset 14, -4
 778 0002 84B0     		sub	sp, sp, #16
 779              		.cfi_def_cfa_offset 24
 780 0004 00AF     		add	r7, sp, #0
 781              		.cfi_def_cfa_register 7
 553:ProgrammingSteps.c **** 	unsigned long chip_DAP_Id 			= 0;
 782              		.loc 1 553 0
 783 0006 0023     		movs	r3, #0
 784 0008 BB60     		str	r3, [r7, #8]
 554:ProgrammingSteps.c ****     unsigned short total_packet_count 	= 0;
 785              		.loc 1 554 0
 786 000a 0023     		movs	r3, #0
 787 000c FB81     		strh	r3, [r7, #14]	@ movhi
 555:ProgrammingSteps.c ****     unsigned long status 				= 0;
 788              		.loc 1 555 0
 789 000e 0023     		movs	r3, #0
 790 0010 7B60     		str	r3, [r7, #4]
 556:ProgrammingSteps.c ****     
 557:ProgrammingSteps.c **** 	/* Aquiring Sequence */
 558:ProgrammingSteps.c **** 
 559:ProgrammingSteps.c **** 	SetXresCmosOutput();
 791              		.loc 1 559 0
 792 0012 FFF7FEFF 		bl	SetXresCmosOutput
 560:ProgrammingSteps.c **** 	SetXresHigh();
 793              		.loc 1 560 0
 794 0016 FFF7FEFF 		bl	SetXresHigh
 561:ProgrammingSteps.c **** 
 562:ProgrammingSteps.c **** 	SetSwdckCmosOutput();
 795              		.loc 1 562 0
 796 001a FFF7FEFF 		bl	SetSwdckCmosOutput
 563:ProgrammingSteps.c **** 	SetSwdckLow();
 797              		.loc 1 563 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 25


 798 001e FFF7FEFF 		bl	SetSwdckLow
 564:ProgrammingSteps.c **** 
 565:ProgrammingSteps.c **** 	SetSwdioCmosOutput();
 799              		.loc 1 565 0
 800 0022 FFF7FEFF 		bl	SetSwdioCmosOutput
 566:ProgrammingSteps.c **** 	SetSwdioLow();
 801              		.loc 1 566 0
 802 0026 FFF7FEFF 		bl	SetSwdioLow
 567:ProgrammingSteps.c **** 	
 568:ProgrammingSteps.c **** 	/* Set XRES of PSoC 4 low for 100us with SWDCK and SWDIO low (min delay 
 569:ProgrammingSteps.c **** 	   required is 5us) */
 570:ProgrammingSteps.c **** 	SetXresLow();
 803              		.loc 1 570 0
 804 002a FFF7FEFF 		bl	SetXresLow
 571:ProgrammingSteps.c **** 	DelayHundredUs();
 805              		.loc 1 571 0
 806 002e FFF7FEFF 		bl	DelayHundredUs
 572:ProgrammingSteps.c **** 	SetXresHigh();
 807              		.loc 1 572 0
 808 0032 FFF7FEFF 		bl	SetXresHigh
 809              	.L64:
 573:ProgrammingSteps.c **** 	
 574:ProgrammingSteps.c ****     do
 575:ProgrammingSteps.c ****     {
 576:ProgrammingSteps.c **** 		/* Call Swd_LineReset (Standard ARM command to reset DAP) and read
 577:ProgrammingSteps.c **** 		   DAP_ID from chip */
 578:ProgrammingSteps.c ****     	Swd_LineReset();
 810              		.loc 1 578 0 discriminator 2
 811 0036 FFF7FEFF 		bl	Swd_LineReset
 579:ProgrammingSteps.c **** 		
 580:ProgrammingSteps.c **** 		Read_DAP(DPACC_DP_IDCODE_READ, &chip_DAP_Id);
 812              		.loc 1 580 0 discriminator 2
 813 003a 07F10803 		add	r3, r7, #8
 814 003e A520     		movs	r0, #165
 815 0040 1946     		mov	r1, r3
 816 0042 FFF7FEFF 		bl	Read_DAP
 581:ProgrammingSteps.c ****     	
 582:ProgrammingSteps.c **** 		total_packet_count++;
 817              		.loc 1 582 0 discriminator 2
 818 0046 FB89     		ldrh	r3, [r7, #14]
 819 0048 0133     		adds	r3, r3, #1
 820 004a FB81     		strh	r3, [r7, #14]	@ movhi
 583:ProgrammingSteps.c **** 		
 584:ProgrammingSteps.c ****     }while((swd_PacketAck != SWD_OK_ACK)&& (total_packet_count < DEVICE_ACQUIRE_TIMEOUT));
 821              		.loc 1 584 0 discriminator 2
 822 004c 354B     		ldr	r3, .L76
 823 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 824 0050 012B     		cmp	r3, #1
 825 0052 02D0     		beq	.L63
 826              		.loc 1 584 0 is_stmt 0 discriminator 1
 827 0054 FB89     		ldrh	r3, [r7, #14]
 828 0056 132B     		cmp	r3, #19
 829 0058 EDD9     		bls	.L64
 830              	.L63:
 585:ProgrammingSteps.c **** 	
 586:ProgrammingSteps.c **** 	/* Set PORT_ACQUIRE_TIMEOUT_ERROR bit in swd_PacketAck if time
 587:ProgrammingSteps.c **** 	   exceeds 1.5 ms */
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 26


 588:ProgrammingSteps.c **** 	if (total_packet_count == DEVICE_ACQUIRE_TIMEOUT)
 831              		.loc 1 588 0 is_stmt 1
 832 005a FB89     		ldrh	r3, [r7, #14]
 833 005c 142B     		cmp	r3, #20
 834 005e 08D1     		bne	.L65
 589:ProgrammingSteps.c **** 	{
 590:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | PORT_ACQUIRE_TIMEOUT_ERROR;
 835              		.loc 1 590 0
 836 0060 304B     		ldr	r3, .L76
 837 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 838 0064 43F01003 		orr	r3, r3, #16
 839 0068 DAB2     		uxtb	r2, r3
 840 006a 2E4B     		ldr	r3, .L76
 841 006c 1A70     		strb	r2, [r3]
 591:ProgrammingSteps.c ****         return(FAILURE);
 842              		.loc 1 591 0
 843 006e 0023     		movs	r3, #0
 844 0070 53E0     		b	.L75
 845              	.L65:
 592:ProgrammingSteps.c **** 	}
 593:ProgrammingSteps.c **** 	
 594:ProgrammingSteps.c **** 	/* Set VERIFICATION_ERROR bit in swd_PacketAck if the DAP_ID read
 595:ProgrammingSteps.c **** 	   from chip does not match with the ARM CM0_DAP_ID (MACRO defined in
 596:ProgrammingSteps.c **** 	   ProgrammingSteps.h file - 0x0BB11477) */
 597:ProgrammingSteps.c **** 	if (chip_DAP_Id != CM0_DAP_ID)
 846              		.loc 1 597 0
 847 0072 BB68     		ldr	r3, [r7, #8]
 848 0074 2C4A     		ldr	r2, .L76+4
 849 0076 9342     		cmp	r3, r2
 850 0078 08D0     		beq	.L67
 598:ProgrammingSteps.c **** 	{
 599:ProgrammingSteps.c **** 		swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 851              		.loc 1 599 0
 852 007a 2A4B     		ldr	r3, .L76
 853 007c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 854 007e 43F04003 		orr	r3, r3, #64
 855 0082 DAB2     		uxtb	r2, r3
 856 0084 274B     		ldr	r3, .L76
 857 0086 1A70     		strb	r2, [r3]
 600:ProgrammingSteps.c **** 		return(FAILURE);
 858              		.loc 1 600 0
 859 0088 0023     		movs	r3, #0
 860 008a 46E0     		b	.L75
 861              	.L67:
 601:ProgrammingSteps.c **** 	}
 602:ProgrammingSteps.c **** 	
 603:ProgrammingSteps.c **** 	/* Initialize Debug Port */
 604:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_CTRLSTAT_WRITE, 0x54000000);
 862              		.loc 1 604 0
 863 008c A920     		movs	r0, #169
 864 008e 4FF0A841 		mov	r1, #1409286144
 865 0092 FFF7FEFF 		bl	Write_DAP
 605:ProgrammingSteps.c ****     
 606:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 866              		.loc 1 606 0
 867 0096 234B     		ldr	r3, .L76
 868 0098 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 27


 869 009a 012B     		cmp	r3, #1
 870 009c 01D0     		beq	.L68
 607:ProgrammingSteps.c ****     {
 608:ProgrammingSteps.c ****         return(FAILURE);
 871              		.loc 1 608 0
 872 009e 0023     		movs	r3, #0
 873 00a0 3BE0     		b	.L75
 874              	.L68:
 609:ProgrammingSteps.c ****     }
 610:ProgrammingSteps.c **** 	
 611:ProgrammingSteps.c **** 	Write_DAP (DPACC_DP_SELECT_WRITE, 0x00000000);
 875              		.loc 1 611 0
 876 00a2 B120     		movs	r0, #177
 877 00a4 0021     		movs	r1, #0
 878 00a6 FFF7FEFF 		bl	Write_DAP
 612:ProgrammingSteps.c ****     
 613:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 879              		.loc 1 613 0
 880 00aa 1E4B     		ldr	r3, .L76
 881 00ac 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 882 00ae 012B     		cmp	r3, #1
 883 00b0 01D0     		beq	.L69
 614:ProgrammingSteps.c ****     {
 615:ProgrammingSteps.c ****         return(FAILURE);
 884              		.loc 1 615 0
 885 00b2 0023     		movs	r3, #0
 886 00b4 31E0     		b	.L75
 887              	.L69:
 616:ProgrammingSteps.c ****     }
 617:ProgrammingSteps.c **** 	
 618:ProgrammingSteps.c **** 	Write_DAP (DPACC_AP_CSW_WRITE, 0x00000002);
 888              		.loc 1 618 0
 889 00b6 A320     		movs	r0, #163
 890 00b8 0221     		movs	r1, #2
 891 00ba FFF7FEFF 		bl	Write_DAP
 619:ProgrammingSteps.c ****     
 620:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 892              		.loc 1 620 0
 893 00be 194B     		ldr	r3, .L76
 894 00c0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 895 00c2 012B     		cmp	r3, #1
 896 00c4 01D0     		beq	.L70
 621:ProgrammingSteps.c ****     {
 622:ProgrammingSteps.c ****         return(FAILURE);
 897              		.loc 1 622 0
 898 00c6 0023     		movs	r3, #0
 899 00c8 27E0     		b	.L75
 900              	.L70:
 623:ProgrammingSteps.c ****     }
 624:ProgrammingSteps.c **** 
 625:ProgrammingSteps.c **** 	/* Enter CPU into Test Mode */
 626:ProgrammingSteps.c ****     Write_IO (TEST_MODE, 0x80000000);
 901              		.loc 1 626 0
 902 00ca 1848     		ldr	r0, .L76+8
 903 00cc 4FF00041 		mov	r1, #-2147483648
 904 00d0 FFF7FEFF 		bl	Write_IO
 627:ProgrammingSteps.c **** 	
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 28


 628:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 905              		.loc 1 628 0
 906 00d4 134B     		ldr	r3, .L76
 907 00d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 908 00d8 012B     		cmp	r3, #1
 909 00da 01D0     		beq	.L71
 629:ProgrammingSteps.c ****     {
 630:ProgrammingSteps.c ****         return(FAILURE);
 910              		.loc 1 630 0
 911 00dc 0023     		movs	r3, #0
 912 00de 1CE0     		b	.L75
 913              	.L71:
 631:ProgrammingSteps.c ****     }
 632:ProgrammingSteps.c ****     
 633:ProgrammingSteps.c ****     Read_IO (TEST_MODE, &status);
 914              		.loc 1 633 0
 915 00e0 3B1D     		adds	r3, r7, #4
 916 00e2 1248     		ldr	r0, .L76+8
 917 00e4 1946     		mov	r1, r3
 918 00e6 FFF7FEFF 		bl	Read_IO
 634:ProgrammingSteps.c **** 	
 635:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 919              		.loc 1 635 0
 920 00ea 0E4B     		ldr	r3, .L76
 921 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 922 00ee 012B     		cmp	r3, #1
 923 00f0 01D0     		beq	.L72
 636:ProgrammingSteps.c ****     {
 637:ProgrammingSteps.c ****         return(FAILURE);
 924              		.loc 1 637 0
 925 00f2 0023     		movs	r3, #0
 926 00f4 11E0     		b	.L75
 927              	.L72:
 638:ProgrammingSteps.c ****     }
 639:ProgrammingSteps.c **** 	
 640:ProgrammingSteps.c ****     if((status & 0x80000000) != 0x80000000)
 928              		.loc 1 640 0
 929 00f6 7B68     		ldr	r3, [r7, #4]
 930 00f8 002B     		cmp	r3, #0
 931 00fa 01DB     		blt	.L73
 641:ProgrammingSteps.c ****     {
 642:ProgrammingSteps.c ****         return (FAILURE);
 932              		.loc 1 642 0
 933 00fc 0023     		movs	r3, #0
 934 00fe 0CE0     		b	.L75
 935              	.L73:
 643:ProgrammingSteps.c ****     }
 644:ProgrammingSteps.c **** 	
 645:ProgrammingSteps.c **** 	/* Read status of the operation */
 646:ProgrammingSteps.c **** 	result = PollSromStatus();
 936              		.loc 1 646 0
 937 0100 FFF7FEFF 		bl	PollSromStatus
 938 0104 0346     		mov	r3, r0
 939 0106 1A46     		mov	r2, r3
 940 0108 094B     		ldr	r3, .L76+12
 941 010a 1A70     		strb	r2, [r3]
 647:ProgrammingSteps.c **** 	
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 29


 648:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 942              		.loc 1 648 0
 943 010c 084B     		ldr	r3, .L76+12
 944 010e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 945 0110 012B     		cmp	r3, #1
 946 0112 01D0     		beq	.L74
 649:ProgrammingSteps.c **** 	{
 650:ProgrammingSteps.c **** 		return(FAILURE);		
 947              		.loc 1 650 0
 948 0114 0023     		movs	r3, #0
 949 0116 00E0     		b	.L75
 950              	.L74:
 651:ProgrammingSteps.c **** 	}
 652:ProgrammingSteps.c **** 	
 653:ProgrammingSteps.c **** 	#if defined (CY8C40xx_FAMILY) || defined (CY8C4xx7_BL_FAMILY)
 654:ProgrammingSteps.c **** 	
 655:ProgrammingSteps.c **** 	/* Set IMO to 48 MHz */
 656:ProgrammingSteps.c **** 	SetIMO48MHz();
 657:ProgrammingSteps.c **** 	
 658:ProgrammingSteps.c **** 	/* Read status of the operation */
 659:ProgrammingSteps.c **** 	result = PollSromStatus();
 660:ProgrammingSteps.c **** 	
 661:ProgrammingSteps.c **** 	if (result != SROM_SUCCESS)
 662:ProgrammingSteps.c **** 	{
 663:ProgrammingSteps.c **** 		return(FAILURE);		
 664:ProgrammingSteps.c **** 	}
 665:ProgrammingSteps.c **** 	#endif
 666:ProgrammingSteps.c **** 	
 667:ProgrammingSteps.c ****     return (SUCCESS);
 951              		.loc 1 667 0
 952 0118 0123     		movs	r3, #1
 953              	.L75:
 668:ProgrammingSteps.c **** }
 954              		.loc 1 668 0 discriminator 1
 955 011a 1846     		mov	r0, r3
 956 011c 1037     		adds	r7, r7, #16
 957              		.cfi_def_cfa_offset 8
 958 011e BD46     		mov	sp, r7
 959              		.cfi_def_cfa_register 13
 960              		@ sp needed
 961 0120 80BD     		pop	{r7, pc}
 962              	.L77:
 963 0122 00BF     		.align	2
 964              	.L76:
 965 0124 00000000 		.word	swd_PacketAck
 966 0128 7714B10B 		.word	196154487
 967 012c 14000340 		.word	1073938452
 968 0130 00000000 		.word	result
 969              		.cfi_endproc
 970              	.LFE69:
 971              		.size	DeviceAcquire, .-DeviceAcquire
 972              		.section	.text.VerifySiliconId,"ax",%progbits
 973              		.align	2
 974              		.global	VerifySiliconId
 975              		.thumb
 976              		.thumb_func
 977              		.type	VerifySiliconId, %function
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 30


 978              	VerifySiliconId:
 979              	.LFB70:
 669:ProgrammingSteps.c **** 
 670:ProgrammingSteps.c **** /******************************************************************************
 671:ProgrammingSteps.c **** * Function Name: VerifySiliconId
 672:ProgrammingSteps.c **** *******************************************************************************
 673:ProgrammingSteps.c **** *
 674:ProgrammingSteps.c **** * Summary:
 675:ProgrammingSteps.c **** *  This is Step 2 of the programming sequence. In this Step, Silicon Id of the
 676:ProgrammingSteps.c **** *  PSoC 4 device is read and matched with the silicon id stored in the Hex File
 677:ProgrammingSteps.c **** *  to verify that the correct device is being programmed.
 678:ProgrammingSteps.c **** *
 679:ProgrammingSteps.c **** * Parameters:
 680:ProgrammingSteps.c **** *  None
 681:ProgrammingSteps.c **** *
 682:ProgrammingSteps.c **** * Return:
 683:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if Silicon Id read from chip matches the Id in the
 684:ProgrammingSteps.c **** *			 HEX File.
 685:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 686:ProgrammingSteps.c **** *			 message.
 687:ProgrammingSteps.c **** *
 688:ProgrammingSteps.c **** * Note:
 689:ProgrammingSteps.c **** * 
 690:ProgrammingSteps.c **** ******************************************************************************/
 691:ProgrammingSteps.c **** unsigned char VerifySiliconId(void)
 692:ProgrammingSteps.c **** {
 980              		.loc 1 692 0
 981              		.cfi_startproc
 982              		@ args = 0, pretend = 0, frame = 24
 983              		@ frame_needed = 1, uses_anonymous_args = 0
 984 0000 80B5     		push	{r7, lr}
 985              		.cfi_def_cfa_offset 8
 986              		.cfi_offset 7, -8
 987              		.cfi_offset 14, -4
 988 0002 86B0     		sub	sp, sp, #24
 989              		.cfi_def_cfa_offset 32
 990 0004 00AF     		add	r7, sp, #0
 991              		.cfi_def_cfa_register 7
 693:ProgrammingSteps.c **** 	unsigned char i;
 694:ProgrammingSteps.c **** 	unsigned long deviceSiliconID;
 695:ProgrammingSteps.c **** 	unsigned long hexSiliconId = 0;
 992              		.loc 1 695 0
 993 0006 0023     		movs	r3, #0
 994 0008 BB60     		str	r3, [r7, #8]
 696:ProgrammingSteps.c ****     
 697:ProgrammingSteps.c **** 	unsigned long parameter1 	 = 0;
 995              		.loc 1 697 0
 996 000a 0023     		movs	r3, #0
 997 000c 3B61     		str	r3, [r7, #16]
 698:ProgrammingSteps.c **** 	unsigned long siliconIdData1 = 0;
 998              		.loc 1 698 0
 999 000e 0023     		movs	r3, #0
 1000 0010 7B60     		str	r3, [r7, #4]
 699:ProgrammingSteps.c **** 	unsigned long siliconIdData2 = 0;
 1001              		.loc 1 699 0
 1002 0012 0023     		movs	r3, #0
 1003 0014 3B60     		str	r3, [r7]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 31


 700:ProgrammingSteps.c **** 	
 701:ProgrammingSteps.c **** 	/* Read and store Silicon ID from HEX file to hexSiliconId array */
 702:ProgrammingSteps.c **** 	HEX_ReadSiliconId(&hexSiliconId);
 1004              		.loc 1 702 0
 1005 0016 07F10803 		add	r3, r7, #8
 1006 001a 1846     		mov	r0, r3
 1007 001c FFF7FEFF 		bl	HEX_ReadSiliconId
 703:ProgrammingSteps.c **** 	
 704:ProgrammingSteps.c **** 	/* Load Parameter1 with the SROM command to read silicon ID from PSoC 4
 705:ProgrammingSteps.c **** 	   chip */
 706:ProgrammingSteps.c **** 	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1008              		.loc 1 706 0
 1009 0020 4DF2B633 		movw	r3, #54198
 1010 0024 3B61     		str	r3, [r7, #16]
 707:ProgrammingSteps.c **** 				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_GET_SILICON_ID) << 8));
 708:ProgrammingSteps.c **** 	
 709:ProgrammingSteps.c **** 	/* Load CPUSS_SYSARG register with parameter1 */
 710:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSARG, parameter1);
 1011              		.loc 1 710 0
 1012 0026 3248     		ldr	r0, .L89
 1013 0028 3969     		ldr	r1, [r7, #16]
 1014 002a FFF7FEFF 		bl	Write_IO
 711:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1015              		.loc 1 711 0
 1016 002e 314B     		ldr	r3, .L89+4
 1017 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1018 0032 012B     		cmp	r3, #1
 1019 0034 01D0     		beq	.L79
 712:ProgrammingSteps.c ****     {
 713:ProgrammingSteps.c ****         return(FAILURE);
 1020              		.loc 1 713 0
 1021 0036 0023     		movs	r3, #0
 1022 0038 55E0     		b	.L88
 1023              	.L79:
 714:ProgrammingSteps.c ****     }
 715:ProgrammingSteps.c **** 	
 716:ProgrammingSteps.c **** 	/* Request SROM operation */
 717:ProgrammingSteps.c **** 	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_GET_SILICON_ID);
 1024              		.loc 1 717 0
 1025 003a 2F48     		ldr	r0, .L89+8
 1026 003c 4FF00041 		mov	r1, #-2147483648
 1027 0040 FFF7FEFF 		bl	Write_IO
 718:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1028              		.loc 1 718 0
 1029 0044 2B4B     		ldr	r3, .L89+4
 1030 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1031 0048 012B     		cmp	r3, #1
 1032 004a 01D0     		beq	.L81
 719:ProgrammingSteps.c ****     {
 720:ProgrammingSteps.c ****         return(FAILURE);
 1033              		.loc 1 720 0
 1034 004c 0023     		movs	r3, #0
 1035 004e 4AE0     		b	.L88
 1036              	.L81:
 721:ProgrammingSteps.c ****     }
 722:ProgrammingSteps.c **** 	
 723:ProgrammingSteps.c **** 	/* Read status of the operation */
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 32


 724:ProgrammingSteps.c ****     result = PollSromStatus();
 1037              		.loc 1 724 0
 1038 0050 FFF7FEFF 		bl	PollSromStatus
 1039 0054 0346     		mov	r3, r0
 1040 0056 1A46     		mov	r2, r3
 1041 0058 284B     		ldr	r3, .L89+12
 1042 005a 1A70     		strb	r2, [r3]
 725:ProgrammingSteps.c **** 	if( result != SROM_SUCCESS )
 1043              		.loc 1 725 0
 1044 005c 274B     		ldr	r3, .L89+12
 1045 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1046 0060 012B     		cmp	r3, #1
 1047 0062 01D0     		beq	.L82
 726:ProgrammingSteps.c ****     {
 727:ProgrammingSteps.c ****         return(FAILURE);
 1048              		.loc 1 727 0
 1049 0064 0023     		movs	r3, #0
 1050 0066 3EE0     		b	.L88
 1051              	.L82:
 728:ProgrammingSteps.c ****     }
 729:ProgrammingSteps.c **** 	
 730:ProgrammingSteps.c **** 	/* Read CPUSS_SYSARG and CPUSS_SYSREQ to read 4 bytes of silicon ID */
 731:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSARG, &siliconIdData1);
 1052              		.loc 1 731 0
 1053 0068 3B1D     		adds	r3, r7, #4
 1054 006a 2148     		ldr	r0, .L89
 1055 006c 1946     		mov	r1, r3
 1056 006e FFF7FEFF 		bl	Read_IO
 732:ProgrammingSteps.c ****     if( swd_PacketAck != SWD_OK_ACK )
 1057              		.loc 1 732 0
 1058 0072 204B     		ldr	r3, .L89+4
 1059 0074 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1060 0076 012B     		cmp	r3, #1
 1061 0078 01D0     		beq	.L83
 733:ProgrammingSteps.c ****     {
 734:ProgrammingSteps.c ****         return(FAILURE);
 1062              		.loc 1 734 0
 1063 007a 0023     		movs	r3, #0
 1064 007c 33E0     		b	.L88
 1065              	.L83:
 735:ProgrammingSteps.c ****     }
 736:ProgrammingSteps.c **** 	
 737:ProgrammingSteps.c **** 	Read_IO(CPUSS_SYSREQ, &siliconIdData2);
 1066              		.loc 1 737 0
 1067 007e 3B46     		mov	r3, r7
 1068 0080 1D48     		ldr	r0, .L89+8
 1069 0082 1946     		mov	r1, r3
 1070 0084 FFF7FEFF 		bl	Read_IO
 738:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 1071              		.loc 1 738 0
 1072 0088 1A4B     		ldr	r3, .L89+4
 1073 008a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1074 008c 012B     		cmp	r3, #1
 1075 008e 01D0     		beq	.L84
 739:ProgrammingSteps.c ****     {
 740:ProgrammingSteps.c ****         return(FAILURE);
 1076              		.loc 1 740 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 33


 1077 0090 0023     		movs	r3, #0
 1078 0092 28E0     		b	.L88
 1079              	.L84:
 741:ProgrammingSteps.c ****     }
 742:ProgrammingSteps.c ****     
 743:ProgrammingSteps.c **** 	/*
 744:ProgrammingSteps.c **** 	SiliconIdData2 (0th byte) = 4th byte of Device Silicon ID (MSB)
 745:ProgrammingSteps.c **** 	SiliconIdData1 (3rd byte) = 3rd byte of Device Silicon ID
 746:ProgrammingSteps.c **** 	SiliconIdData1 (1st byte) = 2nd byte of Device Silicon ID
 747:ProgrammingSteps.c **** 	SiliconIdData1 (2nd byte) = 1st byte of Device Silicon ID (LSB)
 748:ProgrammingSteps.c **** 	*/
 749:ProgrammingSteps.c **** 	deviceSiliconID = (((siliconIdData2 << 24) & 0xFF000000) + (siliconIdData1 & 0x00FF0000) + //
 1080              		.loc 1 749 0
 1081 0094 3B68     		ldr	r3, [r7]
 1082 0096 1A06     		lsls	r2, r3, #24
 1083 0098 7B68     		ldr	r3, [r7, #4]
 1084 009a 03F47F03 		and	r3, r3, #16711680
 1085 009e 1A44     		add	r2, r2, r3
 750:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1086              		.loc 1 750 0
 1087 00a0 7B68     		ldr	r3, [r7, #4]
 1088 00a2 1B02     		lsls	r3, r3, #8
 1089 00a4 9BB2     		uxth	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1090              		.loc 1 749 0
 1091 00a6 1A44     		add	r2, r2, r3
 1092              		.loc 1 750 0
 1093 00a8 7B68     		ldr	r3, [r7, #4]
 1094 00aa 1B0A     		lsrs	r3, r3, #8
 1095 00ac DBB2     		uxtb	r3, r3
 749:ProgrammingSteps.c **** 						((siliconIdData1 << 8) & 0x0000FF00) + ((siliconIdData1 >> 8) & 0x000000FF));
 1096              		.loc 1 749 0
 1097 00ae 1344     		add	r3, r3, r2
 1098 00b0 FB60     		str	r3, [r7, #12]
 751:ProgrammingSteps.c **** 	
 752:ProgrammingSteps.c **** 	/* Match the Silicon ID read from HEX file and PSoC 4 chip */
 753:ProgrammingSteps.c **** 	for (i=0; i<SILICON_ID_BYTE_LENGTH; i++)
 1099              		.loc 1 753 0
 1100 00b2 0023     		movs	r3, #0
 1101 00b4 FB75     		strb	r3, [r7, #23]
 1102 00b6 12E0     		b	.L85
 1103              	.L87:
 754:ProgrammingSteps.c **** 	{
 755:ProgrammingSteps.c **** 		if ((deviceSiliconID & 0xFF00FFFF) != (hexSiliconId & 0xFF00FFFF))
 1104              		.loc 1 755 0
 1105 00b8 BA68     		ldr	r2, [r7, #8]
 1106 00ba FB68     		ldr	r3, [r7, #12]
 1107 00bc 5340     		eors	r3, r3, r2
 1108 00be 23F47F03 		bic	r3, r3, #16711680
 1109 00c2 002B     		cmp	r3, #0
 1110 00c4 08D0     		beq	.L86
 756:ProgrammingSteps.c ****         {
 757:ProgrammingSteps.c **** 			/* Set the VERIFICATION_ERROR bit in swd_PacketAck */
 758:ProgrammingSteps.c ****             swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1111              		.loc 1 758 0
 1112 00c6 0B4B     		ldr	r3, .L89+4
 1113 00c8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 34


 1114 00ca 43F04003 		orr	r3, r3, #64
 1115 00ce DAB2     		uxtb	r2, r3
 1116 00d0 084B     		ldr	r3, .L89+4
 1117 00d2 1A70     		strb	r2, [r3]
 759:ProgrammingSteps.c **** 			return (FAILURE);
 1118              		.loc 1 759 0
 1119 00d4 0023     		movs	r3, #0
 1120 00d6 06E0     		b	.L88
 1121              	.L86:
 753:ProgrammingSteps.c **** 	{
 1122              		.loc 1 753 0 discriminator 2
 1123 00d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1124 00da 0133     		adds	r3, r3, #1
 1125 00dc FB75     		strb	r3, [r7, #23]
 1126              	.L85:
 753:ProgrammingSteps.c **** 	{
 1127              		.loc 1 753 0 is_stmt 0 discriminator 1
 1128 00de FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1129 00e0 032B     		cmp	r3, #3
 1130 00e2 E9D9     		bls	.L87
 760:ProgrammingSteps.c ****         }
 761:ProgrammingSteps.c **** 	}
 762:ProgrammingSteps.c **** 	return (SUCCESS);
 1131              		.loc 1 762 0 is_stmt 1
 1132 00e4 0123     		movs	r3, #1
 1133              	.L88:
 763:ProgrammingSteps.c **** }
 1134              		.loc 1 763 0 discriminator 1
 1135 00e6 1846     		mov	r0, r3
 1136 00e8 1837     		adds	r7, r7, #24
 1137              		.cfi_def_cfa_offset 8
 1138 00ea BD46     		mov	sp, r7
 1139              		.cfi_def_cfa_register 13
 1140              		@ sp needed
 1141 00ec 80BD     		pop	{r7, pc}
 1142              	.L90:
 1143 00ee 00BF     		.align	2
 1144              	.L89:
 1145 00f0 08001040 		.word	1074790408
 1146 00f4 00000000 		.word	swd_PacketAck
 1147 00f8 04001040 		.word	1074790404
 1148 00fc 00000000 		.word	result
 1149              		.cfi_endproc
 1150              	.LFE70:
 1151              		.size	VerifySiliconId, .-VerifySiliconId
 1152              		.section	.text.EraseAllFlash,"ax",%progbits
 1153              		.align	2
 1154              		.global	EraseAllFlash
 1155              		.thumb
 1156              		.thumb_func
 1157              		.type	EraseAllFlash, %function
 1158              	EraseAllFlash:
 1159              	.LFB71:
 764:ProgrammingSteps.c **** 
 765:ProgrammingSteps.c **** /******************************************************************************
 766:ProgrammingSteps.c **** * Function Name: EraseAllFlash
 767:ProgrammingSteps.c **** *******************************************************************************
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 35


 768:ProgrammingSteps.c **** *
 769:ProgrammingSteps.c **** * Summary:
 770:ProgrammingSteps.c **** *  This is Step 3 of the programming sequence. In this Step, the whole user 
 771:ProgrammingSteps.c **** *  flash is erased. This function uses GetChipProtectionVal() and 
 772:ProgrammingSteps.c **** *  GetTransitionMode() API's to take the decision on the method to follow to 
 773:ProgrammingSteps.c **** *  erase the device.
 774:ProgrammingSteps.c **** *
 775:ProgrammingSteps.c **** * Parameters:
 776:ProgrammingSteps.c **** *  None
 777:ProgrammingSteps.c **** *
 778:ProgrammingSteps.c **** * Return:
 779:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully erases complete user 
 780:ProgrammingSteps.c **** *			 flash region.
 781:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 782:ProgrammingSteps.c **** *			 message.
 783:ProgrammingSteps.c **** *
 784:ProgrammingSteps.c **** * Note:
 785:ProgrammingSteps.c **** * 
 786:ProgrammingSteps.c **** ******************************************************************************/
 787:ProgrammingSteps.c **** unsigned char EraseAllFlash(void)
 788:ProgrammingSteps.c **** {
 1160              		.loc 1 788 0
 1161              		.cfi_startproc
 1162              		@ args = 0, pretend = 0, frame = 8
 1163              		@ frame_needed = 1, uses_anonymous_args = 0
 1164 0000 80B5     		push	{r7, lr}
 1165              		.cfi_def_cfa_offset 8
 1166              		.cfi_offset 7, -8
 1167              		.cfi_offset 14, -4
 1168 0002 82B0     		sub	sp, sp, #8
 1169              		.cfi_def_cfa_offset 16
 1170 0004 00AF     		add	r7, sp, #0
 1171              		.cfi_def_cfa_register 7
 789:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1172              		.loc 1 789 0
 1173 0006 0023     		movs	r3, #0
 1174 0008 7B60     		str	r3, [r7, #4]
 790:ProgrammingSteps.c **** 	
 791:ProgrammingSteps.c **** 	/* Get current chip protection setting */
 792:ProgrammingSteps.c **** 	GetChipProtectionVal();
 1175              		.loc 1 792 0
 1176 000a FFF7FEFF 		bl	GetChipProtectionVal
 793:ProgrammingSteps.c **** 	
 794:ProgrammingSteps.c **** 	/* Check if the Chip protection setting transition is valid */
 795:ProgrammingSteps.c **** 	result = GetTransitionMode();
 1177              		.loc 1 795 0
 1178 000e FFF7FEFF 		bl	GetTransitionMode
 1179 0012 0346     		mov	r3, r0
 1180 0014 1A46     		mov	r2, r3
 1181 0016 3A4B     		ldr	r3, .L104
 1182 0018 1A70     		strb	r2, [r3]
 796:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1183              		.loc 1 796 0
 1184 001a 394B     		ldr	r3, .L104
 1185 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1186 001e 012B     		cmp	r3, #1
 1187 0020 01D0     		beq	.L92
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 36


 797:ProgrammingSteps.c **** 	{
 798:ProgrammingSteps.c **** 		return(FAILURE);
 1188              		.loc 1 798 0
 1189 0022 0023     		movs	r3, #0
 1190 0024 68E0     		b	.L93
 1191              	.L92:
 799:ProgrammingSteps.c **** 	}
 800:ProgrammingSteps.c **** 	
 801:ProgrammingSteps.c **** 	/* If the transition is from open to any protection setting or from virgin to
 802:ProgrammingSteps.c **** 	   open, call ERASE_ALL SROM command */
 803:ProgrammingSteps.c **** 	if ((flow == OPEN_XXX) || (flow == VIRGIN_OPEN))
 1192              		.loc 1 803 0
 1193 0026 374B     		ldr	r3, .L104+4
 1194 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1195 002a 002B     		cmp	r3, #0
 1196 002c 03D0     		beq	.L94
 1197              		.loc 1 803 0 is_stmt 0 discriminator 1
 1198 002e 354B     		ldr	r3, .L104+4
 1199 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1200 0032 012B     		cmp	r3, #1
 1201 0034 2DD1     		bne	.L95
 1202              	.L94:
 804:ProgrammingSteps.c ****     {
 805:ProgrammingSteps.c **** 		parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 1203              		.loc 1 805 0 is_stmt 1
 1204 0036 4DF6B653 		movw	r3, #56758
 1205 003a 7B60     		str	r3, [r7, #4]
 806:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_ERASE_ALL) << 8));
 807:ProgrammingSteps.c **** 		
 808:ProgrammingSteps.c **** 		/* Load ERASE_ALL SROM command in parameter1 to SRAM */ 
 809:ProgrammingSteps.c ****     	Write_IO (SRAM_PARAMS_BASE + 0x00, parameter1);
 1206              		.loc 1 809 0
 1207 003c 3248     		ldr	r0, .L104+8
 1208 003e 7968     		ldr	r1, [r7, #4]
 1209 0040 FFF7FEFF 		bl	Write_IO
 810:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1210              		.loc 1 810 0
 1211 0044 314B     		ldr	r3, .L104+12
 1212 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1213 0048 012B     		cmp	r3, #1
 1214 004a 01D0     		beq	.L96
 811:ProgrammingSteps.c ****         {
 812:ProgrammingSteps.c ****             return(FAILURE);
 1215              		.loc 1 812 0
 1216 004c 0023     		movs	r3, #0
 1217 004e 53E0     		b	.L93
 1218              	.L96:
 813:ProgrammingSteps.c ****         }
 814:ProgrammingSteps.c **** 		
 815:ProgrammingSteps.c **** 		/* Set location of parameters */
 816:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1219              		.loc 1 816 0
 1220 0050 2F48     		ldr	r0, .L104+16
 1221 0052 2D49     		ldr	r1, .L104+8
 1222 0054 FFF7FEFF 		bl	Write_IO
 817:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1223              		.loc 1 817 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 37


 1224 0058 2C4B     		ldr	r3, .L104+12
 1225 005a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1226 005c 012B     		cmp	r3, #1
 1227 005e 01D0     		beq	.L97
 818:ProgrammingSteps.c ****         {
 819:ProgrammingSteps.c ****             return(FAILURE);
 1228              		.loc 1 819 0
 1229 0060 0023     		movs	r3, #0
 1230 0062 49E0     		b	.L93
 1231              	.L97:
 820:ProgrammingSteps.c ****         }
 821:ProgrammingSteps.c **** 		
 822:ProgrammingSteps.c **** 		/* Request SROM call */
 823:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_ERASE_ALL);
 1232              		.loc 1 823 0
 1233 0064 2B48     		ldr	r0, .L104+20
 1234 0066 2C49     		ldr	r1, .L104+24
 1235 0068 FFF7FEFF 		bl	Write_IO
 824:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1236              		.loc 1 824 0
 1237 006c 274B     		ldr	r3, .L104+12
 1238 006e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1239 0070 012B     		cmp	r3, #1
 1240 0072 01D0     		beq	.L98
 825:ProgrammingSteps.c ****         {
 826:ProgrammingSteps.c ****             return(FAILURE);
 1241              		.loc 1 826 0
 1242 0074 0023     		movs	r3, #0
 1243 0076 3FE0     		b	.L93
 1244              	.L98:
 827:ProgrammingSteps.c ****         }
 828:ProgrammingSteps.c **** 		
 829:ProgrammingSteps.c **** 		/* Read status of the operation */
 830:ProgrammingSteps.c ****     	result = PollSromStatus();
 1245              		.loc 1 830 0
 1246 0078 FFF7FEFF 		bl	PollSromStatus
 1247 007c 0346     		mov	r3, r0
 1248 007e 1A46     		mov	r2, r3
 1249 0080 1F4B     		ldr	r3, .L104
 1250 0082 1A70     		strb	r2, [r3]
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1251              		.loc 1 831 0
 1252 0084 1E4B     		ldr	r3, .L104
 1253 0086 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1254 0088 012B     		cmp	r3, #1
 1255 008a 01D0     		beq	.L99
 832:ProgrammingSteps.c **** 		{
 833:ProgrammingSteps.c ****     		return (FAILURE);
 1256              		.loc 1 833 0
 1257 008c 0023     		movs	r3, #0
 1258 008e 33E0     		b	.L93
 1259              	.L99:
 831:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1260              		.loc 1 831 0
 1261 0090 31E0     		b	.L100
 1262              	.L95:
 834:ProgrammingSteps.c **** 		}
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 38


 835:ProgrammingSteps.c ****     }
 836:ProgrammingSteps.c **** 	
 837:ProgrammingSteps.c **** 	/* If the transition is from protected mode to open mode or protected mode to
 838:ProgrammingSteps.c **** 	protected mode only, call ERASE_ALL SROM command */
 839:ProgrammingSteps.c ****     else if (flow == PROT_XXX)
 1263              		.loc 1 839 0
 1264 0092 1C4B     		ldr	r3, .L104+4
 1265 0094 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1266 0096 022B     		cmp	r3, #2
 1267 0098 2DD1     		bne	.L100
 840:ProgrammingSteps.c ****     {
 841:ProgrammingSteps.c **** 		/* Move chip to open state: 0x01 corresponds to open state, 0x00 to
 842:ProgrammingSteps.c **** 		   macro 1 */
 843:ProgrammingSteps.c ****     	parameter1 = ((unsigned long)SROM_KEY1 << 0) + //
 1268              		.loc 1 843 0
 1269 009a 204B     		ldr	r3, .L104+28
 1270 009c 7B60     		str	r3, [r7, #4]
 844:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 845:ProgrammingSteps.c **** 					(0x01 << 16) + (0x00 << 24);
 846:ProgrammingSteps.c **** 		
 847:ProgrammingSteps.c **** 		/* Load the write protection command to SRAM */
 848:ProgrammingSteps.c ****     	Write_IO (CPUSS_SYSARG, parameter1);
 1271              		.loc 1 848 0
 1272 009e 1C48     		ldr	r0, .L104+16
 1273 00a0 7968     		ldr	r1, [r7, #4]
 1274 00a2 FFF7FEFF 		bl	Write_IO
 849:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1275              		.loc 1 849 0
 1276 00a6 194B     		ldr	r3, .L104+12
 1277 00a8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1278 00aa 012B     		cmp	r3, #1
 1279 00ac 01D0     		beq	.L101
 850:ProgrammingSteps.c ****         {
 851:ProgrammingSteps.c ****             return(FAILURE);
 1280              		.loc 1 851 0
 1281 00ae 0023     		movs	r3, #0
 1282 00b0 22E0     		b	.L93
 1283              	.L101:
 852:ProgrammingSteps.c ****         }
 853:ProgrammingSteps.c ****     	
 854:ProgrammingSteps.c **** 		/* Request SROM call */
 855:ProgrammingSteps.c ****         Write_IO (CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1284              		.loc 1 855 0
 1285 00b2 1848     		ldr	r0, .L104+20
 1286 00b4 1A49     		ldr	r1, .L104+32
 1287 00b6 FFF7FEFF 		bl	Write_IO
 856:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1288              		.loc 1 856 0
 1289 00ba 144B     		ldr	r3, .L104+12
 1290 00bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1291 00be 012B     		cmp	r3, #1
 1292 00c0 01D0     		beq	.L102
 857:ProgrammingSteps.c ****         {
 858:ProgrammingSteps.c ****             return(FAILURE);
 1293              		.loc 1 858 0
 1294 00c2 0023     		movs	r3, #0
 1295 00c4 18E0     		b	.L93
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 39


 1296              	.L102:
 859:ProgrammingSteps.c ****         }
 860:ProgrammingSteps.c ****     	
 861:ProgrammingSteps.c **** 		/* Read status of the operation */
 862:ProgrammingSteps.c ****         result = PollSromStatus();
 1297              		.loc 1 862 0
 1298 00c6 FFF7FEFF 		bl	PollSromStatus
 1299 00ca 0346     		mov	r3, r0
 1300 00cc 1A46     		mov	r2, r3
 1301 00ce 0C4B     		ldr	r3, .L104
 1302 00d0 1A70     		strb	r2, [r3]
 863:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1303              		.loc 1 863 0
 1304 00d2 0B4B     		ldr	r3, .L104
 1305 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1306 00d6 012B     		cmp	r3, #1
 1307 00d8 01D0     		beq	.L103
 864:ProgrammingSteps.c ****         {
 865:ProgrammingSteps.c ****             return(FAILURE);
 1308              		.loc 1 865 0
 1309 00da 0023     		movs	r3, #0
 1310 00dc 0CE0     		b	.L93
 1311              	.L103:
 866:ProgrammingSteps.c ****         }
 867:ProgrammingSteps.c **** 		
 868:ProgrammingSteps.c **** 		/* Re-acquire chip in OPEN mode */
 869:ProgrammingSteps.c ****     	result = DeviceAcquire();
 1312              		.loc 1 869 0
 1313 00de FFF7FEFF 		bl	DeviceAcquire
 1314 00e2 0346     		mov	r3, r0
 1315 00e4 1A46     		mov	r2, r3
 1316 00e6 064B     		ldr	r3, .L104
 1317 00e8 1A70     		strb	r2, [r3]
 870:ProgrammingSteps.c ****     	if( result != SUCCESS )
 1318              		.loc 1 870 0
 1319 00ea 054B     		ldr	r3, .L104
 1320 00ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1321 00ee 012B     		cmp	r3, #1
 1322 00f0 01D0     		beq	.L100
 871:ProgrammingSteps.c ****         {
 872:ProgrammingSteps.c ****             return(FAILURE);
 1323              		.loc 1 872 0
 1324 00f2 0023     		movs	r3, #0
 1325 00f4 00E0     		b	.L93
 1326              	.L100:
 873:ProgrammingSteps.c ****         }
 874:ProgrammingSteps.c ****     }
 875:ProgrammingSteps.c ****     
 876:ProgrammingSteps.c ****     return (SUCCESS);
 1327              		.loc 1 876 0
 1328 00f6 0123     		movs	r3, #1
 1329              	.L93:
 877:ProgrammingSteps.c **** }
 1330              		.loc 1 877 0
 1331 00f8 1846     		mov	r0, r3
 1332 00fa 0837     		adds	r7, r7, #8
 1333              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 40


 1334 00fc BD46     		mov	sp, r7
 1335              		.cfi_def_cfa_register 13
 1336              		@ sp needed
 1337 00fe 80BD     		pop	{r7, pc}
 1338              	.L105:
 1339              		.align	2
 1340              	.L104:
 1341 0100 00000000 		.word	result
 1342 0104 00000000 		.word	flow
 1343 0108 00010020 		.word	536871168
 1344 010c 00000000 		.word	swd_PacketAck
 1345 0110 08001040 		.word	1074790408
 1346 0114 04001040 		.word	1074790404
 1347 0118 0A000080 		.word	-2147483638
 1348 011c B6E00100 		.word	123062
 1349 0120 0D000080 		.word	-2147483635
 1350              		.cfi_endproc
 1351              	.LFE71:
 1352              		.size	EraseAllFlash, .-EraseAllFlash
 1353              		.section	.text.ChecksumPrivileged,"ax",%progbits
 1354              		.align	2
 1355              		.global	ChecksumPrivileged
 1356              		.thumb
 1357              		.thumb_func
 1358              		.type	ChecksumPrivileged, %function
 1359              	ChecksumPrivileged:
 1360              	.LFB72:
 878:ProgrammingSteps.c **** 
 879:ProgrammingSteps.c **** /******************************************************************************
 880:ProgrammingSteps.c **** * Function Name: ChecksumPrivileged
 881:ProgrammingSteps.c **** *******************************************************************************
 882:ProgrammingSteps.c **** *
 883:ProgrammingSteps.c **** * Summary:
 884:ProgrammingSteps.c **** *  This is Step 4 of the programming sequence. In this Step, checksum of the 
 885:ProgrammingSteps.c **** *  privileged rows is calulated using system call to determine checksum. This 
 886:ProgrammingSteps.c **** *  step uses ChecksumAPI() API to store the checksum of privileged rows in a 
 887:ProgrammingSteps.c **** *  Checksum_Privileged global variable. This variable is used in step 9 to
 888:ProgrammingSteps.c **** *  calculate the checksum of user rows.
 889:ProgrammingSteps.c **** *
 890:ProgrammingSteps.c **** * Parameters:
 891:ProgrammingSteps.c **** *  None
 892:ProgrammingSteps.c **** *
 893:ProgrammingSteps.c **** * Return:
 894:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully calculated the checksum 
 895:ProgrammingSteps.c **** *            of privileged rows.
 896:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 897:ProgrammingSteps.c **** *			 message.
 898:ProgrammingSteps.c **** *
 899:ProgrammingSteps.c **** * Note:
 900:ProgrammingSteps.c **** *
 901:ProgrammingSteps.c **** ******************************************************************************/
 902:ProgrammingSteps.c **** unsigned char ChecksumPrivileged()
 903:ProgrammingSteps.c **** {        
 1361              		.loc 1 903 0
 1362              		.cfi_startproc
 1363              		@ args = 0, pretend = 0, frame = 0
 1364              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 41


 1365 0000 80B5     		push	{r7, lr}
 1366              		.cfi_def_cfa_offset 8
 1367              		.cfi_offset 7, -8
 1368              		.cfi_offset 14, -4
 1369 0002 00AF     		add	r7, sp, #0
 1370              		.cfi_def_cfa_register 7
 904:ProgrammingSteps.c ****     result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_Privileged);
 1371              		.loc 1 904 0
 1372 0004 4FF40040 		mov	r0, #32768
 1373 0008 0749     		ldr	r1, .L109
 1374 000a FFF7FEFF 		bl	ChecksumAPI
 1375 000e 0346     		mov	r3, r0
 1376 0010 1A46     		mov	r2, r3
 1377 0012 064B     		ldr	r3, .L109+4
 1378 0014 1A70     		strb	r2, [r3]
 905:ProgrammingSteps.c **** 	if (result != SUCCESS)
 1379              		.loc 1 905 0
 1380 0016 054B     		ldr	r3, .L109+4
 1381 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1382 001a 012B     		cmp	r3, #1
 1383 001c 01D0     		beq	.L107
 906:ProgrammingSteps.c **** 	{
 907:ProgrammingSteps.c **** 		return (FAILURE);
 1384              		.loc 1 907 0
 1385 001e 0023     		movs	r3, #0
 1386 0020 00E0     		b	.L108
 1387              	.L107:
 908:ProgrammingSteps.c **** 	}
 909:ProgrammingSteps.c **** 	return(SUCCESS);
 1388              		.loc 1 909 0
 1389 0022 0123     		movs	r3, #1
 1390              	.L108:
 910:ProgrammingSteps.c **** }
 1391              		.loc 1 910 0
 1392 0024 1846     		mov	r0, r3
 1393 0026 80BD     		pop	{r7, pc}
 1394              	.L110:
 1395              		.align	2
 1396              	.L109:
 1397 0028 00000000 		.word	checksum_Privileged
 1398 002c 00000000 		.word	result
 1399              		.cfi_endproc
 1400              	.LFE72:
 1401              		.size	ChecksumPrivileged, .-ChecksumPrivileged
 1402              		.section	.text.ProgramFlash,"ax",%progbits
 1403              		.align	2
 1404              		.global	ProgramFlash
 1405              		.thumb
 1406              		.thumb_func
 1407              		.type	ProgramFlash, %function
 1408              	ProgramFlash:
 1409              	.LFB73:
 911:ProgrammingSteps.c **** 
 912:ProgrammingSteps.c **** /******************************************************************************
 913:ProgrammingSteps.c **** * Function Name: ProgramFlash
 914:ProgrammingSteps.c **** *******************************************************************************
 915:ProgrammingSteps.c **** *
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 42


 916:ProgrammingSteps.c **** * Summary:
 917:ProgrammingSteps.c **** *  This is Step 5 of the programming sequence. In this Step, the whole user 
 918:ProgrammingSteps.c **** *  flash is re-programmed with the programming data in the HEX File. This 
 919:ProgrammingSteps.c **** *  function uses LoadLatch() API to latch the row data in SRAM page latch buffer
 920:ProgrammingSteps.c **** *  which is then programmed to the specific row using system calls to program
 921:ProgrammingSteps.c **** *  row.
 922:ProgrammingSteps.c **** *
 923:ProgrammingSteps.c **** * Parameters:
 924:ProgrammingSteps.c **** *  None
 925:ProgrammingSteps.c **** *
 926:ProgrammingSteps.c **** * Return:
 927:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully programs entire flash
 928:ProgrammingSteps.c **** *			 region.
 929:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
 930:ProgrammingSteps.c **** *			 message.
 931:ProgrammingSteps.c **** *
 932:ProgrammingSteps.c **** * Note:
 933:ProgrammingSteps.c **** * 
 934:ProgrammingSteps.c **** ******************************************************************************/
 935:ProgrammingSteps.c **** unsigned char ProgramFlash(void)
 936:ProgrammingSteps.c **** {
 1410              		.loc 1 936 0
 1411              		.cfi_startproc
 1412              		@ args = 0, pretend = 0, frame = 272
 1413              		@ frame_needed = 1, uses_anonymous_args = 0
 1414 0000 80B5     		push	{r7, lr}
 1415              		.cfi_def_cfa_offset 8
 1416              		.cfi_offset 7, -8
 1417              		.cfi_offset 14, -4
 1418 0002 C4B0     		sub	sp, sp, #272
 1419              		.cfi_def_cfa_offset 280
 1420 0004 00AF     		add	r7, sp, #0
 1421              		.cfi_def_cfa_register 7
 937:ProgrammingSteps.c **** 	unsigned char arrayID			= 0;
 1422              		.loc 1 937 0
 1423 0006 0023     		movs	r3, #0
 1424 0008 87F80D31 		strb	r3, [r7, #269]
 938:ProgrammingSteps.c **** 	unsigned char rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
 939:ProgrammingSteps.c **** 	
 940:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1425              		.loc 1 940 0
 1426 000c 0023     		movs	r3, #0
 1427 000e A7F80A31 		strh	r3, [r7, #266]	@ movhi
 941:ProgrammingSteps.c ****     unsigned short rowCount			= 0;
 1428              		.loc 1 941 0
 1429 0012 0023     		movs	r3, #0
 1430 0014 A7F80E31 		strh	r3, [r7, #270]	@ movhi
 942:ProgrammingSteps.c **** 	
 943:ProgrammingSteps.c **** 	unsigned long parameter1 		= 0;
 1431              		.loc 1 943 0
 1432 0018 0023     		movs	r3, #0
 1433 001a C7F80431 		str	r3, [r7, #260]
 944:ProgrammingSteps.c **** 	
 945:ProgrammingSteps.c ****     /* Get the total number of flash rows in the Target PSoC 4 device */
 946:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1434              		.loc 1 946 0
 1435 001e FFF7FEFF 		bl	GetFlashRowCount
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 43


 1436 0022 0346     		mov	r3, r0
 1437 0024 A7F80A31 		strh	r3, [r7, #266]	@ movhi
 947:ProgrammingSteps.c ****            
 948:ProgrammingSteps.c **** 	/* Program all flash rows */
 949:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1438              		.loc 1 949 0
 1439 0028 0023     		movs	r3, #0
 1440 002a A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1441 002e 5EE0     		b	.L112
 1442              	.L119:
 950:ProgrammingSteps.c **** 	{
 951:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1443              		.loc 1 951 0
 1444 0030 B7F80E21 		ldrh	r2, [r7, #270]
 1445 0034 3B1D     		adds	r3, r7, #4
 1446 0036 1046     		mov	r0, r2
 1447 0038 1946     		mov	r1, r3
 1448 003a FFF7FEFF 		bl	HEX_ReadRowData
 952:ProgrammingSteps.c **** 		
 953:ProgrammingSteps.c **** 		arrayID = rowCount/ROWS_PER_ARRAY;
 1449              		.loc 1 953 0
 1450 003e B7F80E31 		ldrh	r3, [r7, #270]
 1451 0042 5B0A     		lsrs	r3, r3, #9
 1452 0044 9BB2     		uxth	r3, r3
 1453 0046 87F80D31 		strb	r3, [r7, #269]
 954:ProgrammingSteps.c **** 		
 955:ProgrammingSteps.c **** 		result = LoadLatch(arrayID, &rowData[0], FLASH_ROW_BYTE_SIZE_HEX_FILE);
 1454              		.loc 1 955 0
 1455 004a 97F80D21 		ldrb	r2, [r7, #269]	@ zero_extendqisi2
 1456 004e 3B1D     		adds	r3, r7, #4
 1457 0050 1046     		mov	r0, r2
 1458 0052 1946     		mov	r1, r3
 1459 0054 4FF48072 		mov	r2, #256
 1460 0058 FFF7FEFF 		bl	LoadLatch
 1461 005c 0346     		mov	r3, r0
 1462 005e 1A46     		mov	r2, r3
 1463 0060 294B     		ldr	r3, .L121
 1464 0062 1A70     		strb	r2, [r3]
 956:ProgrammingSteps.c **** 		if(result != SUCCESS)
 1465              		.loc 1 956 0
 1466 0064 284B     		ldr	r3, .L121
 1467 0066 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1468 0068 012B     		cmp	r3, #1
 1469 006a 01D0     		beq	.L113
 957:ProgrammingSteps.c **** 		{
 958:ProgrammingSteps.c **** 			return(FAILURE);
 1470              		.loc 1 958 0
 1471 006c 0023     		movs	r3, #0
 1472 006e 45E0     		b	.L120
 1473              	.L113:
 959:ProgrammingSteps.c **** 		}
 960:ProgrammingSteps.c **** 
 961:ProgrammingSteps.c **** 	    /* Load parameter1 with Program Row - SROM command */
 962:ProgrammingSteps.c **** 	    parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) + //
 963:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 964:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x000000FF) <<  16) +	//
 1474              		.loc 1 964 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 44


 1475 0070 B7F80E31 		ldrh	r3, [r7, #270]
 1476 0074 DBB2     		uxtb	r3, r3
 1477 0076 1A04     		lsls	r2, r3, #16
 965:ProgrammingSteps.c **** 					(((unsigned long)rowCount & 0x0000FF00) << 16));
 1478              		.loc 1 965 0
 1479 0078 B7F80E31 		ldrh	r3, [r7, #270]
 1480 007c 03F47F43 		and	r3, r3, #65280
 1481 0080 1B04     		lsls	r3, r3, #16
 962:ProgrammingSteps.c **** 					(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_PROGRAM_ROW) << 8) + //
 1482              		.loc 1 962 0
 1483 0082 1344     		add	r3, r3, r2
 1484 0084 03F55943 		add	r3, r3, #55552
 1485 0088 B633     		adds	r3, r3, #182
 1486 008a C7F80431 		str	r3, [r7, #260]
 966:ProgrammingSteps.c ****         
 967:ProgrammingSteps.c **** 		/* Write parameters in SRAM */
 968:ProgrammingSteps.c **** 	    Write_IO(SRAM_PARAMS_BASE+0x00, parameter1);
 1487              		.loc 1 968 0
 1488 008e 1F48     		ldr	r0, .L121+4
 1489 0090 D7F80411 		ldr	r1, [r7, #260]
 1490 0094 FFF7FEFF 		bl	Write_IO
 969:ProgrammingSteps.c **** 	   	if( swd_PacketAck != SWD_OK_ACK )
 1491              		.loc 1 969 0
 1492 0098 1D4B     		ldr	r3, .L121+8
 1493 009a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1494 009c 012B     		cmp	r3, #1
 1495 009e 01D0     		beq	.L115
 970:ProgrammingSteps.c **** 	    {
 971:ProgrammingSteps.c **** 	        return (FAILURE);
 1496              		.loc 1 971 0
 1497 00a0 0023     		movs	r3, #0
 1498 00a2 2BE0     		b	.L120
 1499              	.L115:
 972:ProgrammingSteps.c **** 	    }
 973:ProgrammingSteps.c **** 	    
 974:ProgrammingSteps.c **** 		/* Set location of parameters */
 975:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSARG, SRAM_PARAMS_BASE);
 1500              		.loc 1 975 0
 1501 00a4 1B48     		ldr	r0, .L121+12
 1502 00a6 1949     		ldr	r1, .L121+4
 1503 00a8 FFF7FEFF 		bl	Write_IO
 976:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1504              		.loc 1 976 0
 1505 00ac 184B     		ldr	r3, .L121+8
 1506 00ae 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1507 00b0 012B     		cmp	r3, #1
 1508 00b2 01D0     		beq	.L116
 977:ProgrammingSteps.c **** 	    {
 978:ProgrammingSteps.c **** 	        return (FAILURE);
 1509              		.loc 1 978 0
 1510 00b4 0023     		movs	r3, #0
 1511 00b6 21E0     		b	.L120
 1512              	.L116:
 979:ProgrammingSteps.c **** 	    }
 980:ProgrammingSteps.c **** 	    
 981:ProgrammingSteps.c **** 		/* Request SROM operation */
 982:ProgrammingSteps.c **** 		Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_PROGRAM_ROW);
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 45


 1513              		.loc 1 982 0
 1514 00b8 1748     		ldr	r0, .L121+16
 1515 00ba 1849     		ldr	r1, .L121+20
 1516 00bc FFF7FEFF 		bl	Write_IO
 983:ProgrammingSteps.c **** 		if( swd_PacketAck != SWD_OK_ACK )
 1517              		.loc 1 983 0
 1518 00c0 134B     		ldr	r3, .L121+8
 1519 00c2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1520 00c4 012B     		cmp	r3, #1
 1521 00c6 01D0     		beq	.L117
 984:ProgrammingSteps.c **** 	    {
 985:ProgrammingSteps.c **** 	        return (FAILURE);
 1522              		.loc 1 985 0
 1523 00c8 0023     		movs	r3, #0
 1524 00ca 17E0     		b	.L120
 1525              	.L117:
 986:ProgrammingSteps.c **** 	    }
 987:ProgrammingSteps.c **** 	    
 988:ProgrammingSteps.c **** 		/* Read status of the operation */
 989:ProgrammingSteps.c **** 	    result = PollSromStatus();
 1526              		.loc 1 989 0
 1527 00cc FFF7FEFF 		bl	PollSromStatus
 1528 00d0 0346     		mov	r3, r0
 1529 00d2 1A46     		mov	r2, r3
 1530 00d4 0C4B     		ldr	r3, .L121
 1531 00d6 1A70     		strb	r2, [r3]
 990:ProgrammingSteps.c **** 	    if ( result != SROM_SUCCESS )
 1532              		.loc 1 990 0
 1533 00d8 0B4B     		ldr	r3, .L121
 1534 00da 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1535 00dc 012B     		cmp	r3, #1
 1536 00de 01D0     		beq	.L118
 991:ProgrammingSteps.c ****         {
 992:ProgrammingSteps.c ****             return (FAILURE);
 1537              		.loc 1 992 0
 1538 00e0 0023     		movs	r3, #0
 1539 00e2 0BE0     		b	.L120
 1540              	.L118:
 949:ProgrammingSteps.c **** 	{
 1541              		.loc 1 949 0 discriminator 2
 1542 00e4 B7F80E31 		ldrh	r3, [r7, #270]
 1543 00e8 0133     		adds	r3, r3, #1
 1544 00ea A7F80E31 		strh	r3, [r7, #270]	@ movhi
 1545              	.L112:
 949:ProgrammingSteps.c **** 	{
 1546              		.loc 1 949 0 is_stmt 0 discriminator 1
 1547 00ee B7F80E21 		ldrh	r2, [r7, #270]
 1548 00f2 B7F80A31 		ldrh	r3, [r7, #266]
 1549 00f6 9A42     		cmp	r2, r3
 1550 00f8 9AD3     		bcc	.L119
 993:ProgrammingSteps.c ****         }
 994:ProgrammingSteps.c ****         
 995:ProgrammingSteps.c **** 	}
 996:ProgrammingSteps.c **** 	return ( SUCCESS );
 1551              		.loc 1 996 0 is_stmt 1
 1552 00fa 0123     		movs	r3, #1
 1553              	.L120:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 46


 997:ProgrammingSteps.c **** }
 1554              		.loc 1 997 0 discriminator 1
 1555 00fc 1846     		mov	r0, r3
 1556 00fe 07F58877 		add	r7, r7, #272
 1557              		.cfi_def_cfa_offset 8
 1558 0102 BD46     		mov	sp, r7
 1559              		.cfi_def_cfa_register 13
 1560              		@ sp needed
 1561 0104 80BD     		pop	{r7, pc}
 1562              	.L122:
 1563 0106 00BF     		.align	2
 1564              	.L121:
 1565 0108 00000000 		.word	result
 1566 010c 00010020 		.word	536871168
 1567 0110 00000000 		.word	swd_PacketAck
 1568 0114 08001040 		.word	1074790408
 1569 0118 04001040 		.word	1074790404
 1570 011c 06000080 		.word	-2147483642
 1571              		.cfi_endproc
 1572              	.LFE73:
 1573              		.size	ProgramFlash, .-ProgramFlash
 1574              		.section	.text.VerifyFlash,"ax",%progbits
 1575              		.align	2
 1576              		.global	VerifyFlash
 1577              		.thumb
 1578              		.thumb_func
 1579              		.type	VerifyFlash, %function
 1580              	VerifyFlash:
 1581              	.LFB74:
 998:ProgrammingSteps.c **** 
 999:ProgrammingSteps.c **** /******************************************************************************
1000:ProgrammingSteps.c **** * Function Name: VerifyFlash
1001:ProgrammingSteps.c **** *******************************************************************************
1002:ProgrammingSteps.c **** *
1003:ProgrammingSteps.c **** * Summary:
1004:ProgrammingSteps.c **** *  This is Step 6 of the programming sequence. This is an optional step as we
1005:ProgrammingSteps.c **** *  verify the checksum explicitly. In this Step, flash region is directly read
1006:ProgrammingSteps.c **** *  using Read_IO API defined in SWD_UpperPacketLayer.h and compared with the 
1007:ProgrammingSteps.c **** *  HEX File.
1008:ProgrammingSteps.c **** *
1009:ProgrammingSteps.c **** * Parameters:
1010:ProgrammingSteps.c **** *  None
1011:ProgrammingSteps.c **** *
1012:ProgrammingSteps.c **** * Return:
1013:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the entire flash
1014:ProgrammingSteps.c **** *		     with the HEX File.
1015:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1016:ProgrammingSteps.c **** *			 message.
1017:ProgrammingSteps.c **** *
1018:ProgrammingSteps.c **** * Note:
1019:ProgrammingSteps.c **** * 
1020:ProgrammingSteps.c **** *******************************************************************************************/
1021:ProgrammingSteps.c **** unsigned char VerifyFlash(void)
1022:ProgrammingSteps.c **** { 
 1582              		.loc 1 1022 0
 1583              		.cfi_startproc
 1584              		@ args = 0, pretend = 0, frame = 528
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 47


 1585              		@ frame_needed = 1, uses_anonymous_args = 0
 1586 0000 80B5     		push	{r7, lr}
 1587              		.cfi_def_cfa_offset 8
 1588              		.cfi_offset 7, -8
 1589              		.cfi_offset 14, -4
 1590 0002 ADF5047D 		sub	sp, sp, #528
 1591              		.cfi_def_cfa_offset 536
 1592 0006 00AF     		add	r7, sp, #0
 1593              		.cfi_def_cfa_register 7
1023:ProgrammingSteps.c ****     unsigned long  flashData 		= 0;    
 1594              		.loc 1 1023 0
 1595 0008 0023     		movs	r3, #0
 1596 000a C7F80032 		str	r3, [r7, #512]
1024:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 	= 0;
 1597              		.loc 1 1024 0
 1598 000e 0023     		movs	r3, #0
 1599 0010 A7F80A32 		strh	r3, [r7, #522]	@ movhi
1025:ProgrammingSteps.c **** 	unsigned long rowAddress 		= 0;
 1600              		.loc 1 1025 0
 1601 0014 0023     		movs	r3, #0
 1602 0016 C7F80432 		str	r3, [r7, #516]
1026:ProgrammingSteps.c ****     unsigned short rowCount;
1027:ProgrammingSteps.c ****     unsigned short  i;
1028:ProgrammingSteps.c ****     unsigned char  rowData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1029:ProgrammingSteps.c **** 	unsigned char  chipData[FLASH_ROW_BYTE_SIZE_HEX_FILE];
1030:ProgrammingSteps.c **** 	
1031:ProgrammingSteps.c **** 	/* Get the total number of flash rows in the Target PSoC 4 device */
1032:ProgrammingSteps.c **** 	numOfFlashRows   = GetFlashRowCount();
 1603              		.loc 1 1032 0
 1604 001a FFF7FEFF 		bl	GetFlashRowCount
 1605 001e 0346     		mov	r3, r0
 1606 0020 A7F80A32 		strh	r3, [r7, #522]	@ movhi
1033:ProgrammingSteps.c **** 
1034:ProgrammingSteps.c **** 	/* Read and Verify Flash rows */
1035:ProgrammingSteps.c **** 	for ( rowCount = 0; rowCount < numOfFlashRows; rowCount++)
 1607              		.loc 1 1035 0
 1608 0024 0023     		movs	r3, #0
 1609 0026 A7F80E32 		strh	r3, [r7, #526]	@ movhi
 1610 002a 72E0     		b	.L124
 1611              	.L132:
1036:ProgrammingSteps.c **** 	{
1037:ProgrammingSteps.c **** 		/* Read row from hex file */
1038:ProgrammingSteps.c **** 		
1039:ProgrammingSteps.c **** 		/* linear address of row in flash */
1040:ProgrammingSteps.c ****     	rowAddress = FLASH_ROW_BYTE_SIZE_HEX_FILE * rowCount;
 1612              		.loc 1 1040 0
 1613 002c B7F80E32 		ldrh	r3, [r7, #526]
 1614 0030 1B02     		lsls	r3, r3, #8
 1615 0032 C7F80432 		str	r3, [r7, #516]
1041:ProgrammingSteps.c ****     	
1042:ProgrammingSteps.c **** 		/* Extract 128-byte row from the hex-file from address: rowCount into
1043:ProgrammingSteps.c **** 		   buffer - rowData. */
1044:ProgrammingSteps.c **** 		HEX_ReadRowData( rowCount, &rowData[0] );
 1616              		.loc 1 1044 0
 1617 0036 B7F80E22 		ldrh	r2, [r7, #526]
 1618 003a 07F58073 		add	r3, r7, #256
 1619 003e 1046     		mov	r0, r2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 48


 1620 0040 1946     		mov	r1, r3
 1621 0042 FFF7FEFF 		bl	HEX_ReadRowData
1045:ProgrammingSteps.c **** 
1046:ProgrammingSteps.c ****     	/* Read row from chip */
1047:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i += 4)
 1622              		.loc 1 1047 0
 1623 0046 0023     		movs	r3, #0
 1624 0048 A7F80C32 		strh	r3, [r7, #524]	@ movhi
 1625 004c 37E0     		b	.L125
 1626              	.L128:
1048:ProgrammingSteps.c ****     	{
1049:ProgrammingSteps.c **** 			/* Read flash via AHB-interface */
1050:ProgrammingSteps.c ****        		Read_IO( rowAddress + i, &flashData);
 1627              		.loc 1 1050 0
 1628 004e B7F80C22 		ldrh	r2, [r7, #524]
 1629 0052 D7F80432 		ldr	r3, [r7, #516]
 1630 0056 1A44     		add	r2, r2, r3
 1631 0058 07F50073 		add	r3, r7, #512
 1632 005c 1046     		mov	r0, r2
 1633 005e 1946     		mov	r1, r3
 1634 0060 FFF7FEFF 		bl	Read_IO
1051:ProgrammingSteps.c ****             if( swd_PacketAck != SWD_OK_ACK )
 1635              		.loc 1 1051 0
 1636 0064 314B     		ldr	r3, .L134
 1637 0066 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1638 0068 012B     		cmp	r3, #1
 1639 006a 01D0     		beq	.L126
1052:ProgrammingSteps.c ****     	    {
1053:ProgrammingSteps.c ****     	        return (FAILURE);
 1640              		.loc 1 1053 0
 1641 006c 0023     		movs	r3, #0
 1642 006e 57E0     		b	.L133
 1643              	.L126:
1054:ProgrammingSteps.c ****     	    }
1055:ProgrammingSteps.c ****             
1056:ProgrammingSteps.c ****             chipData[i + 0] = (flashData >> 0) & 0xFF;
 1644              		.loc 1 1056 0 discriminator 2
 1645 0070 B7F80C32 		ldrh	r3, [r7, #524]
 1646 0074 D7F80022 		ldr	r2, [r7, #512]
 1647 0078 D1B2     		uxtb	r1, r2
 1648 007a 3A46     		mov	r2, r7
 1649 007c D154     		strb	r1, [r2, r3]
1057:ProgrammingSteps.c ****             chipData[i + 1] = (flashData >> 8) & 0xFF;
 1650              		.loc 1 1057 0 discriminator 2
 1651 007e B7F80C32 		ldrh	r3, [r7, #524]
 1652 0082 0133     		adds	r3, r3, #1
 1653 0084 D7F80022 		ldr	r2, [r7, #512]
 1654 0088 120A     		lsrs	r2, r2, #8
 1655 008a D1B2     		uxtb	r1, r2
 1656 008c 3A46     		mov	r2, r7
 1657 008e D154     		strb	r1, [r2, r3]
1058:ProgrammingSteps.c ****             chipData[i + 2] = (flashData >> 16) & 0xFF;
 1658              		.loc 1 1058 0 discriminator 2
 1659 0090 B7F80C32 		ldrh	r3, [r7, #524]
 1660 0094 0233     		adds	r3, r3, #2
 1661 0096 D7F80022 		ldr	r2, [r7, #512]
 1662 009a 120C     		lsrs	r2, r2, #16
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 49


 1663 009c D1B2     		uxtb	r1, r2
 1664 009e 3A46     		mov	r2, r7
 1665 00a0 D154     		strb	r1, [r2, r3]
1059:ProgrammingSteps.c ****             chipData[i + 3] = (flashData >> 24) & 0xFF;
 1666              		.loc 1 1059 0 discriminator 2
 1667 00a2 B7F80C32 		ldrh	r3, [r7, #524]
 1668 00a6 0333     		adds	r3, r3, #3
 1669 00a8 D7F80022 		ldr	r2, [r7, #512]
 1670 00ac 120E     		lsrs	r2, r2, #24
 1671 00ae D1B2     		uxtb	r1, r2
 1672 00b0 3A46     		mov	r2, r7
 1673 00b2 D154     		strb	r1, [r2, r3]
1047:ProgrammingSteps.c ****     	{
 1674              		.loc 1 1047 0 discriminator 2
 1675 00b4 B7F80C32 		ldrh	r3, [r7, #524]	@ movhi
 1676 00b8 0433     		adds	r3, r3, #4
 1677 00ba A7F80C32 		strh	r3, [r7, #524]	@ movhi
 1678              	.L125:
1047:ProgrammingSteps.c ****     	{
 1679              		.loc 1 1047 0 is_stmt 0 discriminator 1
 1680 00be B7F80C32 		ldrh	r3, [r7, #524]
 1681 00c2 FF2B     		cmp	r3, #255
 1682 00c4 C3D9     		bls	.L128
1060:ProgrammingSteps.c ****     	}
1061:ProgrammingSteps.c **** 
1062:ProgrammingSteps.c ****     	/* Compare the row data of HEX file with chip data */
1063:ProgrammingSteps.c ****     	for (i = 0; i < FLASH_ROW_BYTE_SIZE_HEX_FILE; i++)
 1683              		.loc 1 1063 0 is_stmt 1
 1684 00c6 0023     		movs	r3, #0
 1685 00c8 A7F80C32 		strh	r3, [r7, #524]	@ movhi
 1686 00cc 18E0     		b	.L129
 1687              	.L131:
1064:ProgrammingSteps.c ****     	{
1065:ProgrammingSteps.c ****        		if (chipData[i] != rowData[i])
 1688              		.loc 1 1065 0
 1689 00ce B7F80C32 		ldrh	r3, [r7, #524]
 1690 00d2 3A46     		mov	r2, r7
 1691 00d4 D25C     		ldrb	r2, [r2, r3]	@ zero_extendqisi2
 1692 00d6 B7F80C32 		ldrh	r3, [r7, #524]
 1693 00da 07F58071 		add	r1, r7, #256
 1694 00de CB5C     		ldrb	r3, [r1, r3]	@ zero_extendqisi2
 1695 00e0 9A42     		cmp	r2, r3
 1696 00e2 08D0     		beq	.L130
1066:ProgrammingSteps.c **** 			{
1067:ProgrammingSteps.c **** 				swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 1697              		.loc 1 1067 0
 1698 00e4 114B     		ldr	r3, .L134
 1699 00e6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1700 00e8 43F04003 		orr	r3, r3, #64
 1701 00ec DAB2     		uxtb	r2, r3
 1702 00ee 0F4B     		ldr	r3, .L134
 1703 00f0 1A70     		strb	r2, [r3]
1068:ProgrammingSteps.c **** 				return ( FAILURE );
 1704              		.loc 1 1068 0
 1705 00f2 0023     		movs	r3, #0
 1706 00f4 14E0     		b	.L133
 1707              	.L130:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 50


1063:ProgrammingSteps.c ****     	{
 1708              		.loc 1 1063 0 discriminator 2
 1709 00f6 B7F80C32 		ldrh	r3, [r7, #524]
 1710 00fa 0133     		adds	r3, r3, #1
 1711 00fc A7F80C32 		strh	r3, [r7, #524]	@ movhi
 1712              	.L129:
1063:ProgrammingSteps.c ****     	{
 1713              		.loc 1 1063 0 is_stmt 0 discriminator 1
 1714 0100 B7F80C32 		ldrh	r3, [r7, #524]
 1715 0104 FF2B     		cmp	r3, #255
 1716 0106 E2D9     		bls	.L131
1035:ProgrammingSteps.c **** 	{
 1717              		.loc 1 1035 0 is_stmt 1 discriminator 2
 1718 0108 B7F80E32 		ldrh	r3, [r7, #526]
 1719 010c 0133     		adds	r3, r3, #1
 1720 010e A7F80E32 		strh	r3, [r7, #526]	@ movhi
 1721              	.L124:
1035:ProgrammingSteps.c **** 	{
 1722              		.loc 1 1035 0 is_stmt 0 discriminator 1
 1723 0112 B7F80E22 		ldrh	r2, [r7, #526]
 1724 0116 B7F80A32 		ldrh	r3, [r7, #522]
 1725 011a 9A42     		cmp	r2, r3
 1726 011c 86D3     		bcc	.L132
1069:ProgrammingSteps.c **** 			}
1070:ProgrammingSteps.c ****     	}
1071:ProgrammingSteps.c **** 	}
1072:ProgrammingSteps.c **** 	return ( SUCCESS );
 1727              		.loc 1 1072 0 is_stmt 1
 1728 011e 0123     		movs	r3, #1
 1729              	.L133:
1073:ProgrammingSteps.c **** }
 1730              		.loc 1 1073 0 discriminator 1
 1731 0120 1846     		mov	r0, r3
 1732 0122 07F50477 		add	r7, r7, #528
 1733              		.cfi_def_cfa_offset 8
 1734 0126 BD46     		mov	sp, r7
 1735              		.cfi_def_cfa_register 13
 1736              		@ sp needed
 1737 0128 80BD     		pop	{r7, pc}
 1738              	.L135:
 1739 012a 00BF     		.align	2
 1740              	.L134:
 1741 012c 00000000 		.word	swd_PacketAck
 1742              		.cfi_endproc
 1743              	.LFE74:
 1744              		.size	VerifyFlash, .-VerifyFlash
 1745              		.section	.text.ProgramProtectionSettings,"ax",%progbits
 1746              		.align	2
 1747              		.global	ProgramProtectionSettings
 1748              		.thumb
 1749              		.thumb_func
 1750              		.type	ProgramProtectionSettings, %function
 1751              	ProgramProtectionSettings:
 1752              	.LFB75:
1074:ProgrammingSteps.c **** 
1075:ProgrammingSteps.c **** /******************************************************************************
1076:ProgrammingSteps.c **** * Function Name: ProgramProtectionSettings
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 51


1077:ProgrammingSteps.c **** *******************************************************************************
1078:ProgrammingSteps.c **** *
1079:ProgrammingSteps.c **** * Summary:
1080:ProgrammingSteps.c **** *  This is Step 7 of the programming sequence. In this step, Chip protection 
1081:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and 
1082:ProgrammingSteps.c **** *  programmed to the specific loctions in the flash.
1083:ProgrammingSteps.c **** *
1084:ProgrammingSteps.c **** * Parameters:
1085:ProgrammingSteps.c **** *  None
1086:ProgrammingSteps.c **** *
1087:ProgrammingSteps.c **** * Return:
1088:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully writes the protection
1089:ProgrammingSteps.c **** *			 settings.
1090:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1091:ProgrammingSteps.c **** *			 message.
1092:ProgrammingSteps.c **** *
1093:ProgrammingSteps.c **** * Note:
1094:ProgrammingSteps.c **** *
1095:ProgrammingSteps.c **** ******************************************************************************/
1096:ProgrammingSteps.c **** unsigned char ProgramProtectionSettings(void)
1097:ProgrammingSteps.c **** {
 1753              		.loc 1 1097 0
 1754              		.cfi_startproc
 1755              		@ args = 0, pretend = 0, frame = 80
 1756              		@ frame_needed = 1, uses_anonymous_args = 0
 1757 0000 80B5     		push	{r7, lr}
 1758              		.cfi_def_cfa_offset 8
 1759              		.cfi_offset 7, -8
 1760              		.cfi_offset 14, -4
 1761 0002 94B0     		sub	sp, sp, #80
 1762              		.cfi_def_cfa_offset 88
 1763 0004 00AF     		add	r7, sp, #0
 1764              		.cfi_def_cfa_register 7
1098:ProgrammingSteps.c **** 	unsigned char  arrayID = 0;
 1765              		.loc 1 1098 0
 1766 0006 0023     		movs	r3, #0
 1767 0008 87F84F30 		strb	r3, [r7, #79]
1099:ProgrammingSteps.c ****     unsigned char  arrayMax = 0;
 1768              		.loc 1 1099 0
 1769 000c 0023     		movs	r3, #0
 1770 000e 87F84E30 		strb	r3, [r7, #78]
1100:ProgrammingSteps.c ****     unsigned char  rowProtectionByteSize = 0;
 1771              		.loc 1 1100 0
 1772 0012 0023     		movs	r3, #0
 1773 0014 87F84D30 		strb	r3, [r7, #77]
1101:ProgrammingSteps.c **** 	unsigned char  rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
1102:ProgrammingSteps.c **** 	unsigned char  chipProtectionData_Hex;
1103:ProgrammingSteps.c **** 	
1104:ProgrammingSteps.c **** 	unsigned short numOfFlashRows = 0;
 1774              		.loc 1 1104 0
 1775 0018 0023     		movs	r3, #0
 1776 001a A7F84A30 		strh	r3, [r7, #74]	@ movhi
1105:ProgrammingSteps.c **** 	
1106:ProgrammingSteps.c **** 	unsigned long parameter1 = 0;
 1777              		.loc 1 1106 0
 1778 001e 0023     		movs	r3, #0
 1779 0020 7B64     		str	r3, [r7, #68]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 52


1107:ProgrammingSteps.c **** 	
1108:ProgrammingSteps.c **** 	/* Get total number of flash rows to determine the size of row protection data
1109:ProgrammingSteps.c **** 	   and arrayID */
1110:ProgrammingSteps.c ****     numOfFlashRows   = GetFlashRowCount();
 1780              		.loc 1 1110 0
 1781 0022 FFF7FEFF 		bl	GetFlashRowCount
 1782 0026 0346     		mov	r3, r0
 1783 0028 A7F84A30 		strh	r3, [r7, #74]	@ movhi
1111:ProgrammingSteps.c ****     
1112:ProgrammingSteps.c **** 	arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 1784              		.loc 1 1112 0
 1785 002c B7F84A30 		ldrh	r3, [r7, #74]
 1786 0030 5B0A     		lsrs	r3, r3, #9
 1787 0032 9BB2     		uxth	r3, r3
 1788 0034 87F84E30 		strb	r3, [r7, #78]
1113:ProgrammingSteps.c ****     
1114:ProgrammingSteps.c ****     rowProtectionByteSize = numOfFlashRows / (8 * arrayMax);
 1789              		.loc 1 1114 0
 1790 0038 B7F84A20 		ldrh	r2, [r7, #74]
 1791 003c 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 1792 0040 DB00     		lsls	r3, r3, #3
 1793 0042 92FBF3F3 		sdiv	r3, r2, r3
 1794 0046 87F84D30 		strb	r3, [r7, #77]
1115:ProgrammingSteps.c **** 	
1116:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 1795              		.loc 1 1116 0
 1796 004a FB1C     		adds	r3, r7, #3
 1797 004c 1846     		mov	r0, r3
 1798 004e FFF7FEFF 		bl	HEX_ReadChipProtectionData
1117:ProgrammingSteps.c ****  
1118:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++)
 1799              		.loc 1 1118 0
 1800 0052 0023     		movs	r3, #0
 1801 0054 87F84F30 		strb	r3, [r7, #79]
 1802 0058 4DE0     		b	.L137
 1803              	.L143:
1119:ProgrammingSteps.c ****     {
1120:ProgrammingSteps.c ****         
1121:ProgrammingSteps.c ****         HEX_ReadRowProtectionData(rowProtectionByteSize, &rowProtectionData[0], arrayID);
 1804              		.loc 1 1121 0
 1805 005a 97F84D10 		ldrb	r1, [r7, #77]	@ zero_extendqisi2
 1806 005e 3A1D     		adds	r2, r7, #4
 1807 0060 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1808 0064 0846     		mov	r0, r1
 1809 0066 1146     		mov	r1, r2
 1810 0068 1A46     		mov	r2, r3
 1811 006a FFF7FEFF 		bl	HEX_ReadRowProtectionData
1122:ProgrammingSteps.c **** 
1123:ProgrammingSteps.c ****     	/* Load protection setting of current macro into volatile latch using 
1124:ProgrammingSteps.c ****     	   LoadLatch API */
1125:ProgrammingSteps.c ****     	result = LoadLatch(arrayID, &rowProtectionData[0], rowProtectionByteSize);
 1812              		.loc 1 1125 0
 1813 006e 97F84D30 		ldrb	r3, [r7, #77]	@ zero_extendqisi2
 1814 0072 9BB2     		uxth	r3, r3
 1815 0074 97F84F10 		ldrb	r1, [r7, #79]	@ zero_extendqisi2
 1816 0078 3A1D     		adds	r2, r7, #4
 1817 007a 0846     		mov	r0, r1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 53


 1818 007c 1146     		mov	r1, r2
 1819 007e 1A46     		mov	r2, r3
 1820 0080 FFF7FEFF 		bl	LoadLatch
 1821 0084 0346     		mov	r3, r0
 1822 0086 1A46     		mov	r2, r3
 1823 0088 204B     		ldr	r3, .L145
 1824 008a 1A70     		strb	r2, [r3]
1126:ProgrammingSteps.c ****     	
1127:ProgrammingSteps.c ****     	if (result != SUCCESS)
 1825              		.loc 1 1127 0
 1826 008c 1F4B     		ldr	r3, .L145
 1827 008e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1828 0090 012B     		cmp	r3, #1
 1829 0092 01D0     		beq	.L138
1128:ProgrammingSteps.c ****     	{
1129:ProgrammingSteps.c ****     		return(FAILURE);
 1830              		.loc 1 1129 0
 1831 0094 0023     		movs	r3, #0
 1832 0096 35E0     		b	.L144
 1833              	.L138:
1130:ProgrammingSteps.c ****     	}
1131:ProgrammingSteps.c **** 
1132:ProgrammingSteps.c ****     	/* Program protection setting into supervisory row */
1133:ProgrammingSteps.c ****     	parameter1 = (unsigned long)(((unsigned long)SROM_KEY1 << 0) +	//
1134:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
1135:ProgrammingSteps.c ****     				((unsigned long)chipProtectionData_Hex << 16) + ((unsigned long)arrayID << 24));
 1834              		.loc 1 1135 0
 1835 0098 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1836 009a 1A04     		lsls	r2, r3, #16
 1837 009c 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1838 00a0 1B06     		lsls	r3, r3, #24
1133:ProgrammingSteps.c ****     				(((unsigned long)SROM_KEY2 + (unsigned long)SROM_CMD_WRITE_PROTECTION) << 8) + //
 1839              		.loc 1 1133 0
 1840 00a2 1344     		add	r3, r3, r2
 1841 00a4 03F56043 		add	r3, r3, #57344
 1842 00a8 B633     		adds	r3, r3, #182
 1843 00aa 7B64     		str	r3, [r7, #68]
1136:ProgrammingSteps.c ****     	
1137:ProgrammingSteps.c ****     	/* Load parameter1 in CPUSS_SYSARG register */
1138:ProgrammingSteps.c ****     	Write_IO(CPUSS_SYSARG, parameter1);	    
 1844              		.loc 1 1138 0
 1845 00ac 1848     		ldr	r0, .L145+4
 1846 00ae 796C     		ldr	r1, [r7, #68]
 1847 00b0 FFF7FEFF 		bl	Write_IO
1139:ProgrammingSteps.c ****     	
1140:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1848              		.loc 1 1140 0
 1849 00b4 174B     		ldr	r3, .L145+8
 1850 00b6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1851 00b8 012B     		cmp	r3, #1
 1852 00ba 01D0     		beq	.L140
1141:ProgrammingSteps.c ****         {
1142:ProgrammingSteps.c ****             return (FAILURE);
 1853              		.loc 1 1142 0
 1854 00bc 0023     		movs	r3, #0
 1855 00be 21E0     		b	.L144
 1856              	.L140:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 54


1143:ProgrammingSteps.c ****         }
1144:ProgrammingSteps.c ****     	
1145:ProgrammingSteps.c ****     	/* Request SROM call */
1146:ProgrammingSteps.c ****         Write_IO(CPUSS_SYSREQ, SROM_SYSREQ_BIT | SROM_CMD_WRITE_PROTECTION);
 1857              		.loc 1 1146 0
 1858 00c0 1548     		ldr	r0, .L145+12
 1859 00c2 1649     		ldr	r1, .L145+16
 1860 00c4 FFF7FEFF 		bl	Write_IO
1147:ProgrammingSteps.c **** 
1148:ProgrammingSteps.c ****     	if( swd_PacketAck != SWD_OK_ACK )
 1861              		.loc 1 1148 0
 1862 00c8 124B     		ldr	r3, .L145+8
 1863 00ca 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1864 00cc 012B     		cmp	r3, #1
 1865 00ce 01D0     		beq	.L141
1149:ProgrammingSteps.c ****         {
1150:ProgrammingSteps.c ****             return (FAILURE);
 1866              		.loc 1 1150 0
 1867 00d0 0023     		movs	r3, #0
 1868 00d2 17E0     		b	.L144
 1869              	.L141:
1151:ProgrammingSteps.c ****         }
1152:ProgrammingSteps.c **** 
1153:ProgrammingSteps.c ****     	/* Read status of the operation */
1154:ProgrammingSteps.c ****     	result = PollSromStatus();
 1870              		.loc 1 1154 0
 1871 00d4 FFF7FEFF 		bl	PollSromStatus
 1872 00d8 0346     		mov	r3, r0
 1873 00da 1A46     		mov	r2, r3
 1874 00dc 0B4B     		ldr	r3, .L145
 1875 00de 1A70     		strb	r2, [r3]
1155:ProgrammingSteps.c **** 
1156:ProgrammingSteps.c ****     	if( result != SROM_SUCCESS )
 1876              		.loc 1 1156 0
 1877 00e0 0A4B     		ldr	r3, .L145
 1878 00e2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1879 00e4 012B     		cmp	r3, #1
 1880 00e6 01D0     		beq	.L142
1157:ProgrammingSteps.c ****         {
1158:ProgrammingSteps.c ****             return (FAILURE);
 1881              		.loc 1 1158 0
 1882 00e8 0023     		movs	r3, #0
 1883 00ea 0BE0     		b	.L144
 1884              	.L142:
1118:ProgrammingSteps.c ****     {
 1885              		.loc 1 1118 0 discriminator 2
 1886 00ec 97F84F30 		ldrb	r3, [r7, #79]	@ zero_extendqisi2
 1887 00f0 0133     		adds	r3, r3, #1
 1888 00f2 87F84F30 		strb	r3, [r7, #79]
 1889              	.L137:
1118:ProgrammingSteps.c ****     {
 1890              		.loc 1 1118 0 is_stmt 0 discriminator 1
 1891 00f6 97F84F20 		ldrb	r2, [r7, #79]	@ zero_extendqisi2
 1892 00fa 97F84E30 		ldrb	r3, [r7, #78]	@ zero_extendqisi2
 1893 00fe 9A42     		cmp	r2, r3
 1894 0100 ABD3     		bcc	.L143
1159:ProgrammingSteps.c ****         }
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 55


1160:ProgrammingSteps.c ****     
1161:ProgrammingSteps.c ****     }
1162:ProgrammingSteps.c **** 
1163:ProgrammingSteps.c **** 	return (SUCCESS);
 1895              		.loc 1 1163 0 is_stmt 1
 1896 0102 0123     		movs	r3, #1
 1897              	.L144:
1164:ProgrammingSteps.c **** }
 1898              		.loc 1 1164 0 discriminator 1
 1899 0104 1846     		mov	r0, r3
 1900 0106 5037     		adds	r7, r7, #80
 1901              		.cfi_def_cfa_offset 8
 1902 0108 BD46     		mov	sp, r7
 1903              		.cfi_def_cfa_register 13
 1904              		@ sp needed
 1905 010a 80BD     		pop	{r7, pc}
 1906              	.L146:
 1907              		.align	2
 1908              	.L145:
 1909 010c 00000000 		.word	result
 1910 0110 08001040 		.word	1074790408
 1911 0114 00000000 		.word	swd_PacketAck
 1912 0118 04001040 		.word	1074790404
 1913 011c 0D000080 		.word	-2147483635
 1914              		.cfi_endproc
 1915              	.LFE75:
 1916              		.size	ProgramProtectionSettings, .-ProgramProtectionSettings
 1917              		.section	.text.VerifyProtectionSettings,"ax",%progbits
 1918              		.align	2
 1919              		.global	VerifyProtectionSettings
 1920              		.thumb
 1921              		.thumb_func
 1922              		.type	VerifyProtectionSettings, %function
 1923              	VerifyProtectionSettings:
 1924              	.LFB76:
1165:ProgrammingSteps.c **** 
1166:ProgrammingSteps.c **** /******************************************************************************
1167:ProgrammingSteps.c **** * Function Name: VerifyProtectionSettings
1168:ProgrammingSteps.c **** *******************************************************************************
1169:ProgrammingSteps.c **** *
1170:ProgrammingSteps.c **** * Summary:
1171:ProgrammingSteps.c **** *  This is Step 8 of the programming sequence. In this step, Chip protection 
1172:ProgrammingSteps.c **** *  settings and Row Protection settings are read from the HEX file and verified 
1173:ProgrammingSteps.c **** *  with the protection settings programmed in flash.
1174:ProgrammingSteps.c **** *
1175:ProgrammingSteps.c **** * Parameters:
1176:ProgrammingSteps.c **** *  None
1177:ProgrammingSteps.c **** *
1178:ProgrammingSteps.c **** * Return:
1179:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the protection
1180:ProgrammingSteps.c **** *  			 settings.
1181:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1182:ProgrammingSteps.c **** *			 message.
1183:ProgrammingSteps.c **** *
1184:ProgrammingSteps.c **** * Note:
1185:ProgrammingSteps.c **** *
1186:ProgrammingSteps.c **** ******************************************************************************/
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 56


1187:ProgrammingSteps.c **** unsigned char VerifyProtectionSettings(void)
1188:ProgrammingSteps.c **** {
 1925              		.loc 1 1188 0
 1926              		.cfi_startproc
 1927              		@ args = 0, pretend = 0, frame = 152
 1928              		@ frame_needed = 1, uses_anonymous_args = 0
 1929 0000 80B5     		push	{r7, lr}
 1930              		.cfi_def_cfa_offset 8
 1931              		.cfi_offset 7, -8
 1932              		.cfi_offset 14, -4
 1933 0002 A6B0     		sub	sp, sp, #152
 1934              		.cfi_def_cfa_offset 160
 1935 0004 00AF     		add	r7, sp, #0
 1936              		.cfi_def_cfa_register 7
1189:ProgrammingSteps.c **** 	unsigned long protectionData 			= 0;
 1937              		.loc 1 1189 0
 1938 0006 0023     		movs	r3, #0
 1939 0008 C7F88830 		str	r3, [r7, #136]
1190:ProgrammingSteps.c **** 	unsigned long flashProtectionAddress 	= 0;
 1940              		.loc 1 1190 0
 1941 000c 0023     		movs	r3, #0
 1942 000e C7F89430 		str	r3, [r7, #148]
1191:ProgrammingSteps.c **** 	unsigned short numOfFlashRows 			= 0;
 1943              		.loc 1 1191 0
 1944 0012 0023     		movs	r3, #0
 1945 0014 A7F89030 		strh	r3, [r7, #144]	@ movhi
1192:ProgrammingSteps.c ****     unsigned char chipProtectionData_Hex 	= 0;
 1946              		.loc 1 1192 0
 1947 0018 0023     		movs	r3, #0
 1948 001a 87F88730 		strb	r3, [r7, #135]
1193:ProgrammingSteps.c **** 	unsigned char rowProtectionByteSize 	= 0;
 1949              		.loc 1 1193 0
 1950 001e 0023     		movs	r3, #0
 1951 0020 87F88F30 		strb	r3, [r7, #143]
1194:ProgrammingSteps.c **** 	unsigned char i;
1195:ProgrammingSteps.c ****     unsigned char rowProtectionData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];
1196:ProgrammingSteps.c ****     unsigned char rowProtectionFlashData[MAXIMUM_ROW_PROTECTION_BYTE_LENGTH];    
1197:ProgrammingSteps.c ****     unsigned char arrayID                   = 0;
 1952              		.loc 1 1197 0
 1953 0024 0023     		movs	r3, #0
 1954 0026 87F89230 		strb	r3, [r7, #146]
1198:ProgrammingSteps.c ****     unsigned char arrayMax                  = 0;
 1955              		.loc 1 1198 0
 1956 002a 0023     		movs	r3, #0
 1957 002c 87F88E30 		strb	r3, [r7, #142]
1199:ProgrammingSteps.c ****         
1200:ProgrammingSteps.c ****     numOfFlashRows = GetFlashRowCount();
 1958              		.loc 1 1200 0
 1959 0030 FFF7FEFF 		bl	GetFlashRowCount
 1960 0034 0346     		mov	r3, r0
 1961 0036 A7F89030 		strh	r3, [r7, #144]	@ movhi
1201:ProgrammingSteps.c ****     
1202:ProgrammingSteps.c ****     arrayMax = numOfFlashRows/ROWS_PER_ARRAY;
 1962              		.loc 1 1202 0
 1963 003a B7F89030 		ldrh	r3, [r7, #144]
 1964 003e 5B0A     		lsrs	r3, r3, #9
 1965 0040 9BB2     		uxth	r3, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 57


 1966 0042 87F88E30 		strb	r3, [r7, #142]
1203:ProgrammingSteps.c ****     
1204:ProgrammingSteps.c **** 	rowProtectionByteSize = numOfFlashRows/(8 * arrayMax);   
 1967              		.loc 1 1204 0
 1968 0046 B7F89020 		ldrh	r2, [r7, #144]
 1969 004a 97F88E30 		ldrb	r3, [r7, #142]	@ zero_extendqisi2
 1970 004e DB00     		lsls	r3, r3, #3
 1971 0050 92FBF3F3 		sdiv	r3, r2, r3
 1972 0054 87F88F30 		strb	r3, [r7, #143]
1205:ProgrammingSteps.c **** 
1206:ProgrammingSteps.c **** 	flashProtectionAddress = SFLASH_MACRO;
 1973              		.loc 1 1206 0
 1974 0058 6B4B     		ldr	r3, .L162
 1975 005a C7F89430 		str	r3, [r7, #148]
1207:ProgrammingSteps.c **** 	
1208:ProgrammingSteps.c ****     for (arrayID = 0; arrayID < arrayMax; arrayID++, flashProtectionAddress += FLASH_PROTECTION_ADD
 1976              		.loc 1 1208 0
 1977 005e 0023     		movs	r3, #0
 1978 0060 87F89230 		strb	r3, [r7, #146]
 1979 0064 8BE0     		b	.L148
 1980              	.L156:
1209:ProgrammingSteps.c ****     {
1210:ProgrammingSteps.c ****         /* Read Protection settings from hex-file */
1211:ProgrammingSteps.c **** 	    HEX_ReadRowProtectionData(rowProtectionByteSize,&rowProtectionData[0], arrayID);
 1981              		.loc 1 1211 0
 1982 0066 97F88F10 		ldrb	r1, [r7, #143]	@ zero_extendqisi2
 1983 006a 07F14402 		add	r2, r7, #68
 1984 006e 97F89230 		ldrb	r3, [r7, #146]	@ zero_extendqisi2
 1985 0072 0846     		mov	r0, r1
 1986 0074 1146     		mov	r1, r2
 1987 0076 1A46     		mov	r2, r3
 1988 0078 FFF7FEFF 		bl	HEX_ReadRowProtectionData
1212:ProgrammingSteps.c **** 	        
1213:ProgrammingSteps.c ****         /* Read Protection settings from silicon */
1214:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize;  i += 4)
 1989              		.loc 1 1214 0
 1990 007c 0023     		movs	r3, #0
 1991 007e 87F89330 		strb	r3, [r7, #147]
 1992 0082 43E0     		b	.L149
 1993              	.L152:
1215:ProgrammingSteps.c ****     	{
1216:ProgrammingSteps.c ****     		Read_IO(flashProtectionAddress + i, &protectionData);
 1994              		.loc 1 1216 0
 1995 0084 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 1996 0088 D7F89430 		ldr	r3, [r7, #148]
 1997 008c 1A44     		add	r2, r2, r3
 1998 008e 07F18803 		add	r3, r7, #136
 1999 0092 1046     		mov	r0, r2
 2000 0094 1946     		mov	r1, r3
 2001 0096 FFF7FEFF 		bl	Read_IO
1217:ProgrammingSteps.c ****     	    
1218:ProgrammingSteps.c ****     		if( swd_PacketAck != SWD_OK_ACK )
 2002              		.loc 1 1218 0
 2003 009a 5C4B     		ldr	r3, .L162+4
 2004 009c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2005 009e 012B     		cmp	r3, #1
 2006 00a0 01D0     		beq	.L150
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 58


1219:ProgrammingSteps.c ****     	    {
1220:ProgrammingSteps.c ****     	        return (FAILURE);
 2007              		.loc 1 1220 0
 2008 00a2 0023     		movs	r3, #0
 2009 00a4 ABE0     		b	.L161
 2010              	.L150:
1221:ProgrammingSteps.c ****     	    }
1222:ProgrammingSteps.c ****     		
1223:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 0] = (protectionData >> 0) & 0xFF;     
 2011              		.loc 1 1223 0 discriminator 2
 2012 00a6 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2013 00aa D7F88820 		ldr	r2, [r7, #136]
 2014 00ae D2B2     		uxtb	r2, r2
 2015 00b0 07F19801 		add	r1, r7, #152
 2016 00b4 0B44     		add	r3, r3, r1
 2017 00b6 03F8942C 		strb	r2, [r3, #-148]
1224:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 1] = (protectionData >> 8) & 0xFF;
 2018              		.loc 1 1224 0 discriminator 2
 2019 00ba 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2020 00be 0133     		adds	r3, r3, #1
 2021 00c0 D7F88820 		ldr	r2, [r7, #136]
 2022 00c4 120A     		lsrs	r2, r2, #8
 2023 00c6 D2B2     		uxtb	r2, r2
 2024 00c8 07F19801 		add	r1, r7, #152
 2025 00cc 0B44     		add	r3, r3, r1
 2026 00ce 03F8942C 		strb	r2, [r3, #-148]
1225:ProgrammingSteps.c ****     		rowProtectionFlashData[i + 2] = (protectionData >> 16) & 0xFF;
 2027              		.loc 1 1225 0 discriminator 2
 2028 00d2 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2029 00d6 0233     		adds	r3, r3, #2
 2030 00d8 D7F88820 		ldr	r2, [r7, #136]
 2031 00dc 120C     		lsrs	r2, r2, #16
 2032 00de D2B2     		uxtb	r2, r2
 2033 00e0 07F19801 		add	r1, r7, #152
 2034 00e4 0B44     		add	r3, r3, r1
 2035 00e6 03F8942C 		strb	r2, [r3, #-148]
1226:ProgrammingSteps.c ****     	    rowProtectionFlashData[i + 3] = (protectionData >> 24) & 0xFF;
 2036              		.loc 1 1226 0 discriminator 2
 2037 00ea 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2038 00ee 0333     		adds	r3, r3, #3
 2039 00f0 D7F88820 		ldr	r2, [r7, #136]
 2040 00f4 120E     		lsrs	r2, r2, #24
 2041 00f6 D2B2     		uxtb	r2, r2
 2042 00f8 07F19801 		add	r1, r7, #152
 2043 00fc 0B44     		add	r3, r3, r1
 2044 00fe 03F8942C 		strb	r2, [r3, #-148]
1214:ProgrammingSteps.c ****     	{
 2045              		.loc 1 1214 0 discriminator 2
 2046 0102 97F89330 		ldrb	r3, [r7, #147]
 2047 0106 0433     		adds	r3, r3, #4
 2048 0108 87F89330 		strb	r3, [r7, #147]
 2049              	.L149:
1214:ProgrammingSteps.c ****     	{
 2050              		.loc 1 1214 0 is_stmt 0 discriminator 1
 2051 010c 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 2052 0110 97F88F30 		ldrb	r3, [r7, #143]	@ zero_extendqisi2
 2053 0114 9A42     		cmp	r2, r3
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 59


 2054 0116 B5D3     		bcc	.L152
1227:ProgrammingSteps.c ****     	}
1228:ProgrammingSteps.c **** 
1229:ProgrammingSteps.c ****     	/* Compare hex and silicons data */
1230:ProgrammingSteps.c ****     	for (i = 0; i < rowProtectionByteSize; i++ )
 2055              		.loc 1 1230 0 is_stmt 1
 2056 0118 0023     		movs	r3, #0
 2057 011a 87F89330 		strb	r3, [r7, #147]
 2058 011e 1DE0     		b	.L153
 2059              	.L155:
1231:ProgrammingSteps.c ****     	{
1232:ProgrammingSteps.c ****     		if (rowProtectionData[i] != rowProtectionFlashData[i])
 2060              		.loc 1 1232 0
 2061 0120 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2062 0124 07F19802 		add	r2, r7, #152
 2063 0128 1344     		add	r3, r3, r2
 2064 012a 13F8542C 		ldrb	r2, [r3, #-84]	@ zero_extendqisi2
 2065 012e 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2066 0132 07F19801 		add	r1, r7, #152
 2067 0136 0B44     		add	r3, r3, r1
 2068 0138 13F8943C 		ldrb	r3, [r3, #-148]	@ zero_extendqisi2
 2069 013c 9A42     		cmp	r2, r3
 2070 013e 08D0     		beq	.L154
1233:ProgrammingSteps.c ****     		{
1234:ProgrammingSteps.c ****                 /* Set the verification error bit for Flash protection data
1235:ProgrammingSteps.c ****     			   mismatch and return failure */
1236:ProgrammingSteps.c ****                 swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2071              		.loc 1 1236 0
 2072 0140 324B     		ldr	r3, .L162+4
 2073 0142 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2074 0144 43F04003 		orr	r3, r3, #64
 2075 0148 DAB2     		uxtb	r2, r3
 2076 014a 304B     		ldr	r3, .L162+4
 2077 014c 1A70     		strb	r2, [r3]
1237:ProgrammingSteps.c ****                 return(FAILURE);
 2078              		.loc 1 1237 0
 2079 014e 0023     		movs	r3, #0
 2080 0150 55E0     		b	.L161
 2081              	.L154:
1230:ProgrammingSteps.c ****     	{
 2082              		.loc 1 1230 0 discriminator 2
 2083 0152 97F89330 		ldrb	r3, [r7, #147]	@ zero_extendqisi2
 2084 0156 0133     		adds	r3, r3, #1
 2085 0158 87F89330 		strb	r3, [r7, #147]
 2086              	.L153:
1230:ProgrammingSteps.c ****     	{
 2087              		.loc 1 1230 0 is_stmt 0 discriminator 1
 2088 015c 97F89320 		ldrb	r2, [r7, #147]	@ zero_extendqisi2
 2089 0160 97F88F30 		ldrb	r3, [r7, #143]	@ zero_extendqisi2
 2090 0164 9A42     		cmp	r2, r3
 2091 0166 DBD3     		bcc	.L155
1208:ProgrammingSteps.c ****     {
 2092              		.loc 1 1208 0 is_stmt 1 discriminator 2
 2093 0168 97F89230 		ldrb	r3, [r7, #146]	@ zero_extendqisi2
 2094 016c 0133     		adds	r3, r3, #1
 2095 016e 87F89230 		strb	r3, [r7, #146]
 2096 0172 D7F89430 		ldr	r3, [r7, #148]
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 60


 2097 0176 03F50063 		add	r3, r3, #2048
 2098 017a C7F89430 		str	r3, [r7, #148]
 2099              	.L148:
1208:ProgrammingSteps.c ****     {
 2100              		.loc 1 1208 0 is_stmt 0 discriminator 1
 2101 017e 97F89220 		ldrb	r2, [r7, #146]	@ zero_extendqisi2
 2102 0182 97F88E30 		ldrb	r3, [r7, #142]	@ zero_extendqisi2
 2103 0186 9A42     		cmp	r2, r3
 2104 0188 FFF46DAF 		bcc	.L156
1238:ProgrammingSteps.c ****             }
1239:ProgrammingSteps.c ****     	}
1240:ProgrammingSteps.c ****     }
1241:ProgrammingSteps.c **** 
1242:ProgrammingSteps.c **** 	/* Read Chip Level Protection from hex-file */
1243:ProgrammingSteps.c **** 	HEX_ReadChipProtectionData(&chipProtectionData_Hex);
 2105              		.loc 1 1243 0 is_stmt 1
 2106 018c 07F18703 		add	r3, r7, #135
 2107 0190 1846     		mov	r0, r3
 2108 0192 FFF7FEFF 		bl	HEX_ReadChipProtectionData
1244:ProgrammingSteps.c **** 
1245:ProgrammingSteps.c **** 	/* Read Chip Level Protection from the silicon */
1246:ProgrammingSteps.c **** 	Read_IO(SFLASH_CPUSS_PROTECTION, &protectionData);
 2109              		.loc 1 1246 0
 2110 0196 07F18803 		add	r3, r7, #136
 2111 019a 1D48     		ldr	r0, .L162+8
 2112 019c 1946     		mov	r1, r3
 2113 019e FFF7FEFF 		bl	Read_IO
1247:ProgrammingSteps.c **** 	if( swd_PacketAck != SWD_OK_ACK )
 2114              		.loc 1 1247 0
 2115 01a2 1A4B     		ldr	r3, .L162+4
 2116 01a4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2117 01a6 012B     		cmp	r3, #1
 2118 01a8 01D0     		beq	.L157
1248:ProgrammingSteps.c ****     {
1249:ProgrammingSteps.c ****         return (FAILURE);
 2119              		.loc 1 1249 0
 2120 01aa 0023     		movs	r3, #0
 2121 01ac 27E0     		b	.L161
 2122              	.L157:
1250:ProgrammingSteps.c ****     }
1251:ProgrammingSteps.c **** 	
1252:ProgrammingSteps.c **** 	chipProtectionData_Chip = (protectionData >> 24) & 0x0F;
 2123              		.loc 1 1252 0
 2124 01ae D7F88830 		ldr	r3, [r7, #136]
 2125 01b2 1B0E     		lsrs	r3, r3, #24
 2126 01b4 DBB2     		uxtb	r3, r3
 2127 01b6 03F00F03 		and	r3, r3, #15
 2128 01ba DAB2     		uxtb	r2, r3
 2129 01bc 154B     		ldr	r3, .L162+12
 2130 01be 1A70     		strb	r2, [r3]
1253:ProgrammingSteps.c **** 
1254:ProgrammingSteps.c **** 	if (chipProtectionData_Chip == CHIP_PROT_VIRGIN)
 2131              		.loc 1 1254 0
 2132 01c0 144B     		ldr	r3, .L162+12
 2133 01c2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2134 01c4 002B     		cmp	r3, #0
 2135 01c6 03D1     		bne	.L158
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 61


1255:ProgrammingSteps.c **** 	{
1256:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_OPEN;
 2136              		.loc 1 1256 0
 2137 01c8 124B     		ldr	r3, .L162+12
 2138 01ca 0122     		movs	r2, #1
 2139 01cc 1A70     		strb	r2, [r3]
 2140 01ce 06E0     		b	.L159
 2141              	.L158:
1257:ProgrammingSteps.c **** 	}	
1258:ProgrammingSteps.c **** 	else if (chipProtectionData_Chip == CHIP_PROT_OPEN)
 2142              		.loc 1 1258 0
 2143 01d0 104B     		ldr	r3, .L162+12
 2144 01d2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2145 01d4 012B     		cmp	r3, #1
 2146 01d6 02D1     		bne	.L159
1259:ProgrammingSteps.c **** 	{
1260:ProgrammingSteps.c **** 		chipProtectionData_Chip = CHIP_PROT_VIRGIN;
 2147              		.loc 1 1260 0
 2148 01d8 0E4B     		ldr	r3, .L162+12
 2149 01da 0022     		movs	r2, #0
 2150 01dc 1A70     		strb	r2, [r3]
 2151              	.L159:
1261:ProgrammingSteps.c **** 	}
1262:ProgrammingSteps.c **** 	
1263:ProgrammingSteps.c **** 	/* Compare hexs and silicons chip protection data */
1264:ProgrammingSteps.c **** 	//Temporary Override GI
1265:ProgrammingSteps.c ****     if (chipProtectionData_Chip != chipProtectionData_Hex)
 2152              		.loc 1 1265 0
 2153 01de 0D4B     		ldr	r3, .L162+12
 2154 01e0 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2155 01e2 97F88730 		ldrb	r3, [r7, #135]	@ zero_extendqisi2
 2156 01e6 9A42     		cmp	r2, r3
 2157 01e8 08D0     		beq	.L160
1266:ProgrammingSteps.c **** 	{
1267:ProgrammingSteps.c ****         /* Set the verification error bit for Flash protection data
1268:ProgrammingSteps.c **** 		   mismatch and return failure */
1269:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR; 
 2158              		.loc 1 1269 0
 2159 01ea 084B     		ldr	r3, .L162+4
 2160 01ec 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2161 01ee 43F04003 		orr	r3, r3, #64
 2162 01f2 DAB2     		uxtb	r2, r3
 2163 01f4 054B     		ldr	r3, .L162+4
 2164 01f6 1A70     		strb	r2, [r3]
1270:ProgrammingSteps.c ****         return(FAILURE);
 2165              		.loc 1 1270 0
 2166 01f8 0023     		movs	r3, #0
 2167 01fa 00E0     		b	.L161
 2168              	.L160:
1271:ProgrammingSteps.c ****     }
1272:ProgrammingSteps.c **** 
1273:ProgrammingSteps.c **** 	return (SUCCESS);
 2169              		.loc 1 1273 0
 2170 01fc 0123     		movs	r3, #1
 2171              	.L161:
1274:ProgrammingSteps.c **** }
 2172              		.loc 1 1274 0 discriminator 1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 62


 2173 01fe 1846     		mov	r0, r3
 2174 0200 9837     		adds	r7, r7, #152
 2175              		.cfi_def_cfa_offset 8
 2176 0202 BD46     		mov	sp, r7
 2177              		.cfi_def_cfa_register 13
 2178              		@ sp needed
 2179 0204 80BD     		pop	{r7, pc}
 2180              	.L163:
 2181 0206 00BF     		.align	2
 2182              	.L162:
 2183 0208 00F0FF0F 		.word	268431360
 2184 020c 00000000 		.word	swd_PacketAck
 2185 0210 7CF0FF0F 		.word	268431484
 2186 0214 00000000 		.word	chipProtectionData_Chip
 2187              		.cfi_endproc
 2188              	.LFE76:
 2189              		.size	VerifyProtectionSettings, .-VerifyProtectionSettings
 2190              		.section	.text.VerifyChecksum,"ax",%progbits
 2191              		.align	2
 2192              		.global	VerifyChecksum
 2193              		.thumb
 2194              		.thumb_func
 2195              		.type	VerifyChecksum, %function
 2196              	VerifyChecksum:
 2197              	.LFB77:
1275:ProgrammingSteps.c **** 
1276:ProgrammingSteps.c **** /******************************************************************************
1277:ProgrammingSteps.c **** * Function Name: VerifyChecksum
1278:ProgrammingSteps.c **** *******************************************************************************
1279:ProgrammingSteps.c **** *
1280:ProgrammingSteps.c **** * Summary:
1281:ProgrammingSteps.c **** *  This is Step 9 of the programming sequence. In this step, Checksum of user
1282:ProgrammingSteps.c **** *  data in flash is verified with the Checksum stored in the HEX File. This step
1283:ProgrammingSteps.c **** *  uses the Checksum of privileged rows calculated in Step 4 get the checksum
1284:ProgrammingSteps.c **** *  of user data in flash.
1285:ProgrammingSteps.c **** *
1286:ProgrammingSteps.c **** * Parameters:
1287:ProgrammingSteps.c **** *  None
1288:ProgrammingSteps.c **** *
1289:ProgrammingSteps.c **** * Return:
1290:ProgrammingSteps.c **** *  SUCCESS - Returns SUCCESS if function successfully verifies the checksum.
1291:ProgrammingSteps.c **** *  FAILURE - Returns Failure if any of the intermediate step returns a fail
1292:ProgrammingSteps.c **** *			 message.
1293:ProgrammingSteps.c **** *
1294:ProgrammingSteps.c **** * Note:
1295:ProgrammingSteps.c **** *
1296:ProgrammingSteps.c **** ******************************************************************************/
1297:ProgrammingSteps.c **** unsigned char VerifyChecksum(void)
1298:ProgrammingSteps.c **** {
 2198              		.loc 1 1298 0
 2199              		.cfi_startproc
 2200              		@ args = 0, pretend = 0, frame = 16
 2201              		@ frame_needed = 1, uses_anonymous_args = 0
 2202 0000 80B5     		push	{r7, lr}
 2203              		.cfi_def_cfa_offset 8
 2204              		.cfi_offset 7, -8
 2205              		.cfi_offset 14, -4
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 63


 2206 0002 84B0     		sub	sp, sp, #16
 2207              		.cfi_def_cfa_offset 24
 2208 0004 00AF     		add	r7, sp, #0
 2209              		.cfi_def_cfa_register 7
1299:ProgrammingSteps.c **** 	unsigned long checksum_All 	 = 0;
 2210              		.loc 1 1299 0
 2211 0006 0023     		movs	r3, #0
 2212 0008 BB60     		str	r3, [r7, #8]
1300:ProgrammingSteps.c **** 	unsigned short chip_Checksum = 0;
 2213              		.loc 1 1300 0
 2214 000a 0023     		movs	r3, #0
 2215 000c FB81     		strh	r3, [r7, #14]	@ movhi
1301:ProgrammingSteps.c **** 	unsigned short checksumData  = 0;
 2216              		.loc 1 1301 0
 2217 000e 0023     		movs	r3, #0
 2218 0010 FB80     		strh	r3, [r7, #6]	@ movhi
1302:ProgrammingSteps.c ****     
1303:ProgrammingSteps.c **** 	/* Read the checksum of entire flash */
1304:ProgrammingSteps.c **** 	result = ChecksumAPI(CHECKSUM_ENTIRE_FLASH, &checksum_All);
 2219              		.loc 1 1304 0
 2220 0012 07F10803 		add	r3, r7, #8
 2221 0016 4FF40040 		mov	r0, #32768
 2222 001a 1946     		mov	r1, r3
 2223 001c FFF7FEFF 		bl	ChecksumAPI
 2224 0020 0346     		mov	r3, r0
 2225 0022 1A46     		mov	r2, r3
 2226 0024 124B     		ldr	r3, .L169
 2227 0026 1A70     		strb	r2, [r3]
1305:ProgrammingSteps.c **** 	
1306:ProgrammingSteps.c **** 	if (result != SUCCESS)
 2228              		.loc 1 1306 0
 2229 0028 114B     		ldr	r3, .L169
 2230 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2231 002c 012B     		cmp	r3, #1
 2232 002e 01D0     		beq	.L165
1307:ProgrammingSteps.c **** 	{
1308:ProgrammingSteps.c **** 		return (FAILURE);
 2233              		.loc 1 1308 0
 2234 0030 0023     		movs	r3, #0
 2235 0032 18E0     		b	.L168
 2236              	.L165:
1309:ProgrammingSteps.c **** 	}
1310:ProgrammingSteps.c **** 	
1311:ProgrammingSteps.c **** 	/* Calculate checksum of user flash */
1312:ProgrammingSteps.c ****     chip_Checksum = (unsigned short)checksum_All - (unsigned short)checksum_Privileged;
 2237              		.loc 1 1312 0
 2238 0034 BB68     		ldr	r3, [r7, #8]
 2239 0036 9AB2     		uxth	r2, r3
 2240 0038 0E4B     		ldr	r3, .L169+4
 2241 003a 1B68     		ldr	r3, [r3]
 2242 003c 9BB2     		uxth	r3, r3
 2243 003e D31A     		subs	r3, r2, r3
 2244 0040 FB81     		strh	r3, [r7, #14]	@ movhi
1313:ProgrammingSteps.c **** 	
1314:ProgrammingSteps.c **** 	/* Read checksum from hex file */
1315:ProgrammingSteps.c **** 	HEX_ReadChecksumData(&checksumData);
 2245              		.loc 1 1315 0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 64


 2246 0042 BB1D     		adds	r3, r7, #6
 2247 0044 1846     		mov	r0, r3
 2248 0046 FFF7FEFF 		bl	HEX_ReadChecksumData
1316:ProgrammingSteps.c **** 	
1317:ProgrammingSteps.c **** 	/* Compare the checksum data of silicon and hex file */
1318:ProgrammingSteps.c **** 	if (chip_Checksum != checksumData)
 2249              		.loc 1 1318 0
 2250 004a FB88     		ldrh	r3, [r7, #6]
 2251 004c FA89     		ldrh	r2, [r7, #14]
 2252 004e 9A42     		cmp	r2, r3
 2253 0050 08D0     		beq	.L167
1319:ProgrammingSteps.c ****     {
1320:ProgrammingSteps.c ****         swd_PacketAck = swd_PacketAck | VERIFICATION_ERROR;
 2254              		.loc 1 1320 0
 2255 0052 094B     		ldr	r3, .L169+8
 2256 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2257 0056 43F04003 		orr	r3, r3, #64
 2258 005a DAB2     		uxtb	r2, r3
 2259 005c 064B     		ldr	r3, .L169+8
 2260 005e 1A70     		strb	r2, [r3]
1321:ProgrammingSteps.c **** 		return (FAILURE);
 2261              		.loc 1 1321 0
 2262 0060 0023     		movs	r3, #0
 2263 0062 00E0     		b	.L168
 2264              	.L167:
1322:ProgrammingSteps.c ****     }
1323:ProgrammingSteps.c **** 	
1324:ProgrammingSteps.c **** 	return (SUCCESS);
 2265              		.loc 1 1324 0
 2266 0064 0123     		movs	r3, #1
 2267              	.L168:
1325:ProgrammingSteps.c **** }
 2268              		.loc 1 1325 0 discriminator 1
 2269 0066 1846     		mov	r0, r3
 2270 0068 1037     		adds	r7, r7, #16
 2271              		.cfi_def_cfa_offset 8
 2272 006a BD46     		mov	sp, r7
 2273              		.cfi_def_cfa_register 13
 2274              		@ sp needed
 2275 006c 80BD     		pop	{r7, pc}
 2276              	.L170:
 2277 006e 00BF     		.align	2
 2278              	.L169:
 2279 0070 00000000 		.word	result
 2280 0074 00000000 		.word	checksum_Privileged
 2281 0078 00000000 		.word	swd_PacketAck
 2282              		.cfi_endproc
 2283              	.LFE77:
 2284              		.size	VerifyChecksum, .-VerifyChecksum
 2285              		.section	.text.ReadHsspErrorStatus,"ax",%progbits
 2286              		.align	2
 2287              		.global	ReadHsspErrorStatus
 2288              		.thumb
 2289              		.thumb_func
 2290              		.type	ReadHsspErrorStatus, %function
 2291              	ReadHsspErrorStatus:
 2292              	.LFB78:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 65


1326:ProgrammingSteps.c **** 
1327:ProgrammingSteps.c **** /******************************************************************************
1328:ProgrammingSteps.c **** * Function Name: ReadHsspErrorStatus
1329:ProgrammingSteps.c **** *******************************************************************************
1330:ProgrammingSteps.c **** *
1331:ProgrammingSteps.c **** * Summary:
1332:ProgrammingSteps.c **** *  Returns the HSSP Error status in case of FAILURE return in any one of the
1333:ProgrammingSteps.c **** *  programming steps.
1334:ProgrammingSteps.c **** *
1335:ProgrammingSteps.c **** * Parameters:
1336:ProgrammingSteps.c **** *  None.
1337:ProgrammingSteps.c **** *
1338:ProgrammingSteps.c **** * Return:
1339:ProgrammingSteps.c **** *  swd_PacketAck - Each bit of this 8-bit return value has a specific meaning.
1340:ProgrammingSteps.c **** *
1341:ProgrammingSteps.c **** * Note:
1342:ProgrammingSteps.c **** *  Refer to the application note pdf for details on the Error status bit
1343:ProgrammingSteps.c **** *  definitions
1344:ProgrammingSteps.c **** ******************************************************************************/
1345:ProgrammingSteps.c **** unsigned char ReadHsspErrorStatus()
1346:ProgrammingSteps.c **** {
 2293              		.loc 1 1346 0
 2294              		.cfi_startproc
 2295              		@ args = 0, pretend = 0, frame = 0
 2296              		@ frame_needed = 1, uses_anonymous_args = 0
 2297              		@ link register save eliminated.
 2298 0000 80B4     		push	{r7}
 2299              		.cfi_def_cfa_offset 4
 2300              		.cfi_offset 7, -4
 2301 0002 00AF     		add	r7, sp, #0
 2302              		.cfi_def_cfa_register 7
1347:ProgrammingSteps.c ****     return(swd_PacketAck);
 2303              		.loc 1 1347 0
 2304 0004 034B     		ldr	r3, .L173
 2305 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
1348:ProgrammingSteps.c **** }
 2306              		.loc 1 1348 0
 2307 0008 1846     		mov	r0, r3
 2308 000a BD46     		mov	sp, r7
 2309              		.cfi_def_cfa_register 13
 2310              		@ sp needed
 2311 000c 5DF8047B 		ldr	r7, [sp], #4
 2312              		.cfi_restore 7
 2313              		.cfi_def_cfa_offset 0
 2314 0010 7047     		bx	lr
 2315              	.L174:
 2316 0012 00BF     		.align	2
 2317              	.L173:
 2318 0014 00000000 		.word	swd_PacketAck
 2319              		.cfi_endproc
 2320              	.LFE78:
 2321              		.size	ReadHsspErrorStatus, .-ReadHsspErrorStatus
 2322              		.section	.text.ExitProgrammingMode,"ax",%progbits
 2323              		.align	2
 2324              		.global	ExitProgrammingMode
 2325              		.thumb
 2326              		.thumb_func
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 66


 2327              		.type	ExitProgrammingMode, %function
 2328              	ExitProgrammingMode:
 2329              	.LFB79:
1349:ProgrammingSteps.c **** /******************************************************************************
1350:ProgrammingSteps.c **** * Function Name: ExitProgrammingMode
1351:ProgrammingSteps.c **** *******************************************************************************
1352:ProgrammingSteps.c **** *
1353:ProgrammingSteps.c **** * Summary:
1354:ProgrammingSteps.c **** *  Releases the target PSoC 4 device from Programming mode.
1355:ProgrammingSteps.c **** *
1356:ProgrammingSteps.c **** * Parameters:
1357:ProgrammingSteps.c **** *  None.
1358:ProgrammingSteps.c **** *
1359:ProgrammingSteps.c **** * Return:
1360:ProgrammingSteps.c **** *  None.
1361:ProgrammingSteps.c **** *
1362:ProgrammingSteps.c **** * Note:
1363:ProgrammingSteps.c **** *
1364:ProgrammingSteps.c **** ******************************************************************************/
1365:ProgrammingSteps.c **** void ExitProgrammingMode()
1366:ProgrammingSteps.c **** {
 2330              		.loc 1 1366 0
 2331              		.cfi_startproc
 2332              		@ args = 0, pretend = 0, frame = 0
 2333              		@ frame_needed = 1, uses_anonymous_args = 0
 2334 0000 80B5     		push	{r7, lr}
 2335              		.cfi_def_cfa_offset 8
 2336              		.cfi_offset 7, -8
 2337              		.cfi_offset 14, -4
 2338 0002 00AF     		add	r7, sp, #0
 2339              		.cfi_def_cfa_register 7
1367:ProgrammingSteps.c ****     /* Drive the SWDIO, SWDCK outputs low */
1368:ProgrammingSteps.c ****     SetSwdckLow();
 2340              		.loc 1 1368 0
 2341 0004 FFF7FEFF 		bl	SetSwdckLow
1369:ProgrammingSteps.c ****     SetSwdioLow();
 2342              		.loc 1 1369 0
 2343 0008 FFF7FEFF 		bl	SetSwdioLow
1370:ProgrammingSteps.c ****     
1371:ProgrammingSteps.c ****     /* Make SWDIO, SWDCK High-Z after completing Programming */    
1372:ProgrammingSteps.c ****     SetSwdioHizInput();
 2344              		.loc 1 1372 0
 2345 000c FFF7FEFF 		bl	SetSwdioHizInput
1373:ProgrammingSteps.c ****     SetSwdckHizInput();
 2346              		.loc 1 1373 0
 2347 0010 FFF7FEFF 		bl	SetSwdckHizInput
1374:ProgrammingSteps.c ****     
1375:ProgrammingSteps.c ****     /* Generate active low rest pulse for 100 uS */
1376:ProgrammingSteps.c ****     SetXresLow();
 2348              		.loc 1 1376 0
 2349 0014 FFF7FEFF 		bl	SetXresLow
1377:ProgrammingSteps.c ****     DelayHundredUs();    
 2350              		.loc 1 1377 0
 2351 0018 FFF7FEFF 		bl	DelayHundredUs
1378:ProgrammingSteps.c ****     SetXresHigh();
 2352              		.loc 1 1378 0
 2353 001c FFF7FEFF 		bl	SetXresHigh
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 67


1379:ProgrammingSteps.c **** 
1380:ProgrammingSteps.c ****     /* Make XRES High-Z after generating the reset pulse */  
1381:ProgrammingSteps.c ****     SetXresHizInput();
 2354              		.loc 1 1381 0
 2355 0020 FFF7FEFF 		bl	SetXresHizInput
1382:ProgrammingSteps.c **** }
 2356              		.loc 1 1382 0
 2357 0024 80BD     		pop	{r7, pc}
 2358              		.cfi_endproc
 2359              	.LFE79:
 2360              		.size	ExitProgrammingMode, .-ExitProgrammingMode
 2361 0026 00BF     		.text
 2362              	.Letext0:
 2363              		.file 2 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2364              		.file 3 "c:\\program files\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.3\\arm
 2365              		.file 4 "SWD_PacketLayer.h"
 2366              		.file 5 "Generated_Source\\PSoC5/core_cm3.h"
 2367              		.section	.debug_info,"",%progbits
 2368              	.Ldebug_info0:
 2369 0000 50060000 		.4byte	0x650
 2370 0004 0400     		.2byte	0x4
 2371 0006 00000000 		.4byte	.Ldebug_abbrev0
 2372 000a 04       		.byte	0x4
 2373 000b 01       		.uleb128 0x1
 2374 000c 06020000 		.4byte	.LASF74
 2375 0010 01       		.byte	0x1
 2376 0011 DD000000 		.4byte	.LASF75
 2377 0015 F0000000 		.4byte	.LASF76
 2378 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2379 001d 00000000 		.4byte	0
 2380 0021 00000000 		.4byte	.Ldebug_line0
 2381 0025 02       		.uleb128 0x2
 2382 0026 01       		.byte	0x1
 2383 0027 06       		.byte	0x6
 2384 0028 BB010000 		.4byte	.LASF0
 2385 002c 02       		.uleb128 0x2
 2386 002d 01       		.byte	0x1
 2387 002e 08       		.byte	0x8
 2388 002f F5020000 		.4byte	.LASF1
 2389 0033 02       		.uleb128 0x2
 2390 0034 02       		.byte	0x2
 2391 0035 05       		.byte	0x5
 2392 0036 9C000000 		.4byte	.LASF2
 2393 003a 02       		.uleb128 0x2
 2394 003b 02       		.byte	0x2
 2395 003c 07       		.byte	0x7
 2396 003d 98030000 		.4byte	.LASF3
 2397 0041 03       		.uleb128 0x3
 2398 0042 62040000 		.4byte	.LASF9
 2399 0046 02       		.byte	0x2
 2400 0047 3F       		.byte	0x3f
 2401 0048 4C000000 		.4byte	0x4c
 2402 004c 02       		.uleb128 0x2
 2403 004d 04       		.byte	0x4
 2404 004e 05       		.byte	0x5
 2405 004f D4030000 		.4byte	.LASF4
 2406 0053 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 68


 2407 0054 04       		.byte	0x4
 2408 0055 07       		.byte	0x7
 2409 0056 09040000 		.4byte	.LASF5
 2410 005a 02       		.uleb128 0x2
 2411 005b 08       		.byte	0x8
 2412 005c 05       		.byte	0x5
 2413 005d 3D010000 		.4byte	.LASF6
 2414 0061 02       		.uleb128 0x2
 2415 0062 08       		.byte	0x8
 2416 0063 07       		.byte	0x7
 2417 0064 47030000 		.4byte	.LASF7
 2418 0068 04       		.uleb128 0x4
 2419 0069 04       		.byte	0x4
 2420 006a 05       		.byte	0x5
 2421 006b 696E7400 		.ascii	"int\000"
 2422 006f 02       		.uleb128 0x2
 2423 0070 04       		.byte	0x4
 2424 0071 07       		.byte	0x7
 2425 0072 71030000 		.4byte	.LASF8
 2426 0076 03       		.uleb128 0x3
 2427 0077 E7030000 		.4byte	.LASF10
 2428 007b 03       		.byte	0x3
 2429 007c 2C       		.byte	0x2c
 2430 007d 41000000 		.4byte	0x41
 2431 0081 02       		.uleb128 0x2
 2432 0082 04       		.byte	0x4
 2433 0083 04       		.byte	0x4
 2434 0084 C7010000 		.4byte	.LASF11
 2435 0088 02       		.uleb128 0x2
 2436 0089 08       		.byte	0x8
 2437 008a 04       		.byte	0x4
 2438 008b 27040000 		.4byte	.LASF12
 2439 008f 02       		.uleb128 0x2
 2440 0090 01       		.byte	0x1
 2441 0091 08       		.byte	0x8
 2442 0092 C0030000 		.4byte	.LASF13
 2443 0096 02       		.uleb128 0x2
 2444 0097 04       		.byte	0x4
 2445 0098 07       		.byte	0x7
 2446 0099 B6000000 		.4byte	.LASF14
 2447 009d 05       		.uleb128 0x5
 2448 009e 04       		.byte	0x4
 2449 009f 2C000000 		.4byte	0x2c
 2450 00a3 06       		.uleb128 0x6
 2451 00a4 78040000 		.4byte	.LASF77
 2452 00a8 01       		.byte	0x1
 2453 00a9 01       		.byte	0x1
 2454 00aa 48       		.byte	0x48
 2455 00ab C8000000 		.4byte	0xc8
 2456 00af 07       		.uleb128 0x7
 2457 00b0 AD020000 		.4byte	.LASF15
 2458 00b4 00       		.sleb128 0
 2459 00b5 07       		.uleb128 0x7
 2460 00b6 6C040000 		.4byte	.LASF16
 2461 00ba 01       		.sleb128 1
 2462 00bb 07       		.uleb128 0x7
 2463 00bc 88040000 		.4byte	.LASF17
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 69


 2464 00c0 02       		.sleb128 2
 2465 00c1 07       		.uleb128 0x7
 2466 00c2 00000000 		.4byte	.LASF18
 2467 00c6 03       		.sleb128 3
 2468 00c7 00       		.byte	0
 2469 00c8 08       		.uleb128 0x8
 2470 00c9 7E030000 		.4byte	.LASF19
 2471 00cd 01       		.byte	0x1
 2472 00ce 68       		.byte	0x68
 2473 00cf 2C000000 		.4byte	0x2c
 2474 00d3 00000000 		.4byte	.LFB63
 2475 00d7 9C000000 		.4byte	.LFE63-.LFB63
 2476 00db 01       		.uleb128 0x1
 2477 00dc 9C       		.byte	0x9c
 2478 00dd F0000000 		.4byte	0xf0
 2479 00e1 09       		.uleb128 0x9
 2480 00e2 F9010000 		.4byte	.LASF21
 2481 00e6 01       		.byte	0x1
 2482 00e7 6A       		.byte	0x6a
 2483 00e8 53000000 		.4byte	0x53
 2484 00ec 02       		.uleb128 0x2
 2485 00ed 91       		.byte	0x91
 2486 00ee 74       		.sleb128 -12
 2487 00ef 00       		.byte	0
 2488 00f0 0A       		.uleb128 0xa
 2489 00f1 03030000 		.4byte	.LASF45
 2490 00f5 01       		.byte	0x1
 2491 00f6 C5       		.byte	0xc5
 2492 00f7 2C000000 		.4byte	0x2c
 2493 00fb 00000000 		.4byte	.LFB64
 2494 00ff 18000000 		.4byte	.LFE64-.LFB64
 2495 0103 01       		.uleb128 0x1
 2496 0104 9C       		.byte	0x9c
 2497 0105 08       		.uleb128 0x8
 2498 0106 B0040000 		.4byte	.LASF20
 2499 010a 01       		.byte	0x1
 2500 010b DF       		.byte	0xdf
 2501 010c 2C000000 		.4byte	0x2c
 2502 0110 00000000 		.4byte	.LFB65
 2503 0114 94000000 		.4byte	.LFE65-.LFB65
 2504 0118 01       		.uleb128 0x1
 2505 0119 9C       		.byte	0x9c
 2506 011a 3B010000 		.4byte	0x13b
 2507 011e 09       		.uleb128 0x9
 2508 011f 57010000 		.4byte	.LASF22
 2509 0123 01       		.byte	0x1
 2510 0124 E1       		.byte	0xe1
 2511 0125 53000000 		.4byte	0x53
 2512 0129 02       		.uleb128 0x2
 2513 012a 91       		.byte	0x91
 2514 012b 74       		.sleb128 -12
 2515 012c 09       		.uleb128 0x9
 2516 012d EC010000 		.4byte	.LASF23
 2517 0131 01       		.byte	0x1
 2518 0132 E2       		.byte	0xe2
 2519 0133 53000000 		.4byte	0x53
 2520 0137 02       		.uleb128 0x2
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 70


 2521 0138 91       		.byte	0x91
 2522 0139 70       		.sleb128 -16
 2523 013a 00       		.byte	0
 2524 013b 0B       		.uleb128 0xb
 2525 013c CB000000 		.4byte	.LASF24
 2526 0140 01       		.byte	0x1
 2527 0141 2601     		.2byte	0x126
 2528 0143 2C000000 		.4byte	0x2c
 2529 0147 00000000 		.4byte	.LFB66
 2530 014b A4000000 		.4byte	.LFE66-.LFB66
 2531 014f 01       		.uleb128 0x1
 2532 0150 9C       		.byte	0x9c
 2533 0151 65010000 		.4byte	0x165
 2534 0155 0C       		.uleb128 0xc
 2535 0156 42040000 		.4byte	.LASF25
 2536 015a 01       		.byte	0x1
 2537 015b 2801     		.2byte	0x128
 2538 015d 2C000000 		.4byte	0x2c
 2539 0161 02       		.uleb128 0x2
 2540 0162 91       		.byte	0x91
 2541 0163 77       		.sleb128 -9
 2542 0164 00       		.byte	0
 2543 0165 0B       		.uleb128 0xb
 2544 0166 DD030000 		.4byte	.LASF26
 2545 016a 01       		.byte	0x1
 2546 016b 7501     		.2byte	0x175
 2547 016d 2C000000 		.4byte	0x2c
 2548 0171 00000000 		.4byte	.LFB67
 2549 0175 24010000 		.4byte	.LFE67-.LFB67
 2550 0179 01       		.uleb128 0x1
 2551 017a 9C       		.byte	0x9c
 2552 017b D8010000 		.4byte	0x1d8
 2553 017f 0D       		.uleb128 0xd
 2554 0180 01040000 		.4byte	.LASF27
 2555 0184 01       		.byte	0x1
 2556 0185 7501     		.2byte	0x175
 2557 0187 2C000000 		.4byte	0x2c
 2558 018b 02       		.uleb128 0x2
 2559 018c 91       		.byte	0x91
 2560 018d 67       		.sleb128 -25
 2561 018e 0D       		.uleb128 0xd
 2562 018f 87000000 		.4byte	.LASF28
 2563 0193 01       		.byte	0x1
 2564 0194 7501     		.2byte	0x175
 2565 0196 9D000000 		.4byte	0x9d
 2566 019a 02       		.uleb128 0x2
 2567 019b 91       		.byte	0x91
 2568 019c 60       		.sleb128 -32
 2569 019d 0D       		.uleb128 0xd
 2570 019e 8E010000 		.4byte	.LASF29
 2571 01a2 01       		.byte	0x1
 2572 01a3 7501     		.2byte	0x175
 2573 01a5 3A000000 		.4byte	0x3a
 2574 01a9 02       		.uleb128 0x2
 2575 01aa 91       		.byte	0x91
 2576 01ab 64       		.sleb128 -28
 2577 01ac 0C       		.uleb128 0xc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 71


 2578 01ad 57010000 		.4byte	.LASF22
 2579 01b1 01       		.byte	0x1
 2580 01b2 7701     		.2byte	0x177
 2581 01b4 53000000 		.4byte	0x53
 2582 01b8 02       		.uleb128 0x2
 2583 01b9 91       		.byte	0x91
 2584 01ba 70       		.sleb128 -16
 2585 01bb 0C       		.uleb128 0xc
 2586 01bc 62010000 		.4byte	.LASF30
 2587 01c0 01       		.byte	0x1
 2588 01c1 7801     		.2byte	0x178
 2589 01c3 53000000 		.4byte	0x53
 2590 01c7 02       		.uleb128 0x2
 2591 01c8 91       		.byte	0x91
 2592 01c9 6C       		.sleb128 -20
 2593 01ca 0E       		.uleb128 0xe
 2594 01cb 6900     		.ascii	"i\000"
 2595 01cd 01       		.byte	0x1
 2596 01ce 7901     		.2byte	0x179
 2597 01d0 3A000000 		.4byte	0x3a
 2598 01d4 02       		.uleb128 0x2
 2599 01d5 91       		.byte	0x91
 2600 01d6 76       		.sleb128 -10
 2601 01d7 00       		.byte	0
 2602 01d8 0B       		.uleb128 0xb
 2603 01d9 1B040000 		.4byte	.LASF31
 2604 01dd 01       		.byte	0x1
 2605 01de DD01     		.2byte	0x1dd
 2606 01e0 2C000000 		.4byte	0x2c
 2607 01e4 00000000 		.4byte	.LFB68
 2608 01e8 AC000000 		.4byte	.LFE68-.LFB68
 2609 01ec 01       		.uleb128 0x1
 2610 01ed 9C       		.byte	0x9c
 2611 01ee 2F020000 		.4byte	0x22f
 2612 01f2 0D       		.uleb128 0xd
 2613 01f3 4B010000 		.4byte	.LASF32
 2614 01f7 01       		.byte	0x1
 2615 01f8 DD01     		.2byte	0x1dd
 2616 01fa 3A000000 		.4byte	0x3a
 2617 01fe 02       		.uleb128 0x2
 2618 01ff 91       		.byte	0x91
 2619 0200 6E       		.sleb128 -18
 2620 0201 0D       		.uleb128 0xd
 2621 0202 85010000 		.4byte	.LASF33
 2622 0206 01       		.byte	0x1
 2623 0207 DD01     		.2byte	0x1dd
 2624 0209 2F020000 		.4byte	0x22f
 2625 020d 02       		.uleb128 0x2
 2626 020e 91       		.byte	0x91
 2627 020f 68       		.sleb128 -24
 2628 0210 0C       		.uleb128 0xc
 2629 0211 57010000 		.4byte	.LASF22
 2630 0215 01       		.byte	0x1
 2631 0216 DF01     		.2byte	0x1df
 2632 0218 53000000 		.4byte	0x53
 2633 021c 02       		.uleb128 0x2
 2634 021d 91       		.byte	0x91
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 72


 2635 021e 74       		.sleb128 -12
 2636 021f 0C       		.uleb128 0xc
 2637 0220 B2030000 		.4byte	.LASF34
 2638 0224 01       		.byte	0x1
 2639 0225 E001     		.2byte	0x1e0
 2640 0227 53000000 		.4byte	0x53
 2641 022b 02       		.uleb128 0x2
 2642 022c 91       		.byte	0x91
 2643 022d 70       		.sleb128 -16
 2644 022e 00       		.byte	0
 2645 022f 05       		.uleb128 0x5
 2646 0230 04       		.byte	0x4
 2647 0231 53000000 		.4byte	0x53
 2648 0235 0B       		.uleb128 0xb
 2649 0236 11000000 		.4byte	.LASF35
 2650 023a 01       		.byte	0x1
 2651 023b 2702     		.2byte	0x227
 2652 023d 2C000000 		.4byte	0x2c
 2653 0241 00000000 		.4byte	.LFB69
 2654 0245 34010000 		.4byte	.LFE69-.LFB69
 2655 0249 01       		.uleb128 0x1
 2656 024a 9C       		.byte	0x9c
 2657 024b 7D020000 		.4byte	0x27d
 2658 024f 0C       		.uleb128 0xc
 2659 0250 BF000000 		.4byte	.LASF36
 2660 0254 01       		.byte	0x1
 2661 0255 2902     		.2byte	0x229
 2662 0257 53000000 		.4byte	0x53
 2663 025b 02       		.uleb128 0x2
 2664 025c 91       		.byte	0x91
 2665 025d 70       		.sleb128 -16
 2666 025e 0C       		.uleb128 0xc
 2667 025f 12030000 		.4byte	.LASF37
 2668 0263 01       		.byte	0x1
 2669 0264 2A02     		.2byte	0x22a
 2670 0266 3A000000 		.4byte	0x3a
 2671 026a 02       		.uleb128 0x2
 2672 026b 91       		.byte	0x91
 2673 026c 76       		.sleb128 -10
 2674 026d 0C       		.uleb128 0xc
 2675 026e AB030000 		.4byte	.LASF38
 2676 0272 01       		.byte	0x1
 2677 0273 2B02     		.2byte	0x22b
 2678 0275 53000000 		.4byte	0x53
 2679 0279 02       		.uleb128 0x2
 2680 027a 91       		.byte	0x91
 2681 027b 6C       		.sleb128 -20
 2682 027c 00       		.byte	0
 2683 027d 0B       		.uleb128 0xb
 2684 027e DC010000 		.4byte	.LASF39
 2685 0282 01       		.byte	0x1
 2686 0283 B302     		.2byte	0x2b3
 2687 0285 2C000000 		.4byte	0x2c
 2688 0289 00000000 		.4byte	.LFB70
 2689 028d 00010000 		.4byte	.LFE70-.LFB70
 2690 0291 01       		.uleb128 0x1
 2691 0292 9C       		.byte	0x9c
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 73


 2692 0293 F0020000 		.4byte	0x2f0
 2693 0297 0E       		.uleb128 0xe
 2694 0298 6900     		.ascii	"i\000"
 2695 029a 01       		.byte	0x1
 2696 029b B502     		.2byte	0x2b5
 2697 029d 2C000000 		.4byte	0x2c
 2698 02a1 02       		.uleb128 0x2
 2699 02a2 91       		.byte	0x91
 2700 02a3 77       		.sleb128 -9
 2701 02a4 0C       		.uleb128 0xc
 2702 02a5 A6000000 		.4byte	.LASF40
 2703 02a9 01       		.byte	0x1
 2704 02aa B602     		.2byte	0x2b6
 2705 02ac 53000000 		.4byte	0x53
 2706 02b0 02       		.uleb128 0x2
 2707 02b1 91       		.byte	0x91
 2708 02b2 6C       		.sleb128 -20
 2709 02b3 0C       		.uleb128 0xc
 2710 02b4 A3040000 		.4byte	.LASF41
 2711 02b8 01       		.byte	0x1
 2712 02b9 B702     		.2byte	0x2b7
 2713 02bb 53000000 		.4byte	0x53
 2714 02bf 02       		.uleb128 0x2
 2715 02c0 91       		.byte	0x91
 2716 02c1 68       		.sleb128 -24
 2717 02c2 0C       		.uleb128 0xc
 2718 02c3 57010000 		.4byte	.LASF22
 2719 02c7 01       		.byte	0x1
 2720 02c8 B902     		.2byte	0x2b9
 2721 02ca 53000000 		.4byte	0x53
 2722 02ce 02       		.uleb128 0x2
 2723 02cf 91       		.byte	0x91
 2724 02d0 70       		.sleb128 -16
 2725 02d1 0C       		.uleb128 0xc
 2726 02d2 5E000000 		.4byte	.LASF42
 2727 02d6 01       		.byte	0x1
 2728 02d7 BA02     		.2byte	0x2ba
 2729 02d9 53000000 		.4byte	0x53
 2730 02dd 02       		.uleb128 0x2
 2731 02de 91       		.byte	0x91
 2732 02df 64       		.sleb128 -28
 2733 02e0 0C       		.uleb128 0xc
 2734 02e1 6D000000 		.4byte	.LASF43
 2735 02e5 01       		.byte	0x1
 2736 02e6 BB02     		.2byte	0x2bb
 2737 02e8 53000000 		.4byte	0x53
 2738 02ec 02       		.uleb128 0x2
 2739 02ed 91       		.byte	0x91
 2740 02ee 60       		.sleb128 -32
 2741 02ef 00       		.byte	0
 2742 02f0 0B       		.uleb128 0xb
 2743 02f1 1F000000 		.4byte	.LASF44
 2744 02f5 01       		.byte	0x1
 2745 02f6 1303     		.2byte	0x313
 2746 02f8 2C000000 		.4byte	0x2c
 2747 02fc 00000000 		.4byte	.LFB71
 2748 0300 24010000 		.4byte	.LFE71-.LFB71
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 74


 2749 0304 01       		.uleb128 0x1
 2750 0305 9C       		.byte	0x9c
 2751 0306 1A030000 		.4byte	0x31a
 2752 030a 0C       		.uleb128 0xc
 2753 030b 57010000 		.4byte	.LASF22
 2754 030f 01       		.byte	0x1
 2755 0310 1503     		.2byte	0x315
 2756 0312 53000000 		.4byte	0x53
 2757 0316 02       		.uleb128 0x2
 2758 0317 91       		.byte	0x91
 2759 0318 74       		.sleb128 -12
 2760 0319 00       		.byte	0
 2761 031a 0F       		.uleb128 0xf
 2762 031b 5E030000 		.4byte	.LASF46
 2763 031f 01       		.byte	0x1
 2764 0320 8603     		.2byte	0x386
 2765 0322 2C000000 		.4byte	0x2c
 2766 0326 00000000 		.4byte	.LFB72
 2767 032a 30000000 		.4byte	.LFE72-.LFB72
 2768 032e 01       		.uleb128 0x1
 2769 032f 9C       		.byte	0x9c
 2770 0330 0B       		.uleb128 0xb
 2771 0331 9A010000 		.4byte	.LASF47
 2772 0335 01       		.byte	0x1
 2773 0336 A703     		.2byte	0x3a7
 2774 0338 2C000000 		.4byte	0x2c
 2775 033c 00000000 		.4byte	.LFB73
 2776 0340 20010000 		.4byte	.LFE73-.LFB73
 2777 0344 01       		.uleb128 0x1
 2778 0345 9C       		.byte	0x9c
 2779 0346 97030000 		.4byte	0x397
 2780 034a 0C       		.uleb128 0xc
 2781 034b 01040000 		.4byte	.LASF27
 2782 034f 01       		.byte	0x1
 2783 0350 A903     		.2byte	0x3a9
 2784 0352 2C000000 		.4byte	0x2c
 2785 0356 02       		.uleb128 0x2
 2786 0357 91       		.byte	0x91
 2787 0358 75       		.sleb128 -11
 2788 0359 0C       		.uleb128 0xc
 2789 035a 87000000 		.4byte	.LASF28
 2790 035e 01       		.byte	0x1
 2791 035f AA03     		.2byte	0x3aa
 2792 0361 97030000 		.4byte	0x397
 2793 0365 03       		.uleb128 0x3
 2794 0366 91       		.byte	0x91
 2795 0367 EC7D     		.sleb128 -276
 2796 0369 0C       		.uleb128 0xc
 2797 036a FD040000 		.4byte	.LASF48
 2798 036e 01       		.byte	0x1
 2799 036f AC03     		.2byte	0x3ac
 2800 0371 3A000000 		.4byte	0x3a
 2801 0375 02       		.uleb128 0x2
 2802 0376 91       		.byte	0x91
 2803 0377 72       		.sleb128 -14
 2804 0378 0C       		.uleb128 0xc
 2805 0379 59040000 		.4byte	.LASF49
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 75


 2806 037d 01       		.byte	0x1
 2807 037e AD03     		.2byte	0x3ad
 2808 0380 3A000000 		.4byte	0x3a
 2809 0384 02       		.uleb128 0x2
 2810 0385 91       		.byte	0x91
 2811 0386 76       		.sleb128 -10
 2812 0387 0C       		.uleb128 0xc
 2813 0388 57010000 		.4byte	.LASF22
 2814 038c 01       		.byte	0x1
 2815 038d AF03     		.2byte	0x3af
 2816 038f 53000000 		.4byte	0x53
 2817 0393 02       		.uleb128 0x2
 2818 0394 91       		.byte	0x91
 2819 0395 6C       		.sleb128 -20
 2820 0396 00       		.byte	0
 2821 0397 10       		.uleb128 0x10
 2822 0398 2C000000 		.4byte	0x2c
 2823 039c A7030000 		.4byte	0x3a7
 2824 03a0 11       		.uleb128 0x11
 2825 03a1 96000000 		.4byte	0x96
 2826 03a5 FF       		.byte	0xff
 2827 03a6 00       		.byte	0
 2828 03a7 0B       		.uleb128 0xb
 2829 03a8 3B030000 		.4byte	.LASF50
 2830 03ac 01       		.byte	0x1
 2831 03ad FD03     		.2byte	0x3fd
 2832 03af 2C000000 		.4byte	0x2c
 2833 03b3 00000000 		.4byte	.LFB74
 2834 03b7 30010000 		.4byte	.LFE74-.LFB74
 2835 03bb 01       		.uleb128 0x1
 2836 03bc 9C       		.byte	0x9c
 2837 03bd 2B040000 		.4byte	0x42b
 2838 03c1 0C       		.uleb128 0xc
 2839 03c2 EB020000 		.4byte	.LASF51
 2840 03c6 01       		.byte	0x1
 2841 03c7 FF03     		.2byte	0x3ff
 2842 03c9 53000000 		.4byte	0x53
 2843 03cd 02       		.uleb128 0x2
 2844 03ce 91       		.byte	0x91
 2845 03cf 68       		.sleb128 -24
 2846 03d0 0C       		.uleb128 0xc
 2847 03d1 FD040000 		.4byte	.LASF48
 2848 03d5 01       		.byte	0x1
 2849 03d6 0004     		.2byte	0x400
 2850 03d8 3A000000 		.4byte	0x3a
 2851 03dc 02       		.uleb128 0x2
 2852 03dd 91       		.byte	0x91
 2853 03de 72       		.sleb128 -14
 2854 03df 0C       		.uleb128 0xc
 2855 03e0 7C000000 		.4byte	.LASF52
 2856 03e4 01       		.byte	0x1
 2857 03e5 0104     		.2byte	0x401
 2858 03e7 53000000 		.4byte	0x53
 2859 03eb 02       		.uleb128 0x2
 2860 03ec 91       		.byte	0x91
 2861 03ed 6C       		.sleb128 -20
 2862 03ee 0C       		.uleb128 0xc
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 76


 2863 03ef 59040000 		.4byte	.LASF49
 2864 03f3 01       		.byte	0x1
 2865 03f4 0204     		.2byte	0x402
 2866 03f6 3A000000 		.4byte	0x3a
 2867 03fa 02       		.uleb128 0x2
 2868 03fb 91       		.byte	0x91
 2869 03fc 76       		.sleb128 -10
 2870 03fd 0E       		.uleb128 0xe
 2871 03fe 6900     		.ascii	"i\000"
 2872 0400 01       		.byte	0x1
 2873 0401 0304     		.2byte	0x403
 2874 0403 3A000000 		.4byte	0x3a
 2875 0407 02       		.uleb128 0x2
 2876 0408 91       		.byte	0x91
 2877 0409 74       		.sleb128 -12
 2878 040a 0C       		.uleb128 0xc
 2879 040b 87000000 		.4byte	.LASF28
 2880 040f 01       		.byte	0x1
 2881 0410 0404     		.2byte	0x404
 2882 0412 97030000 		.4byte	0x397
 2883 0416 03       		.uleb128 0x3
 2884 0417 91       		.byte	0x91
 2885 0418 E87D     		.sleb128 -280
 2886 041a 0C       		.uleb128 0xc
 2887 041b E2020000 		.4byte	.LASF53
 2888 041f 01       		.byte	0x1
 2889 0420 0504     		.2byte	0x405
 2890 0422 97030000 		.4byte	0x397
 2891 0426 03       		.uleb128 0x3
 2892 0427 91       		.byte	0x91
 2893 0428 E87B     		.sleb128 -536
 2894 042a 00       		.byte	0
 2895 042b 0B       		.uleb128 0xb
 2896 042c 44000000 		.4byte	.LASF54
 2897 0430 01       		.byte	0x1
 2898 0431 4804     		.2byte	0x448
 2899 0433 2C000000 		.4byte	0x2c
 2900 0437 00000000 		.4byte	.LFB75
 2901 043b 20010000 		.4byte	.LFE75-.LFB75
 2902 043f 01       		.uleb128 0x1
 2903 0440 9C       		.byte	0x9c
 2904 0441 B1040000 		.4byte	0x4b1
 2905 0445 0C       		.uleb128 0xc
 2906 0446 01040000 		.4byte	.LASF27
 2907 044a 01       		.byte	0x1
 2908 044b 4A04     		.2byte	0x44a
 2909 044d 2C000000 		.4byte	0x2c
 2910 0451 02       		.uleb128 0x2
 2911 0452 91       		.byte	0x91
 2912 0453 77       		.sleb128 -9
 2913 0454 0C       		.uleb128 0xc
 2914 0455 D3040000 		.4byte	.LASF55
 2915 0459 01       		.byte	0x1
 2916 045a 4B04     		.2byte	0x44b
 2917 045c 2C000000 		.4byte	0x2c
 2918 0460 02       		.uleb128 0x2
 2919 0461 91       		.byte	0x91
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 77


 2920 0462 76       		.sleb128 -10
 2921 0463 0C       		.uleb128 0xc
 2922 0464 25030000 		.4byte	.LASF56
 2923 0468 01       		.byte	0x1
 2924 0469 4C04     		.2byte	0x44c
 2925 046b 2C000000 		.4byte	0x2c
 2926 046f 02       		.uleb128 0x2
 2927 0470 91       		.byte	0x91
 2928 0471 75       		.sleb128 -11
 2929 0472 0C       		.uleb128 0xc
 2930 0473 91040000 		.4byte	.LASF57
 2931 0477 01       		.byte	0x1
 2932 0478 4D04     		.2byte	0x44d
 2933 047a B1040000 		.4byte	0x4b1
 2934 047e 03       		.uleb128 0x3
 2935 047f 91       		.byte	0x91
 2936 0480 AC7F     		.sleb128 -84
 2937 0482 0C       		.uleb128 0xc
 2938 0483 42040000 		.4byte	.LASF25
 2939 0487 01       		.byte	0x1
 2940 0488 4E04     		.2byte	0x44e
 2941 048a 2C000000 		.4byte	0x2c
 2942 048e 03       		.uleb128 0x3
 2943 048f 91       		.byte	0x91
 2944 0490 AB7F     		.sleb128 -85
 2945 0492 0C       		.uleb128 0xc
 2946 0493 FD040000 		.4byte	.LASF48
 2947 0497 01       		.byte	0x1
 2948 0498 5004     		.2byte	0x450
 2949 049a 3A000000 		.4byte	0x3a
 2950 049e 02       		.uleb128 0x2
 2951 049f 91       		.byte	0x91
 2952 04a0 72       		.sleb128 -14
 2953 04a1 0C       		.uleb128 0xc
 2954 04a2 57010000 		.4byte	.LASF22
 2955 04a6 01       		.byte	0x1
 2956 04a7 5204     		.2byte	0x452
 2957 04a9 53000000 		.4byte	0x53
 2958 04ad 02       		.uleb128 0x2
 2959 04ae 91       		.byte	0x91
 2960 04af 6C       		.sleb128 -20
 2961 04b0 00       		.byte	0
 2962 04b1 10       		.uleb128 0x10
 2963 04b2 2C000000 		.4byte	0x2c
 2964 04b6 C1040000 		.4byte	0x4c1
 2965 04ba 11       		.uleb128 0x11
 2966 04bb 96000000 		.4byte	0x96
 2967 04bf 3F       		.byte	0x3f
 2968 04c0 00       		.byte	0
 2969 04c1 0B       		.uleb128 0xb
 2970 04c2 94020000 		.4byte	.LASF58
 2971 04c6 01       		.byte	0x1
 2972 04c7 A304     		.2byte	0x4a3
 2973 04c9 2C000000 		.4byte	0x2c
 2974 04cd 00000000 		.4byte	.LFB76
 2975 04d1 18020000 		.4byte	.LFE76-.LFB76
 2976 04d5 01       		.uleb128 0x1
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 78


 2977 04d6 9C       		.byte	0x9c
 2978 04d7 72050000 		.4byte	0x572
 2979 04db 0C       		.uleb128 0xc
 2980 04dc CD010000 		.4byte	.LASF59
 2981 04e0 01       		.byte	0x1
 2982 04e1 A504     		.2byte	0x4a5
 2983 04e3 53000000 		.4byte	0x53
 2984 04e7 02       		.uleb128 0x2
 2985 04e8 91       		.byte	0x91
 2986 04e9 68       		.sleb128 -24
 2987 04ea 0C       		.uleb128 0xc
 2988 04eb 2D000000 		.4byte	.LASF60
 2989 04ef 01       		.byte	0x1
 2990 04f0 A604     		.2byte	0x4a6
 2991 04f2 53000000 		.4byte	0x53
 2992 04f6 02       		.uleb128 0x2
 2993 04f7 91       		.byte	0x91
 2994 04f8 74       		.sleb128 -12
 2995 04f9 0C       		.uleb128 0xc
 2996 04fa FD040000 		.4byte	.LASF48
 2997 04fe 01       		.byte	0x1
 2998 04ff A704     		.2byte	0x4a7
 2999 0501 3A000000 		.4byte	0x3a
 3000 0505 02       		.uleb128 0x2
 3001 0506 91       		.byte	0x91
 3002 0507 70       		.sleb128 -16
 3003 0508 0C       		.uleb128 0xc
 3004 0509 42040000 		.4byte	.LASF25
 3005 050d 01       		.byte	0x1
 3006 050e A804     		.2byte	0x4a8
 3007 0510 2C000000 		.4byte	0x2c
 3008 0514 02       		.uleb128 0x2
 3009 0515 91       		.byte	0x91
 3010 0516 67       		.sleb128 -25
 3011 0517 0C       		.uleb128 0xc
 3012 0518 25030000 		.4byte	.LASF56
 3013 051c 01       		.byte	0x1
 3014 051d A904     		.2byte	0x4a9
 3015 051f 2C000000 		.4byte	0x2c
 3016 0523 02       		.uleb128 0x2
 3017 0524 91       		.byte	0x91
 3018 0525 6F       		.sleb128 -17
 3019 0526 0E       		.uleb128 0xe
 3020 0527 6900     		.ascii	"i\000"
 3021 0529 01       		.byte	0x1
 3022 052a AA04     		.2byte	0x4aa
 3023 052c 2C000000 		.4byte	0x2c
 3024 0530 02       		.uleb128 0x2
 3025 0531 91       		.byte	0x91
 3026 0532 73       		.sleb128 -13
 3027 0533 0C       		.uleb128 0xc
 3028 0534 91040000 		.4byte	.LASF57
 3029 0538 01       		.byte	0x1
 3030 0539 AB04     		.2byte	0x4ab
 3031 053b B1040000 		.4byte	0x4b1
 3032 053f 03       		.uleb128 0x3
 3033 0540 91       		.byte	0x91
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 79


 3034 0541 A47F     		.sleb128 -92
 3035 0543 0C       		.uleb128 0xc
 3036 0544 BD020000 		.4byte	.LASF61
 3037 0548 01       		.byte	0x1
 3038 0549 AC04     		.2byte	0x4ac
 3039 054b B1040000 		.4byte	0x4b1
 3040 054f 03       		.uleb128 0x3
 3041 0550 91       		.byte	0x91
 3042 0551 E47E     		.sleb128 -156
 3043 0553 0C       		.uleb128 0xc
 3044 0554 01040000 		.4byte	.LASF27
 3045 0558 01       		.byte	0x1
 3046 0559 AD04     		.2byte	0x4ad
 3047 055b 2C000000 		.4byte	0x2c
 3048 055f 02       		.uleb128 0x2
 3049 0560 91       		.byte	0x91
 3050 0561 72       		.sleb128 -14
 3051 0562 0C       		.uleb128 0xc
 3052 0563 D3040000 		.4byte	.LASF55
 3053 0567 01       		.byte	0x1
 3054 0568 AE04     		.2byte	0x4ae
 3055 056a 2C000000 		.4byte	0x2c
 3056 056e 02       		.uleb128 0x2
 3057 056f 91       		.byte	0x91
 3058 0570 6E       		.sleb128 -18
 3059 0571 00       		.byte	0
 3060 0572 0B       		.uleb128 0xb
 3061 0573 C5030000 		.4byte	.LASF62
 3062 0577 01       		.byte	0x1
 3063 0578 1105     		.2byte	0x511
 3064 057a 2C000000 		.4byte	0x2c
 3065 057e 00000000 		.4byte	.LFB77
 3066 0582 7C000000 		.4byte	.LFE77-.LFB77
 3067 0586 01       		.uleb128 0x1
 3068 0587 9C       		.byte	0x9c
 3069 0588 BA050000 		.4byte	0x5ba
 3070 058c 0C       		.uleb128 0xc
 3071 058d EF030000 		.4byte	.LASF63
 3072 0591 01       		.byte	0x1
 3073 0592 1305     		.2byte	0x513
 3074 0594 53000000 		.4byte	0x53
 3075 0598 02       		.uleb128 0x2
 3076 0599 91       		.byte	0x91
 3077 059a 70       		.sleb128 -16
 3078 059b 0C       		.uleb128 0xc
 3079 059c D4020000 		.4byte	.LASF64
 3080 05a0 01       		.byte	0x1
 3081 05a1 1405     		.2byte	0x514
 3082 05a3 3A000000 		.4byte	0x3a
 3083 05a7 02       		.uleb128 0x2
 3084 05a8 91       		.byte	0x91
 3085 05a9 76       		.sleb128 -10
 3086 05aa 0C       		.uleb128 0xc
 3087 05ab 8F000000 		.4byte	.LASF65
 3088 05af 01       		.byte	0x1
 3089 05b0 1505     		.2byte	0x515
 3090 05b2 3A000000 		.4byte	0x3a
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 80


 3091 05b6 02       		.uleb128 0x2
 3092 05b7 91       		.byte	0x91
 3093 05b8 6E       		.sleb128 -18
 3094 05b9 00       		.byte	0
 3095 05ba 12       		.uleb128 0x12
 3096 05bb DC040000 		.4byte	.LASF66
 3097 05bf 01       		.byte	0x1
 3098 05c0 4105     		.2byte	0x541
 3099 05c2 2C000000 		.4byte	0x2c
 3100 05c6 00000000 		.4byte	.LFB78
 3101 05ca 18000000 		.4byte	.LFE78-.LFB78
 3102 05ce 01       		.uleb128 0x1
 3103 05cf 9C       		.byte	0x9c
 3104 05d0 13       		.uleb128 0x13
 3105 05d1 2E040000 		.4byte	.LASF78
 3106 05d5 01       		.byte	0x1
 3107 05d6 5505     		.2byte	0x555
 3108 05d8 00000000 		.4byte	.LFB79
 3109 05dc 26000000 		.4byte	.LFE79-.LFB79
 3110 05e0 01       		.uleb128 0x1
 3111 05e1 9C       		.byte	0x9c
 3112 05e2 14       		.uleb128 0x14
 3113 05e3 C5040000 		.4byte	.LASF67
 3114 05e7 04       		.byte	0x4
 3115 05e8 55       		.byte	0x55
 3116 05e9 2C000000 		.4byte	0x2c
 3117 05ed 15       		.uleb128 0x15
 3118 05ee F0040000 		.4byte	.LASF68
 3119 05f2 05       		.byte	0x5
 3120 05f3 9606     		.2byte	0x696
 3121 05f5 F9050000 		.4byte	0x5f9
 3122 05f9 16       		.uleb128 0x16
 3123 05fa 76000000 		.4byte	0x76
 3124 05fe 17       		.uleb128 0x17
 3125 05ff A7010000 		.4byte	.LASF69
 3126 0603 01       		.byte	0x1
 3127 0604 42       		.byte	0x42
 3128 0605 53000000 		.4byte	0x53
 3129 0609 05       		.uleb128 0x5
 3130 060a 03       		.byte	0x3
 3131 060b 00000000 		.4byte	checksum_Privileged
 3132 060f 17       		.uleb128 0x17
 3133 0610 8D030000 		.4byte	.LASF70
 3134 0614 01       		.byte	0x1
 3135 0615 43       		.byte	0x43
 3136 0616 53000000 		.4byte	0x53
 3137 061a 05       		.uleb128 0x5
 3138 061b 03       		.byte	0x3
 3139 061c 00000000 		.4byte	statusCode
 3140 0620 17       		.uleb128 0x17
 3141 0621 B6020000 		.4byte	.LASF71
 3142 0625 01       		.byte	0x1
 3143 0626 45       		.byte	0x45
 3144 0627 2C000000 		.4byte	0x2c
 3145 062b 05       		.uleb128 0x5
 3146 062c 03       		.byte	0x3
 3147 062d 00000000 		.4byte	result
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 81


 3148 0631 17       		.uleb128 0x17
 3149 0632 6D010000 		.4byte	.LASF72
 3150 0636 01       		.byte	0x1
 3151 0637 46       		.byte	0x46
 3152 0638 2C000000 		.4byte	0x2c
 3153 063c 05       		.uleb128 0x5
 3154 063d 03       		.byte	0x3
 3155 063e 00000000 		.4byte	chipProtectionData_Chip
 3156 0642 17       		.uleb128 0x17
 3157 0643 FC030000 		.4byte	.LASF73
 3158 0647 01       		.byte	0x1
 3159 0648 48       		.byte	0x48
 3160 0649 A3000000 		.4byte	0xa3
 3161 064d 05       		.uleb128 0x5
 3162 064e 03       		.byte	0x3
 3163 064f 00000000 		.4byte	flow
 3164 0653 00       		.byte	0
 3165              		.section	.debug_abbrev,"",%progbits
 3166              	.Ldebug_abbrev0:
 3167 0000 01       		.uleb128 0x1
 3168 0001 11       		.uleb128 0x11
 3169 0002 01       		.byte	0x1
 3170 0003 25       		.uleb128 0x25
 3171 0004 0E       		.uleb128 0xe
 3172 0005 13       		.uleb128 0x13
 3173 0006 0B       		.uleb128 0xb
 3174 0007 03       		.uleb128 0x3
 3175 0008 0E       		.uleb128 0xe
 3176 0009 1B       		.uleb128 0x1b
 3177 000a 0E       		.uleb128 0xe
 3178 000b 55       		.uleb128 0x55
 3179 000c 17       		.uleb128 0x17
 3180 000d 11       		.uleb128 0x11
 3181 000e 01       		.uleb128 0x1
 3182 000f 10       		.uleb128 0x10
 3183 0010 17       		.uleb128 0x17
 3184 0011 00       		.byte	0
 3185 0012 00       		.byte	0
 3186 0013 02       		.uleb128 0x2
 3187 0014 24       		.uleb128 0x24
 3188 0015 00       		.byte	0
 3189 0016 0B       		.uleb128 0xb
 3190 0017 0B       		.uleb128 0xb
 3191 0018 3E       		.uleb128 0x3e
 3192 0019 0B       		.uleb128 0xb
 3193 001a 03       		.uleb128 0x3
 3194 001b 0E       		.uleb128 0xe
 3195 001c 00       		.byte	0
 3196 001d 00       		.byte	0
 3197 001e 03       		.uleb128 0x3
 3198 001f 16       		.uleb128 0x16
 3199 0020 00       		.byte	0
 3200 0021 03       		.uleb128 0x3
 3201 0022 0E       		.uleb128 0xe
 3202 0023 3A       		.uleb128 0x3a
 3203 0024 0B       		.uleb128 0xb
 3204 0025 3B       		.uleb128 0x3b
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 82


 3205 0026 0B       		.uleb128 0xb
 3206 0027 49       		.uleb128 0x49
 3207 0028 13       		.uleb128 0x13
 3208 0029 00       		.byte	0
 3209 002a 00       		.byte	0
 3210 002b 04       		.uleb128 0x4
 3211 002c 24       		.uleb128 0x24
 3212 002d 00       		.byte	0
 3213 002e 0B       		.uleb128 0xb
 3214 002f 0B       		.uleb128 0xb
 3215 0030 3E       		.uleb128 0x3e
 3216 0031 0B       		.uleb128 0xb
 3217 0032 03       		.uleb128 0x3
 3218 0033 08       		.uleb128 0x8
 3219 0034 00       		.byte	0
 3220 0035 00       		.byte	0
 3221 0036 05       		.uleb128 0x5
 3222 0037 0F       		.uleb128 0xf
 3223 0038 00       		.byte	0
 3224 0039 0B       		.uleb128 0xb
 3225 003a 0B       		.uleb128 0xb
 3226 003b 49       		.uleb128 0x49
 3227 003c 13       		.uleb128 0x13
 3228 003d 00       		.byte	0
 3229 003e 00       		.byte	0
 3230 003f 06       		.uleb128 0x6
 3231 0040 04       		.uleb128 0x4
 3232 0041 01       		.byte	0x1
 3233 0042 03       		.uleb128 0x3
 3234 0043 0E       		.uleb128 0xe
 3235 0044 0B       		.uleb128 0xb
 3236 0045 0B       		.uleb128 0xb
 3237 0046 3A       		.uleb128 0x3a
 3238 0047 0B       		.uleb128 0xb
 3239 0048 3B       		.uleb128 0x3b
 3240 0049 0B       		.uleb128 0xb
 3241 004a 01       		.uleb128 0x1
 3242 004b 13       		.uleb128 0x13
 3243 004c 00       		.byte	0
 3244 004d 00       		.byte	0
 3245 004e 07       		.uleb128 0x7
 3246 004f 28       		.uleb128 0x28
 3247 0050 00       		.byte	0
 3248 0051 03       		.uleb128 0x3
 3249 0052 0E       		.uleb128 0xe
 3250 0053 1C       		.uleb128 0x1c
 3251 0054 0D       		.uleb128 0xd
 3252 0055 00       		.byte	0
 3253 0056 00       		.byte	0
 3254 0057 08       		.uleb128 0x8
 3255 0058 2E       		.uleb128 0x2e
 3256 0059 01       		.byte	0x1
 3257 005a 3F       		.uleb128 0x3f
 3258 005b 19       		.uleb128 0x19
 3259 005c 03       		.uleb128 0x3
 3260 005d 0E       		.uleb128 0xe
 3261 005e 3A       		.uleb128 0x3a
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 83


 3262 005f 0B       		.uleb128 0xb
 3263 0060 3B       		.uleb128 0x3b
 3264 0061 0B       		.uleb128 0xb
 3265 0062 27       		.uleb128 0x27
 3266 0063 19       		.uleb128 0x19
 3267 0064 49       		.uleb128 0x49
 3268 0065 13       		.uleb128 0x13
 3269 0066 11       		.uleb128 0x11
 3270 0067 01       		.uleb128 0x1
 3271 0068 12       		.uleb128 0x12
 3272 0069 06       		.uleb128 0x6
 3273 006a 40       		.uleb128 0x40
 3274 006b 18       		.uleb128 0x18
 3275 006c 9642     		.uleb128 0x2116
 3276 006e 19       		.uleb128 0x19
 3277 006f 01       		.uleb128 0x1
 3278 0070 13       		.uleb128 0x13
 3279 0071 00       		.byte	0
 3280 0072 00       		.byte	0
 3281 0073 09       		.uleb128 0x9
 3282 0074 34       		.uleb128 0x34
 3283 0075 00       		.byte	0
 3284 0076 03       		.uleb128 0x3
 3285 0077 0E       		.uleb128 0xe
 3286 0078 3A       		.uleb128 0x3a
 3287 0079 0B       		.uleb128 0xb
 3288 007a 3B       		.uleb128 0x3b
 3289 007b 0B       		.uleb128 0xb
 3290 007c 49       		.uleb128 0x49
 3291 007d 13       		.uleb128 0x13
 3292 007e 02       		.uleb128 0x2
 3293 007f 18       		.uleb128 0x18
 3294 0080 00       		.byte	0
 3295 0081 00       		.byte	0
 3296 0082 0A       		.uleb128 0xa
 3297 0083 2E       		.uleb128 0x2e
 3298 0084 00       		.byte	0
 3299 0085 3F       		.uleb128 0x3f
 3300 0086 19       		.uleb128 0x19
 3301 0087 03       		.uleb128 0x3
 3302 0088 0E       		.uleb128 0xe
 3303 0089 3A       		.uleb128 0x3a
 3304 008a 0B       		.uleb128 0xb
 3305 008b 3B       		.uleb128 0x3b
 3306 008c 0B       		.uleb128 0xb
 3307 008d 27       		.uleb128 0x27
 3308 008e 19       		.uleb128 0x19
 3309 008f 49       		.uleb128 0x49
 3310 0090 13       		.uleb128 0x13
 3311 0091 11       		.uleb128 0x11
 3312 0092 01       		.uleb128 0x1
 3313 0093 12       		.uleb128 0x12
 3314 0094 06       		.uleb128 0x6
 3315 0095 40       		.uleb128 0x40
 3316 0096 18       		.uleb128 0x18
 3317 0097 9742     		.uleb128 0x2117
 3318 0099 19       		.uleb128 0x19
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 84


 3319 009a 00       		.byte	0
 3320 009b 00       		.byte	0
 3321 009c 0B       		.uleb128 0xb
 3322 009d 2E       		.uleb128 0x2e
 3323 009e 01       		.byte	0x1
 3324 009f 3F       		.uleb128 0x3f
 3325 00a0 19       		.uleb128 0x19
 3326 00a1 03       		.uleb128 0x3
 3327 00a2 0E       		.uleb128 0xe
 3328 00a3 3A       		.uleb128 0x3a
 3329 00a4 0B       		.uleb128 0xb
 3330 00a5 3B       		.uleb128 0x3b
 3331 00a6 05       		.uleb128 0x5
 3332 00a7 27       		.uleb128 0x27
 3333 00a8 19       		.uleb128 0x19
 3334 00a9 49       		.uleb128 0x49
 3335 00aa 13       		.uleb128 0x13
 3336 00ab 11       		.uleb128 0x11
 3337 00ac 01       		.uleb128 0x1
 3338 00ad 12       		.uleb128 0x12
 3339 00ae 06       		.uleb128 0x6
 3340 00af 40       		.uleb128 0x40
 3341 00b0 18       		.uleb128 0x18
 3342 00b1 9642     		.uleb128 0x2116
 3343 00b3 19       		.uleb128 0x19
 3344 00b4 01       		.uleb128 0x1
 3345 00b5 13       		.uleb128 0x13
 3346 00b6 00       		.byte	0
 3347 00b7 00       		.byte	0
 3348 00b8 0C       		.uleb128 0xc
 3349 00b9 34       		.uleb128 0x34
 3350 00ba 00       		.byte	0
 3351 00bb 03       		.uleb128 0x3
 3352 00bc 0E       		.uleb128 0xe
 3353 00bd 3A       		.uleb128 0x3a
 3354 00be 0B       		.uleb128 0xb
 3355 00bf 3B       		.uleb128 0x3b
 3356 00c0 05       		.uleb128 0x5
 3357 00c1 49       		.uleb128 0x49
 3358 00c2 13       		.uleb128 0x13
 3359 00c3 02       		.uleb128 0x2
 3360 00c4 18       		.uleb128 0x18
 3361 00c5 00       		.byte	0
 3362 00c6 00       		.byte	0
 3363 00c7 0D       		.uleb128 0xd
 3364 00c8 05       		.uleb128 0x5
 3365 00c9 00       		.byte	0
 3366 00ca 03       		.uleb128 0x3
 3367 00cb 0E       		.uleb128 0xe
 3368 00cc 3A       		.uleb128 0x3a
 3369 00cd 0B       		.uleb128 0xb
 3370 00ce 3B       		.uleb128 0x3b
 3371 00cf 05       		.uleb128 0x5
 3372 00d0 49       		.uleb128 0x49
 3373 00d1 13       		.uleb128 0x13
 3374 00d2 02       		.uleb128 0x2
 3375 00d3 18       		.uleb128 0x18
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 85


 3376 00d4 00       		.byte	0
 3377 00d5 00       		.byte	0
 3378 00d6 0E       		.uleb128 0xe
 3379 00d7 34       		.uleb128 0x34
 3380 00d8 00       		.byte	0
 3381 00d9 03       		.uleb128 0x3
 3382 00da 08       		.uleb128 0x8
 3383 00db 3A       		.uleb128 0x3a
 3384 00dc 0B       		.uleb128 0xb
 3385 00dd 3B       		.uleb128 0x3b
 3386 00de 05       		.uleb128 0x5
 3387 00df 49       		.uleb128 0x49
 3388 00e0 13       		.uleb128 0x13
 3389 00e1 02       		.uleb128 0x2
 3390 00e2 18       		.uleb128 0x18
 3391 00e3 00       		.byte	0
 3392 00e4 00       		.byte	0
 3393 00e5 0F       		.uleb128 0xf
 3394 00e6 2E       		.uleb128 0x2e
 3395 00e7 00       		.byte	0
 3396 00e8 3F       		.uleb128 0x3f
 3397 00e9 19       		.uleb128 0x19
 3398 00ea 03       		.uleb128 0x3
 3399 00eb 0E       		.uleb128 0xe
 3400 00ec 3A       		.uleb128 0x3a
 3401 00ed 0B       		.uleb128 0xb
 3402 00ee 3B       		.uleb128 0x3b
 3403 00ef 05       		.uleb128 0x5
 3404 00f0 27       		.uleb128 0x27
 3405 00f1 19       		.uleb128 0x19
 3406 00f2 49       		.uleb128 0x49
 3407 00f3 13       		.uleb128 0x13
 3408 00f4 11       		.uleb128 0x11
 3409 00f5 01       		.uleb128 0x1
 3410 00f6 12       		.uleb128 0x12
 3411 00f7 06       		.uleb128 0x6
 3412 00f8 40       		.uleb128 0x40
 3413 00f9 18       		.uleb128 0x18
 3414 00fa 9642     		.uleb128 0x2116
 3415 00fc 19       		.uleb128 0x19
 3416 00fd 00       		.byte	0
 3417 00fe 00       		.byte	0
 3418 00ff 10       		.uleb128 0x10
 3419 0100 01       		.uleb128 0x1
 3420 0101 01       		.byte	0x1
 3421 0102 49       		.uleb128 0x49
 3422 0103 13       		.uleb128 0x13
 3423 0104 01       		.uleb128 0x1
 3424 0105 13       		.uleb128 0x13
 3425 0106 00       		.byte	0
 3426 0107 00       		.byte	0
 3427 0108 11       		.uleb128 0x11
 3428 0109 21       		.uleb128 0x21
 3429 010a 00       		.byte	0
 3430 010b 49       		.uleb128 0x49
 3431 010c 13       		.uleb128 0x13
 3432 010d 2F       		.uleb128 0x2f
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 86


 3433 010e 0B       		.uleb128 0xb
 3434 010f 00       		.byte	0
 3435 0110 00       		.byte	0
 3436 0111 12       		.uleb128 0x12
 3437 0112 2E       		.uleb128 0x2e
 3438 0113 00       		.byte	0
 3439 0114 3F       		.uleb128 0x3f
 3440 0115 19       		.uleb128 0x19
 3441 0116 03       		.uleb128 0x3
 3442 0117 0E       		.uleb128 0xe
 3443 0118 3A       		.uleb128 0x3a
 3444 0119 0B       		.uleb128 0xb
 3445 011a 3B       		.uleb128 0x3b
 3446 011b 05       		.uleb128 0x5
 3447 011c 27       		.uleb128 0x27
 3448 011d 19       		.uleb128 0x19
 3449 011e 49       		.uleb128 0x49
 3450 011f 13       		.uleb128 0x13
 3451 0120 11       		.uleb128 0x11
 3452 0121 01       		.uleb128 0x1
 3453 0122 12       		.uleb128 0x12
 3454 0123 06       		.uleb128 0x6
 3455 0124 40       		.uleb128 0x40
 3456 0125 18       		.uleb128 0x18
 3457 0126 9742     		.uleb128 0x2117
 3458 0128 19       		.uleb128 0x19
 3459 0129 00       		.byte	0
 3460 012a 00       		.byte	0
 3461 012b 13       		.uleb128 0x13
 3462 012c 2E       		.uleb128 0x2e
 3463 012d 00       		.byte	0
 3464 012e 3F       		.uleb128 0x3f
 3465 012f 19       		.uleb128 0x19
 3466 0130 03       		.uleb128 0x3
 3467 0131 0E       		.uleb128 0xe
 3468 0132 3A       		.uleb128 0x3a
 3469 0133 0B       		.uleb128 0xb
 3470 0134 3B       		.uleb128 0x3b
 3471 0135 05       		.uleb128 0x5
 3472 0136 27       		.uleb128 0x27
 3473 0137 19       		.uleb128 0x19
 3474 0138 11       		.uleb128 0x11
 3475 0139 01       		.uleb128 0x1
 3476 013a 12       		.uleb128 0x12
 3477 013b 06       		.uleb128 0x6
 3478 013c 40       		.uleb128 0x40
 3479 013d 18       		.uleb128 0x18
 3480 013e 9642     		.uleb128 0x2116
 3481 0140 19       		.uleb128 0x19
 3482 0141 00       		.byte	0
 3483 0142 00       		.byte	0
 3484 0143 14       		.uleb128 0x14
 3485 0144 34       		.uleb128 0x34
 3486 0145 00       		.byte	0
 3487 0146 03       		.uleb128 0x3
 3488 0147 0E       		.uleb128 0xe
 3489 0148 3A       		.uleb128 0x3a
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 87


 3490 0149 0B       		.uleb128 0xb
 3491 014a 3B       		.uleb128 0x3b
 3492 014b 0B       		.uleb128 0xb
 3493 014c 49       		.uleb128 0x49
 3494 014d 13       		.uleb128 0x13
 3495 014e 3F       		.uleb128 0x3f
 3496 014f 19       		.uleb128 0x19
 3497 0150 3C       		.uleb128 0x3c
 3498 0151 19       		.uleb128 0x19
 3499 0152 00       		.byte	0
 3500 0153 00       		.byte	0
 3501 0154 15       		.uleb128 0x15
 3502 0155 34       		.uleb128 0x34
 3503 0156 00       		.byte	0
 3504 0157 03       		.uleb128 0x3
 3505 0158 0E       		.uleb128 0xe
 3506 0159 3A       		.uleb128 0x3a
 3507 015a 0B       		.uleb128 0xb
 3508 015b 3B       		.uleb128 0x3b
 3509 015c 05       		.uleb128 0x5
 3510 015d 49       		.uleb128 0x49
 3511 015e 13       		.uleb128 0x13
 3512 015f 3F       		.uleb128 0x3f
 3513 0160 19       		.uleb128 0x19
 3514 0161 3C       		.uleb128 0x3c
 3515 0162 19       		.uleb128 0x19
 3516 0163 00       		.byte	0
 3517 0164 00       		.byte	0
 3518 0165 16       		.uleb128 0x16
 3519 0166 35       		.uleb128 0x35
 3520 0167 00       		.byte	0
 3521 0168 49       		.uleb128 0x49
 3522 0169 13       		.uleb128 0x13
 3523 016a 00       		.byte	0
 3524 016b 00       		.byte	0
 3525 016c 17       		.uleb128 0x17
 3526 016d 34       		.uleb128 0x34
 3527 016e 00       		.byte	0
 3528 016f 03       		.uleb128 0x3
 3529 0170 0E       		.uleb128 0xe
 3530 0171 3A       		.uleb128 0x3a
 3531 0172 0B       		.uleb128 0xb
 3532 0173 3B       		.uleb128 0x3b
 3533 0174 0B       		.uleb128 0xb
 3534 0175 49       		.uleb128 0x49
 3535 0176 13       		.uleb128 0x13
 3536 0177 3F       		.uleb128 0x3f
 3537 0178 19       		.uleb128 0x19
 3538 0179 02       		.uleb128 0x2
 3539 017a 18       		.uleb128 0x18
 3540 017b 00       		.byte	0
 3541 017c 00       		.byte	0
 3542 017d 00       		.byte	0
 3543              		.section	.debug_aranges,"",%progbits
 3544 0000 9C000000 		.4byte	0x9c
 3545 0004 0200     		.2byte	0x2
 3546 0006 00000000 		.4byte	.Ldebug_info0
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 88


 3547 000a 04       		.byte	0x4
 3548 000b 00       		.byte	0
 3549 000c 0000     		.2byte	0
 3550 000e 0000     		.2byte	0
 3551 0010 00000000 		.4byte	.LFB63
 3552 0014 9C000000 		.4byte	.LFE63-.LFB63
 3553 0018 00000000 		.4byte	.LFB64
 3554 001c 18000000 		.4byte	.LFE64-.LFB64
 3555 0020 00000000 		.4byte	.LFB65
 3556 0024 94000000 		.4byte	.LFE65-.LFB65
 3557 0028 00000000 		.4byte	.LFB66
 3558 002c A4000000 		.4byte	.LFE66-.LFB66
 3559 0030 00000000 		.4byte	.LFB67
 3560 0034 24010000 		.4byte	.LFE67-.LFB67
 3561 0038 00000000 		.4byte	.LFB68
 3562 003c AC000000 		.4byte	.LFE68-.LFB68
 3563 0040 00000000 		.4byte	.LFB69
 3564 0044 34010000 		.4byte	.LFE69-.LFB69
 3565 0048 00000000 		.4byte	.LFB70
 3566 004c 00010000 		.4byte	.LFE70-.LFB70
 3567 0050 00000000 		.4byte	.LFB71
 3568 0054 24010000 		.4byte	.LFE71-.LFB71
 3569 0058 00000000 		.4byte	.LFB72
 3570 005c 30000000 		.4byte	.LFE72-.LFB72
 3571 0060 00000000 		.4byte	.LFB73
 3572 0064 20010000 		.4byte	.LFE73-.LFB73
 3573 0068 00000000 		.4byte	.LFB74
 3574 006c 30010000 		.4byte	.LFE74-.LFB74
 3575 0070 00000000 		.4byte	.LFB75
 3576 0074 20010000 		.4byte	.LFE75-.LFB75
 3577 0078 00000000 		.4byte	.LFB76
 3578 007c 18020000 		.4byte	.LFE76-.LFB76
 3579 0080 00000000 		.4byte	.LFB77
 3580 0084 7C000000 		.4byte	.LFE77-.LFB77
 3581 0088 00000000 		.4byte	.LFB78
 3582 008c 18000000 		.4byte	.LFE78-.LFB78
 3583 0090 00000000 		.4byte	.LFB79
 3584 0094 26000000 		.4byte	.LFE79-.LFB79
 3585 0098 00000000 		.4byte	0
 3586 009c 00000000 		.4byte	0
 3587              		.section	.debug_ranges,"",%progbits
 3588              	.Ldebug_ranges0:
 3589 0000 00000000 		.4byte	.LFB63
 3590 0004 9C000000 		.4byte	.LFE63
 3591 0008 00000000 		.4byte	.LFB64
 3592 000c 18000000 		.4byte	.LFE64
 3593 0010 00000000 		.4byte	.LFB65
 3594 0014 94000000 		.4byte	.LFE65
 3595 0018 00000000 		.4byte	.LFB66
 3596 001c A4000000 		.4byte	.LFE66
 3597 0020 00000000 		.4byte	.LFB67
 3598 0024 24010000 		.4byte	.LFE67
 3599 0028 00000000 		.4byte	.LFB68
 3600 002c AC000000 		.4byte	.LFE68
 3601 0030 00000000 		.4byte	.LFB69
 3602 0034 34010000 		.4byte	.LFE69
 3603 0038 00000000 		.4byte	.LFB70
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 89


 3604 003c 00010000 		.4byte	.LFE70
 3605 0040 00000000 		.4byte	.LFB71
 3606 0044 24010000 		.4byte	.LFE71
 3607 0048 00000000 		.4byte	.LFB72
 3608 004c 30000000 		.4byte	.LFE72
 3609 0050 00000000 		.4byte	.LFB73
 3610 0054 20010000 		.4byte	.LFE73
 3611 0058 00000000 		.4byte	.LFB74
 3612 005c 30010000 		.4byte	.LFE74
 3613 0060 00000000 		.4byte	.LFB75
 3614 0064 20010000 		.4byte	.LFE75
 3615 0068 00000000 		.4byte	.LFB76
 3616 006c 18020000 		.4byte	.LFE76
 3617 0070 00000000 		.4byte	.LFB77
 3618 0074 7C000000 		.4byte	.LFE77
 3619 0078 00000000 		.4byte	.LFB78
 3620 007c 18000000 		.4byte	.LFE78
 3621 0080 00000000 		.4byte	.LFB79
 3622 0084 26000000 		.4byte	.LFE79
 3623 0088 00000000 		.4byte	0
 3624 008c 00000000 		.4byte	0
 3625              		.section	.debug_line,"",%progbits
 3626              	.Ldebug_line0:
 3627 0000 F5040000 		.section	.debug_str,"MS",%progbits,1
 3627      02004F01 
 3627      00000201 
 3627      FB0E0D00 
 3627      01010101 
 3628              	.LASF18:
 3629 0000 57524F4E 		.ascii	"WRONG_TRANSITION\000"
 3629      475F5452 
 3629      414E5349 
 3629      54494F4E 
 3629      00
 3630              	.LASF35:
 3631 0011 44657669 		.ascii	"DeviceAcquire\000"
 3631      63654163 
 3631      71756972 
 3631      6500
 3632              	.LASF44:
 3633 001f 45726173 		.ascii	"EraseAllFlash\000"
 3633      65416C6C 
 3633      466C6173 
 3633      6800
 3634              	.LASF60:
 3635 002d 666C6173 		.ascii	"flashProtectionAddress\000"
 3635      6850726F 
 3635      74656374 
 3635      696F6E41 
 3635      64647265 
 3636              	.LASF54:
 3637 0044 50726F67 		.ascii	"ProgramProtectionSettings\000"
 3637      72616D50 
 3637      726F7465 
 3637      6374696F 
 3637      6E536574 
 3638              	.LASF42:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 90


 3639 005e 73696C69 		.ascii	"siliconIdData1\000"
 3639      636F6E49 
 3639      64446174 
 3639      613100
 3640              	.LASF43:
 3641 006d 73696C69 		.ascii	"siliconIdData2\000"
 3641      636F6E49 
 3641      64446174 
 3641      613200
 3642              	.LASF52:
 3643 007c 726F7741 		.ascii	"rowAddress\000"
 3643      64647265 
 3643      737300
 3644              	.LASF28:
 3645 0087 726F7744 		.ascii	"rowData\000"
 3645      61746100 
 3646              	.LASF65:
 3647 008f 63686563 		.ascii	"checksumData\000"
 3647      6B73756D 
 3647      44617461 
 3647      00
 3648              	.LASF2:
 3649 009c 73686F72 		.ascii	"short int\000"
 3649      7420696E 
 3649      7400
 3650              	.LASF40:
 3651 00a6 64657669 		.ascii	"deviceSiliconID\000"
 3651      63655369 
 3651      6C69636F 
 3651      6E494400 
 3652              	.LASF14:
 3653 00b6 73697A65 		.ascii	"sizetype\000"
 3653      74797065 
 3653      00
 3654              	.LASF36:
 3655 00bf 63686970 		.ascii	"chip_DAP_Id\000"
 3655      5F444150 
 3655      5F496400 
 3656              	.LASF24:
 3657 00cb 47657454 		.ascii	"GetTransitionMode\000"
 3657      72616E73 
 3657      6974696F 
 3657      6E4D6F64 
 3657      6500
 3658              	.LASF75:
 3659 00dd 50726F67 		.ascii	"ProgrammingSteps.c\000"
 3659      72616D6D 
 3659      696E6753 
 3659      74657073 
 3659      2E6300
 3660              	.LASF76:
 3661 00f0 443A5C55 		.ascii	"D:\\Users\\WorkBench\\Documents\\GitHub\\BackboneHS"
 3661      73657273 
 3661      5C576F72 
 3661      6B42656E 
 3661      63685C44 
 3662 011e 53505C50 		.ascii	"SP\\Programmer\\Programmer.cydsn\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 91


 3662      726F6772 
 3662      616D6D65 
 3662      725C5072 
 3662      6F677261 
 3663              	.LASF6:
 3664 013d 6C6F6E67 		.ascii	"long long int\000"
 3664      206C6F6E 
 3664      6720696E 
 3664      7400
 3665              	.LASF32:
 3666 014b 63686563 		.ascii	"checksumRow\000"
 3666      6B73756D 
 3666      526F7700 
 3667              	.LASF22:
 3668 0157 70617261 		.ascii	"parameter1\000"
 3668      6D657465 
 3668      723100
 3669              	.LASF30:
 3670 0162 70617261 		.ascii	"parameter2\000"
 3670      6D657465 
 3670      723200
 3671              	.LASF72:
 3672 016d 63686970 		.ascii	"chipProtectionData_Chip\000"
 3672      50726F74 
 3672      65637469 
 3672      6F6E4461 
 3672      74615F43 
 3673              	.LASF33:
 3674 0185 63686563 		.ascii	"checksum\000"
 3674      6B73756D 
 3674      00
 3675              	.LASF29:
 3676 018e 726F7742 		.ascii	"rowByteSize\000"
 3676      79746553 
 3676      697A6500 
 3677              	.LASF47:
 3678 019a 50726F67 		.ascii	"ProgramFlash\000"
 3678      72616D46 
 3678      6C617368 
 3678      00
 3679              	.LASF69:
 3680 01a7 63686563 		.ascii	"checksum_Privileged\000"
 3680      6B73756D 
 3680      5F507269 
 3680      76696C65 
 3680      67656400 
 3681              	.LASF0:
 3682 01bb 7369676E 		.ascii	"signed char\000"
 3682      65642063 
 3682      68617200 
 3683              	.LASF11:
 3684 01c7 666C6F61 		.ascii	"float\000"
 3684      7400
 3685              	.LASF59:
 3686 01cd 70726F74 		.ascii	"protectionData\000"
 3686      65637469 
 3686      6F6E4461 
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 92


 3686      746100
 3687              	.LASF39:
 3688 01dc 56657269 		.ascii	"VerifySiliconId\000"
 3688      66795369 
 3688      6C69636F 
 3688      6E496400 
 3689              	.LASF23:
 3690 01ec 63686970 		.ascii	"chipProtData\000"
 3690      50726F74 
 3690      44617461 
 3690      00
 3691              	.LASF21:
 3692 01f9 74696D65 		.ascii	"time_elapsed\000"
 3692      5F656C61 
 3692      70736564 
 3692      00
 3693              	.LASF74:
 3694 0206 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 3694      4320342E 
 3694      392E3320 
 3694      32303135 
 3694      30333033 
 3695 0239 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 3695      20726576 
 3695      6973696F 
 3695      6E203232 
 3695      31323230 
 3696 026c 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 3696      66756E63 
 3696      74696F6E 
 3696      2D736563 
 3696      74696F6E 
 3697              	.LASF58:
 3698 0294 56657269 		.ascii	"VerifyProtectionSettings\000"
 3698      66795072 
 3698      6F746563 
 3698      74696F6E 
 3698      53657474 
 3699              	.LASF15:
 3700 02ad 4F50454E 		.ascii	"OPEN_XXX\000"
 3700      5F585858 
 3700      00
 3701              	.LASF71:
 3702 02b6 72657375 		.ascii	"result\000"
 3702      6C7400
 3703              	.LASF61:
 3704 02bd 726F7750 		.ascii	"rowProtectionFlashData\000"
 3704      726F7465 
 3704      6374696F 
 3704      6E466C61 
 3704      73684461 
 3705              	.LASF64:
 3706 02d4 63686970 		.ascii	"chip_Checksum\000"
 3706      5F436865 
 3706      636B7375 
 3706      6D00
 3707              	.LASF53:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 93


 3708 02e2 63686970 		.ascii	"chipData\000"
 3708      44617461 
 3708      00
 3709              	.LASF51:
 3710 02eb 666C6173 		.ascii	"flashData\000"
 3710      68446174 
 3710      6100
 3711              	.LASF1:
 3712 02f5 756E7369 		.ascii	"unsigned char\000"
 3712      676E6564 
 3712      20636861 
 3712      7200
 3713              	.LASF45:
 3714 0303 52656164 		.ascii	"ReadSromStatus\000"
 3714      53726F6D 
 3714      53746174 
 3714      757300
 3715              	.LASF37:
 3716 0312 746F7461 		.ascii	"total_packet_count\000"
 3716      6C5F7061 
 3716      636B6574 
 3716      5F636F75 
 3716      6E7400
 3717              	.LASF56:
 3718 0325 726F7750 		.ascii	"rowProtectionByteSize\000"
 3718      726F7465 
 3718      6374696F 
 3718      6E427974 
 3718      6553697A 
 3719              	.LASF50:
 3720 033b 56657269 		.ascii	"VerifyFlash\000"
 3720      6679466C 
 3720      61736800 
 3721              	.LASF7:
 3722 0347 6C6F6E67 		.ascii	"long long unsigned int\000"
 3722      206C6F6E 
 3722      6720756E 
 3722      7369676E 
 3722      65642069 
 3723              	.LASF46:
 3724 035e 43686563 		.ascii	"ChecksumPrivileged\000"
 3724      6B73756D 
 3724      50726976 
 3724      696C6567 
 3724      656400
 3725              	.LASF8:
 3726 0371 756E7369 		.ascii	"unsigned int\000"
 3726      676E6564 
 3726      20696E74 
 3726      00
 3727              	.LASF19:
 3728 037e 506F6C6C 		.ascii	"PollSromStatus\000"
 3728      53726F6D 
 3728      53746174 
 3728      757300
 3729              	.LASF70:
 3730 038d 73746174 		.ascii	"statusCode\000"
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 94


 3730      7573436F 
 3730      646500
 3731              	.LASF3:
 3732 0398 73686F72 		.ascii	"short unsigned int\000"
 3732      7420756E 
 3732      7369676E 
 3732      65642069 
 3732      6E7400
 3733              	.LASF38:
 3734 03ab 73746174 		.ascii	"status\000"
 3734      757300
 3735              	.LASF34:
 3736 03b2 63686563 		.ascii	"checksum_chip\000"
 3736      6B73756D 
 3736      5F636869 
 3736      7000
 3737              	.LASF13:
 3738 03c0 63686172 		.ascii	"char\000"
 3738      00
 3739              	.LASF62:
 3740 03c5 56657269 		.ascii	"VerifyChecksum\000"
 3740      66794368 
 3740      65636B73 
 3740      756D00
 3741              	.LASF4:
 3742 03d4 6C6F6E67 		.ascii	"long int\000"
 3742      20696E74 
 3742      00
 3743              	.LASF26:
 3744 03dd 4C6F6164 		.ascii	"LoadLatch\000"
 3744      4C617463 
 3744      6800
 3745              	.LASF10:
 3746 03e7 696E7433 		.ascii	"int32_t\000"
 3746      325F7400 
 3747              	.LASF63:
 3748 03ef 63686563 		.ascii	"checksum_All\000"
 3748      6B73756D 
 3748      5F416C6C 
 3748      00
 3749              	.LASF73:
 3750 03fc 666C6F77 		.ascii	"flow\000"
 3750      00
 3751              	.LASF27:
 3752 0401 61727261 		.ascii	"arrayID\000"
 3752      79494400 
 3753              	.LASF5:
 3754 0409 6C6F6E67 		.ascii	"long unsigned int\000"
 3754      20756E73 
 3754      69676E65 
 3754      6420696E 
 3754      7400
 3755              	.LASF31:
 3756 041b 43686563 		.ascii	"ChecksumAPI\000"
 3756      6B73756D 
 3756      41504900 
 3757              	.LASF12:
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 95


 3758 0427 646F7562 		.ascii	"double\000"
 3758      6C6500
 3759              	.LASF78:
 3760 042e 45786974 		.ascii	"ExitProgrammingMode\000"
 3760      50726F67 
 3760      72616D6D 
 3760      696E674D 
 3760      6F646500 
 3761              	.LASF25:
 3762 0442 63686970 		.ascii	"chipProtectionData_Hex\000"
 3762      50726F74 
 3762      65637469 
 3762      6F6E4461 
 3762      74615F48 
 3763              	.LASF49:
 3764 0459 726F7743 		.ascii	"rowCount\000"
 3764      6F756E74 
 3764      00
 3765              	.LASF9:
 3766 0462 5F5F696E 		.ascii	"__int32_t\000"
 3766      7433325F 
 3766      7400
 3767              	.LASF16:
 3768 046c 56495247 		.ascii	"VIRGIN_OPEN\000"
 3768      494E5F4F 
 3768      50454E00 
 3769              	.LASF77:
 3770 0478 5472616E 		.ascii	"Transition_mode\000"
 3770      73697469 
 3770      6F6E5F6D 
 3770      6F646500 
 3771              	.LASF17:
 3772 0488 50524F54 		.ascii	"PROT_XXX\000"
 3772      5F585858 
 3772      00
 3773              	.LASF57:
 3774 0491 726F7750 		.ascii	"rowProtectionData\000"
 3774      726F7465 
 3774      6374696F 
 3774      6E446174 
 3774      6100
 3775              	.LASF41:
 3776 04a3 68657853 		.ascii	"hexSiliconId\000"
 3776      696C6963 
 3776      6F6E4964 
 3776      00
 3777              	.LASF20:
 3778 04b0 47657443 		.ascii	"GetChipProtectionVal\000"
 3778      68697050 
 3778      726F7465 
 3778      6374696F 
 3778      6E56616C 
 3779              	.LASF67:
 3780 04c5 7377645F 		.ascii	"swd_PacketAck\000"
 3780      5061636B 
 3780      65744163 
 3780      6B00
ARM GAS  C:\Users\WORKBE~1\AppData\Local\Temp\cchFGJiz.s 			page 96


 3781              	.LASF55:
 3782 04d3 61727261 		.ascii	"arrayMax\000"
 3782      794D6178 
 3782      00
 3783              	.LASF66:
 3784 04dc 52656164 		.ascii	"ReadHsspErrorStatus\000"
 3784      48737370 
 3784      4572726F 
 3784      72537461 
 3784      74757300 
 3785              	.LASF68:
 3786 04f0 49544D5F 		.ascii	"ITM_RxBuffer\000"
 3786      52784275 
 3786      66666572 
 3786      00
 3787              	.LASF48:
 3788 04fd 6E756D4F 		.ascii	"numOfFlashRows\000"
 3788      66466C61 
 3788      7368526F 
 3788      777300
 3789              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
